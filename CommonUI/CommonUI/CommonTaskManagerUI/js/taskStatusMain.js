if (!(window.console && console.log)) {
    console = {
        log: function () { },
        debug: function () { },
        info: function () { },
        warn: function () { },
        error: function () { }
    };
}

var gridId = null;

function RAD_init_common_task_status(radGridId) {
    //unbind previous events on document
    gridId = radGridId;

    $(document).off("click");
    $(document).off("change");
    $(document).off("keyup");
    $(document).off("mouseenter");
    $(document).off("mouseleave");

    $(document).ready(function () {
        initializeDivFilterDate();

        var params = { clientName: $('[id*="clientName_hf"]').val()};
        CallCommonServiceMethod('GetTaskStatusInfo', params, OnSuccess_GetTaskStatusInfo, OnFailure, null, false);

        $('[id$=btnGetStatus]').unbind('click').bind('click', function (ee) {
            var selectedTaskStatusParam = "";
            var filtersSelectedData = smslidemenu.getAllData("SMDashboardRightFilterDiv"); //$("#SMDashboardRightFilter").rightFilter("getFiltersJSON");
            filtersSelectedDataSelected = filtersSelectedData;
            smslidemenu.hide("SMDashboardRightFilterDiv");
            var SelectedTaskType = filtersSelectedData.TaskType.SelectedText;
            var SelectedTaskStatus = filtersSelectedData.TaskStatus.SelectedText;
            $('#hdnGetTaskTypeWithStatus').val(SelectedTaskType + '<$>' + SelectedTaskStatus);
            ee.stopPropagation();
        });

        $('[id$=SMDashboardRefreshButton]').unbind('click').bind('click', function (ee) {
            filterApply();
        });

    });

    setPolyFills();
    $(".cts-calendar").datepicker({
        changeMonth: true,
        changeYear: true,
        showOn: "button",
        //        buttonImage: "http://jqueryui.com/resources/demos/datepicker/images/calendar.gif",
        buttonImage: "App_Themes/Aqua/images/icons/calendar.gif",
        buttonImageOnly: true
    });
    $("#ctm_trigger_as_of_date").datepicker({
        changeMonth: true,
        changeYear: true,
        showOn: "button",
        buttonImage: "App_Themes/Aqua/images/icons/calendar.gif",
        buttonImageOnly: true,
        dateFormat: 'mm/dd/yy'
    });

    var ctm_as_of_date = new Date().getFullYear() + "/" + (new Date().getMonth() + 1) + "/" + (new Date().getDate());
    $("#ctm_trigger_as_of_date").val($.datepicker.formatDate('mm/dd/yy', new Date())); //ctsEndDate))ctm_as_of_date);
    $(".datepicker").datepicker(
    {
        beforeShow: function () {
            setTimeout(function () {
                $('.ui-datepicker').css('z-index', 99999999999999);
            }, 0);
        },
        changeMonth: true,
        changeYear: true,
        showOn: "button",
        onSelect: function () {
            initCharts(globalStatusLevel);
        },
        buttonImage: "App_Themes/Aqua/images/icons/calendar.gif",
        buttonImageOnly: true
    });
    $('.datepicker, .cts-calendar').datepicker('option', 'dateFormat', 'mm/dd/yy');

    //$('#taskGanttChartPopup').draggable(); donot use- scrolling on popup causes popup to move
    //$( "#taskGanttChartPopup" ).draggable({ cancel: ".highcharts-navigator" }); doent work
    var webServicePath = $('[id$="servicePath"]').val() + ($('[id$="servicePath"]').val().endsWith("/") ? "" : "/") + "Services/TaskStatusWebMethods.asmx";
    //if ($('[id$="unsyncdTasksFlag_hf"]').val() == "True") {
    //    $('[id$="btnGetUnsyncedTasks"]').prop("disabled", false).removeClass("ctm-disabled");
    //}
    //else {
    //    $('[id$="btnGetUnsyncedTasks"]').prop("disabled", true).addClass("ctm-disabled");
    //}

    $("#chartTabs").tabs();

    $('#lightbox, .cross').click(function () {
        $('.ctm-popup').hide('slide', function () {
            $('#lightbox').hide();
        });
    });

    var globalStatusLevel = false;


    var oneWeekBefore = new Date(); oneWeekBefore.setDate(oneWeekBefore.getDate() - 7);
    $("#jsganttChartFromDate").val(oneWeekBefore.getFullYear() + "-" + (oneWeekBefore.getMonth() + 1) + "-" + (oneWeekBefore.getDate()));
    $("#jsganttChartToDate").val(new Date().getFullYear() + "-" + (new Date().getMonth() + 1) + "-" + (new Date().getDate()));
    console.log("is postback>>" + $('[id*=isPostBack_hf]').val());

    //if ($('[id*=isPostBack_hf]').val() != "True") {
    //    //$.datepicker.formatDate('mm/dd/yy', new Date());
    //    // $.datepicker.formatDate('mm/dd/yy', new Date());
    //    var ctsStartDate = new Date().getFullYear() + "/" + (new Date().getMonth() + 1) + "/" + (new Date().getDate());
    //    var ctsEndDate = new Date().getFullYear() + "/" + (new Date().getMonth() + 1) + "/" + (new Date().getDate());
    //    if ($.datepicker.formatDate('mm/dd/yy', new Date(ctsStartDate)) > $.datepicker.formatDate('mm/dd/yy', new Date(ctsEndDate))) {
    //        // $(this).dialog("close");
    //        alert("Error: Start date cannot be greater than the End date.  ");
    //    }
    //    else {
    //        $('[id*=txtEndDate]').val($.datepicker.formatDate('mm/dd/yy', new Date(ctsEndDate)));
    //        $('[id*=txtStartDate]').val($.datepicker.formatDate('mm/dd/yy', new Date(ctsStartDate)));
    //    }
    //    // $('[id*=txtEndDate]').val(new Date().getFullYear() + "-" + (new Date().getMonth() + 1) + "-" + (new Date().getDate()));
    //    //$('[id*=txtStartDate]').val(new Date().getFullYear() + "-" + (new Date().getMonth()) + "-" + (new Date().getDate()));
    //}
    //else {
    //    // if ($.datepicker.formatDate('mm/dd/yy', new Date($('[id*=startDate_hf]').val())) > $.datepicker.formatDate('mm/dd/yy', new Date($('[id*=endDate_hf]').val()))) {
    //    //  $(this).dialog("close");
    //    var startDate = new Date($('[id*=startDate_hf]').val());
    //    var endDate = new Date($('[id*=endDate_hf]').val());
    //    if (startDate.getTime() > endDate.getTime()) {
    //        $('[id*=txtEndDate]').val($.datepicker.formatDate('mm/dd/yy', new Date($('[id*=startDate_hf]').val())));
    //        alert("Error: Start date cannot be greater than the End date.  ");
    //    }
    //    else {
    //        $('[id*=txtEndDate]').val($.datepicker.formatDate('mm/dd/yy', new Date($('[id*=endDate_hf]').val())));
    //        $('[id*=txtStartDate]').val($.datepicker.formatDate('mm/dd/yy', new Date($('[id*=startDate_hf]').val())));
    //        //$('[id*=txtEndDate]').val( $('[id*=endDate_hf]').val());
    //        //$('[id*=txtStartDate]').val( $('[id*=startDate_hf]').val());
    //    }
    //}

    $('[id*=rblstDate]').eq(1).click(function () {
        $('#startDateContainer').show();
        $('#endDateContainer').show();
    });

    $('[id*=rblstDate]').eq(2).click(function () {
        $('#startDateContainer').show();
        $('#endDateContainer').hide();
    });

    $('[id*=rblstDate]').eq(3).click(function () {
        $('#startDateContainer').hide();
        $('#endDateContainer').show();
    });

    if ($('[id*=rblstDate]').eq(1).is(':checked')) {
        $('#startDateContainer').show();
        $('#endDateContainer').show();
    }

    if ($('[id*=rblstDate]').eq(2).is(':checked')) {
        $('#startDateContainer').show();
        $('#endDateContainer').hide();
    }

    if ($('[id*=rblstDate]').eq(3).is(':checked')) {
        $('#startDateContainer').hide();
        $('#endDateContainer').show();
    }

    $(document).on("click", ".imgBtnDelete", function () {
        var taskStatusId = $(this).data("task_status_id");
        var taskName = $(this).data("task_name");
        $('#dialogMsg').empty();
        $('#dialogMsg').text("Are you sure you want to delete this task status??");
        $('#dialog').dialog({
            modal: true,
            width: '300px',
            height: 'auto',
            title: taskName,
            resizable: false,
            buttons: {
                "Yes": function () {
                    $('#preLoader').show();
                    $self = $(this);

                    $.ajax({
                        type: "POST",
                        url: webServicePath + "/DeleteStatus",
                        contentType: "application/json; charset=utf-8",
                        dataType: "json",
                        data: JSON.stringify({
                            taskStatusId: taskStatusId, clientName: $('[id*="clientName_hf"]').val()
                        }),
                        success: function (msg) {
                            $('#preLoader').hide();
                            if (msg.d == "true") {
                                $self.dialog("close");
                                var gridId = $('div[id$="RADXLGrid"]').attr('id');
                                var gridComponent = $find(gridId);
                                if (gridComponent == null) return;
                                var delArray = Array();
                                delArray.push(taskStatusId);
                                gridComponent.deleteRow(delArray);
                            }
                            else { $self.dialog("close"); alert("Error: Unable to delete"); }
                        },
                        error: function (e) {
                            $('#preLoader').hide();
                            $self.dialog("close");
                            alert("Error: Unable to delete", e);
                        }
                    });

                },
                "No": function () {
                    $(this).dialog("close")
                }
            }
        });
        $('#dialog').dialog('option', 'title', taskName);
    });

    $(document).on("click", ".undoBtn", function () {
        var taskStatusId = $(this).data("task_status_id");
        $('#dialogMsg').empty();
        $('#dialogMsg').text("Are you sure you want to undo this task ??");
        $('#dialog').dialog({
            modal: true,
            width: '300px',
            height: 'auto',
            resizable: false,
            buttons: {
                "Yes": function () {
                    $('#preLoader').show();
                    $self = $(this);

                    $.ajax({
                        type: "POST",
                        url: webServicePath + "/UndoTask",
                        contentType: "application/json; charset=utf-8",
                        dataType: "json",
                        data: JSON.stringify({
                            taskStatusId: taskStatusId, clientName: $('[id*="clientName_hf"]').val()
                        }),
                        success: function (msg) {
                            $('#preLoader').hide();
                            if (msg.d == "true") {
                                $self.dialog("close");
                                alert("Task Undo successful");
                            }
                            else { $self.dialog("close"); alert("Error: Unable to Undo Task"); }
                        },
                        error: function (e) {
                            $('#preLoader').hide();
                            $self.dialog("close");
                            alert("Error: Unable to Undo Task", e);
                        }
                    });

                },
                "No": function () {
                    $(this).dialog("close")
                }
            }
        });
        $('#dialog').dialog('option', 'title', "Common Task Manager");
    });


    $(document).on("click", ".retryBtn", function () {
        var flowId = $(this).data("flow_id");
        $('#dialogMsg').text("How do you want to re-trigger this task?");
        $('#dialog').dialog({
            modal: true,
            width: '300px',
            height: 'auto',
            resizable: false,
            buttons: {
                "Retrigger from this task onwards": function () {

                    $('#preLoader').show();
                    $.ajax({
                        type: "POST",
                        url: webServicePath + "/RetriggerTask",
                        contentType: "application/json; charset=utf-8",
                        dataType: "json",
                        data: JSON.stringify({
                            flowId: flowId, username: $('[id*="loginName_hf"]').val(), option: "0", asOfDate: $('#ctm_trigger_as_of_date').val(), clientName: $('[id*="clientName_hf"]').val()
                        }),
                        success: function (msg) {
                            $('#preLoader').hide();
                            alert('Task re-triggered successfully');
                            $('[id*="btnGetStatus"]').trigger('click');
                        },
                        error: function (e) {
                            $('#preLoader').hide();
                            alert("Error: Unable to trigger task", e);
                        }
                    });

                    $(this).dialog("close");
                },
                "Retrigger only this task": function () {
                    $('#preLoader').show();
                    $.ajax({
                        type: "POST",
                        url: webServicePath + "/RetriggerTask",
                        contentType: "application/json; charset=utf-8",
                        dataType: "json",
                        data: JSON.stringify({
                            flowId: flowId, username: $('[id*="loginName_hf"]').val(), option: "1", asOfDate: $('#ctm_trigger_as_of_date').val(), clientName: $('[id*="clientName_hf"]').val()
                        }),
                        success: function (msg) {
                            $('#preLoader').hide();
                            alert('Task re-triggered successfully');
                            $('[id*="btnGetStatus"]').trigger('click');
                        },
                        error: function (e) {
                            $('#preLoader').hide();
                            alert("Error: Unable to trigger task", e);
                        }
                    });

                    $(this).dialog("close");
                },
                "Retrigger from the start of chain": function () {
                    $('#preLoader').show();
                    $.ajax({
                        type: "POST",
                        url: webServicePath + "/RetriggerTask",
                        contentType: "application/json; charset=utf-8",
                        dataType: "json",
                        data: JSON.stringify({
                            flowId: flowId, username: $('[id*="loginName_hf"]').val(), option: "2", asOfDate: $('#ctm_trigger_as_of_date').val(), clientName: $('[id*="clientName_hf"]').val()
                        }),
                        success: function (msg) {
                            $('#preLoader').hide();
                            alert('Task re-triggered successfully');
                            $('[id*="btnGetStatus"]').trigger('click');
                        },
                        error: function (e) {
                            $('#preLoader').hide();
                            alert("Error: Unable to trigger task", e);
                        }
                    });
                    $(this).dialog("close");
                }
            }
        });
        $('#dialog').dialog('option', 'title', "Common Task Manager");
    });
    //end of retry button click

    var flowId = null;

    $("#jsganttChartFromDate").datepicker().on('changeDate', function () {
        initCharts(false);
    });

    $("#jsganttChartToDate").datepicker().on('changeDate', function () {
        initCharts(false);
    });

    $(document).on("click", "#viewGlobalTaskHistoryChart", function () {
        $('#lightbox').show();
        $('#taskGanttChartPopup').show('slide');
        flowId = $(this).children().children().data('flow_id')
        globalStatusLevel = true;
        initCharts(true);
    });

    $(document).on("click", ".viewTaskHistoryChart", function () {
        $('#lightbox').show();
        $('#taskGanttChartPopup').show('slide');
        flowId = $(this).children().data('flow_id')
        globalStatusLevel = false;
        initCharts(false);

    });

    var chartData;

    function initCharts(isGlobalTaskStatus) {
        fetchChartData(isGlobalTaskStatus);
    }

    function fetchChartData(isGlobalTaskStatus) {
        if (flowId == undefined) { flowId = null; }
        $('#preLoader').show();
        $.ajax({
            type: "POST",
            url: webServicePath + "/getGanttChartData",
            contentType: "application/json; charset=utf-8",
            dataType: "json",
            data: JSON.stringify({
                flowId: flowId,
                startTime: 0, // $("#jsganttChartFromDate").val(),
                endTime: 0, //$("#jsganttChartToDate").val(),
                isGlobalTaskStatus: isGlobalTaskStatus,
                clientName: $('[id*="clientName_hf"]').val()
            }),
            success: function (msg) {
                var taskStatuses = JSON.parse(msg.d);
                $(taskStatuses).each(function (i, e) {
                    e.start_time = new Date(parseInt(e.start_time.replace('Date', '').substring(2, 15)));
                    e.end_time = new Date(parseInt(e.end_time.replace('Date', '').substring(2, 15)));
                    e.duration_micros = e.end_time - e.start_time;
                    //e.duration_millis = e.duration_micros/1000
                    e.duration_sec = e.duration_micros / 1000;
                    //e.duratin_min = e.duration_micros /60/1000/1000;

                });

                //sorting is necassary for highcharts
                taskStatuses.sort(function (a, b) { return a.start_time.getTime() - b.start_time.getTime(); });
                //initJsGanttChart(isGlobalTaskStatus,taskStatuses);
                initHighChart(isGlobalTaskStatus, taskStatuses);
                //initHighChartRange(isGlobalTaskStatus,taskStatuses);
                initHighChartTest(isGlobalTaskStatus, taskStatuses);
                $('#preLoader').hide();
            },
            error: function (ex) {
                $('#preLoader').hide();
                alert("Error while fetching task status chart data", ex);
            }
        });
    }



    function stringToColour(str) {

        // str to hash
        for (var i = 0, hash = 0; i < str.length; hash = str.charCodeAt(i++) + ((hash << 5) - hash));

        // int/hash to hex
        for (var i = 0, colour = "#"; i < 3; colour += ("00" + ((hash >> i++ * 8) & 0xFF).toString(16)).slice(-2));

        return colour;
    }
    //start time end time high chart
    function initHighChartTest(isGlobalTaskStatus, taskStatuses) {
        $('#preLoader').show();
        $('#highchart3').empty()

        var chartData = new Array();
        var chartSeries = new Array();
        for (var i = 0; i < taskStatuses.length; i++) {
            //console.log(stringToColour(taskStatuses[i].task_name));
            var tmpData = Array();
            tmpData.push([taskStatuses[i].start_time.getTime(), i]);
            tmpData.push([taskStatuses[i].end_time.getTime(), i]);
            chartSeries.push({
                name: taskStatuses[i].task_name,
                data: tmpData,
                color: stringToColour(taskStatuses[i].task_name), //'#0066FF',//'#'+intToARGB(hashCode(taskStatuses[i].task_name)).toString(),
                marker: {
                    enabled: true,
                    radius: 3
                },
                shadow: true
            });
        }

        console.log("High chart test");
        console.log(chartSeries);

        //console.log(chartSeries);
        $('#highchart3').highcharts('StockChart', {
            rangeSelector: {
                selected: 1
            },
            series: chartSeries,
            tooltip: {
                formatter: function () {
                    console.log();
                    return '<b>' + this.points[0].series.name + '</b><br/>' + new Date(this.x);
                }
            },
            navigator: {
                enabled: true
            },
            credits: {
                enabled: false
            },
            //$('.highcharts-legend text:contains("CRNew")').remove()
            legend: {
                enabled: false

            },
            yAxis: {
                labels: { enabled: false },
                title: {
                    text: 'Tasks'

                }
            },
            xAxis: {
                title: { text: 'Time (24hours format)' },
                type: 'datetime'
            },
            title: {
                text: 'Task History'
            }
        });
        $('#preLoader').hide();
    }

    //duration high chart
    function initHighChart(isGlobalTaskStatus, taskStatuses) {
        $('#preLoader').show();
        $('#highchart').empty();
        var chartData = new Array();
        for (var i = 0; i < taskStatuses.length; i++) {
            if (chartData[taskStatuses[i].task_name] == null || chartData[taskStatuses[i].task_name] == undefined) {
                chartData[taskStatuses[i].task_name] = new Array();
            }
            chartData[taskStatuses[i].task_name].push([taskStatuses[i].start_time.getTime(), taskStatuses[i].duration_sec]);
        }

        var chartSeries = new Array();
        for (key in chartData) {
            chartSeries.push({
                name: key,
                data: chartData[key],
                marker: {
                    enabled: true,
                    radius: 3
                },
                shadow: true
            });
        }
        console.log("highstock", chartSeries);
        $('#highchart').highcharts('StockChart', {
            rangeSelector: {
                selected: 1
            },
            navigator: {
                enabled: true
            },
            credits: {
                enabled: false
            },
            legend: {
                enabled: true

            },
            yAxis: {
                title: { text: 'Duration (seconds)' }
            },
            xAxis: {
                title: { text: 'Time (24hours format)' },
                type: 'datetime'
            },
            title: {
                text: 'Task History'
            },

            series: chartSeries
        });
        $('#preLoader').hide();


    }


    function setPolyFills() {
        //polyfill for Array.indexOf
        if (!Array.prototype.indexOf) {
            Array.prototype.indexOf = function (elt /*, from*/) {
                var len = this.length >>> 0;

                var from = Number(arguments[1]) || 0;
                from = (from < 0)
                    ? Math.ceil(from)
                    : Math.floor(from);
                if (from < 0)
                    from += len;

                for (; from < len; from++) {
                    if (from in this &&
                    this[from] === elt)
                        return from;
                }
                return -1;
            };
        }

        //polyfill for Array.filter
        if (!Array.prototype.filter) {
            Array.prototype.filter = function (fun /*, thisp */) {
                "use strict";

                if (this === void 0 || this === null)
                    throw new TypeError();

                var t = Object(this);
                var len = t.length >>> 0;
                if (typeof fun !== "function")
                    throw new TypeError();

                var res = [];
                var thisp = arguments[1];
                for (var i = 0; i < len; i++) {
                    if (i in t) {
                        var val = t[i]; // in case fun mutates this
                        if (fun.call(thisp, val, i, t))
                            res.push(val);
                    }
                }

                return res;
            };
        }

        //placeholder polyfill for ie8
        $('[placeholder]').focus(function () {
            var input = $(this);
            if (input.val() == input.attr('placeholder')) {
                input.val('');
                input.removeClass('placeholder');
            }
        }).blur(function () {
            var input = $(this);
            if (input.val() == '' || input.val() == input.attr('placeholder')) {
                input.addClass('placeholder');
                input.val(input.attr('placeholder'));
            }
        }).blur();
    }

    function findIndexOfContains(searchText, searchColumn, searchArray) {
        for (var i = 0; i < searchArray.length; i++) {

            if (searchArray[i][searchColumn].toString().indexOf(searchText) > -1) {
                return i;
            }
        }

        return -1;
    }



    function alert(msg) {
        $('#dialogMsg').html(msg);
        $('#dialog').dialog({
            modal: true,
            resizable: false,
            buttons: {
                Ok: function () {
                    $(this).dialog("close");
                }
            }
        });
        $('#dialog').dialog('option', 'title', 'Common Task Manager');
    }

    function alert(msg, e) {
        if (e && e.responseText) {
            $('#dialogMsg').html(msg + "</br> Error details:<div style='max-height: 300px;max-width: 600px;overflow: auto;background-color: whitesmoke;border: 1px solid rgb(158, 158, 158);margin-top: 10px;'>" + e.responseText + "</div>");
        } else {
            $('#dialogMsg').html(msg);
        }
        $('#dialog').dialog({
            modal: true,
            resizable: false,
            buttons: {
                Ok: function () {
                    $(this).dialog("close");
                }
            }
        });
        $('#dialog').dialog('option', 'title', 'Common Task Manager');

    }
    grid = $find(gridId);
    show_no_records_div();
    dateFilterHtml();
}
//end of init_common_task_status()

//highcharts.js
//highcharts.js
(function () {
    function e(e, t) { var n; e || (e = {}); for (n in t) e[n] = t[n]; return e } function t() { var e, t = arguments, n, r = {}, i = function (e, t) { var n, r; typeof e !== "object" && (e = {}); for (r in t) t.hasOwnProperty(r) && (n = t[r], e[r] = n && typeof n === "object" && Object.prototype.toString.call(n) !== "[object Array]" && r !== "renderTo" && typeof n.nodeType !== "number" ? i(e[r] || {}, n) : t[r]); return e }; t[0] === !0 && (r = t[1], t = Array.prototype.slice.call(t, 2)); n = t.length; for (e = 0; e < n; e++) r = i(r, t[e]); return r } function n() { for (var e = 0, t = arguments, n = t.length, r = {}; e < n; e++) r[t[e++]] = t[e]; return r } function r(e, t) { return parseInt(e, t || 10) } function i(e) { return typeof e === "string" } function s(e) { return typeof e === "object" } function o(e) { return Object.prototype.toString.call(e) === "[object Array]" } function u(e) { return typeof e === "number" } function a(e) { return W.log(e) / W.LN10 } function f(e) { return W.pow(10, e) } function l(e, t) { for (var n = e.length; n--;) if (e[n] === t) { e.splice(n, 1); break } } function c(e) { return e !== R && e !== null } function h(e, t, n) { var r, o; if (i(t)) c(n) ? e.setAttribute(t, n) : e && e.getAttribute && (o = e.getAttribute(t)); else if (c(t) && s(t)) for (r in t) e.setAttribute(r, t[r]); return o } function p(e) { return o(e) ? e : [e] } function d() { var e = arguments, t, n, r = e.length; for (t = 0; t < r; t++) if (n = e[t], typeof n !== "undefined" && n !== null) return n } function v(t, n) { if (rt && !ft && n && n.opacity !== R) n.filter = "alpha(opacity=" + n.opacity * 100 + ")"; e(t.style, n) } function m(t, n, r, i, s) { t = U.createElement(t); n && e(t, n); s && v(t, { padding: 0, border: Ct, margin: 0 }); r && v(t, r); i && i.appendChild(t); return t } function g(t, n) { var r = function () { }; r.prototype = new t; e(r.prototype, n); return r } function y(e, t, n, i) { var s = gt.lang, e = +e || 0, o = t === -1 ? (e.toString().split(".")[1] || "").length : isNaN(t = Q(t)) ? 2 : t, t = n === void 0 ? s.decimalPoint : n, i = i === void 0 ? s.thousandsSep : i, s = e < 0 ? "-" : "", n = String(r(e = Q(e).toFixed(o))), u = n.length > 3 ? n.length % 3 : 0; return s + (u ? n.substr(0, u) + i : "") + n.substr(u).replace(/(\d{3})(?=\d)/g, "$1" + i) + (o ? t + Q(e - n).toFixed(o).slice(2) : "") } function b(e, t) { return Array((t || 2) + 1 - String(e).length).join(0) + e } function w(e, t, n) { var r = e[t]; e[t] = function () { var e = Array.prototype.slice.call(arguments); e.unshift(r); return n.apply(this, e) } } function E(e, t) { for (var n = "{", r = !1, i, s, o, u, a, f = []; (n = e.indexOf(n)) !== -1;) { i = e.slice(0, n); if (r) { s = i.split(":"); o = s.shift().split("."); a = o.length; i = t; for (u = 0; u < a; u++) i = i[o[u]]; if (s.length) s = s.join(":"), o = /\.([0-9])/, u = gt.lang, a = void 0, /f$/.test(s) ? (a = (a = s.match(o)) ? a[1] : -1, i !== null && (i = y(i, a, u.decimalPoint, s.indexOf(",") > -1 ? u.thousandsSep : ""))) : i = yt(s, i) } f.push(i); e = e.slice(n + 1); n = (r = !r) ? "}" : "{" } f.push(e); return f.join("") } function S(e) { return W.pow(10, V(W.log(e) / W.LN10)) } function x(e, t, n, r) { var i, n = d(n, 1); i = e / n; t || (t = [1, 2, 2.5, 5, 10], r && r.allowDecimals === !1 && (n === 1 ? t = [1, 2, 5, 10] : n <= .1 && (t = [1 / n]))); for (r = 0; r < t.length; r++) if (e = t[r], i <= (t[r] + (t[r + 1] || t[r])) / 2) break; e *= n; return e } function T() { this.symbol = this.color = 0 } function N(e, t) { var n = e.length, r, i; for (i = 0; i < n; i++) e[i].ss_i = i; e.sort(function (e, n) { r = t(e, n); return r === 0 ? e.ss_i - n.ss_i : r }); for (i = 0; i < n; i++) delete e[i].ss_i } function C(e) { for (var t = e.length, n = e[0]; t--;) e[t] < n && (n = e[t]); return n } function k(e) { for (var t = e.length, n = e[0]; t--;) e[t] > n && (n = e[t]); return n } function L(e, t) { for (var n in e) e[n] && e[n] !== t && e[n].destroy && e[n].destroy(), delete e[n] } function A(e) { mt || (mt = m(Nt)); e && mt.appendChild(e); mt.innerHTML = "" } function O(e, t) { var n = "Highcharts error #" + e + ": www.highcharts.com/errors/" + e; if (t) throw n; else z.console && console.log(n) } function M(e) { return parseFloat(e.toPrecision(14)) } function _(e, t) { bt = d(e, t.animation) } function D() { var e = gt.global.useUTC, t = e ? "getUTC" : "get", n = e ? "setUTC" : "set"; Ot = (e && gt.global.timezoneOffset || 0) * 6e4; At = e ? Date.UTC : function (e, t, n, r, i, s) { return (new Date(e, t, d(n, 1), d(r, 0), d(i, 0), d(s, 0))).getTime() }; Mt = t + "Minutes"; _t = t + "Hours"; Dt = t + "Day"; Pt = t + "Date"; Ht = t + "Month"; Bt = t + "FullYear"; jt = n + "Minutes"; Ft = n + "Hours"; It = n + "Date"; qt = n + "Month"; Rt = n + "FullYear" } function P() { } function H(e, t, n, r) { this.axis = e; this.pos = t; this.type = n || ""; this.isNew = !0; !n && !r && this.addLabel() } function B() { this.init.apply(this, arguments) } function j() { this.init.apply(this, arguments) } function F(e, t, n, r, i) { var s = e.chart.inverted; this.axis = e; this.isNegative = n; this.options = t; this.x = r; this.total = null; this.points = {}; this.stack = i; this.alignOptions = { align: t.align || (s ? n ? "left" : "right" : "center"), verticalAlign: t.verticalAlign || (s ? "middle" : n ? "bottom" : "top"), y: d(t.y, s ? 4 : n ? 14 : -6), x: d(t.x, s ? n ? -6 : 6 : 0) }; this.textAlign = t.textAlign || (s ? n ? "right" : "left" : "center") } function I(e) { var t = e.options, n = t.navigator, r = n.enabled, t = t.scrollbar, i = t.enabled, s = r ? n.height : 0, o = i ? t.height : 0; this.handles = []; this.scrollbarButtons = []; this.elementsToDestroy = []; this.chart = e; this.setBaseSeries(); this.height = s; this.scrollbarHeight = o; this.scrollbarEnabled = i; this.navigatorEnabled = r; this.navigatorOptions = n; this.scrollbarOptions = t; this.outlineHeight = s + o; this.init() } function q(e) { this.init(e) } var R, U = document, z = window, W = Math, X = W.round, V = W.floor, $ = W.ceil, J = W.max, K = W.min, Q = W.abs, G = W.cos, Y = W.sin, Z = W.PI, et = Z * 2 / 360, tt = navigator.userAgent, nt = z.opera, rt = /msie/i.test(tt) && !nt, it = U.documentMode === 8, st = /AppleWebKit/.test(tt), ot = /Firefox/.test(tt), ut = /(Mobile|Android|Windows Phone)/.test(tt), at = "http://www.w3.org/2000/svg", ft = !!U.createElementNS && !!U.createElementNS(at, "svg").createSVGRect, lt = ot && parseInt(tt.split("Firefox/")[1], 10) < 4, ct = !ft && !rt && !!U.createElement("canvas").getContext, ht, pt, dt = {}, vt = 0, mt, gt, yt, bt, wt, Et, St = function () { }, xt = [], Tt = 0, Nt = "div", Ct = "none", kt = /^[0-9]+$/, Lt = "stroke-width", At, Ot, Mt, _t, Dt, Pt, Ht, Bt, jt, Ft, It, qt, Rt, Ut = {}, zt = z.Highcharts = z.Highcharts ? O(16, !0) : {}; yt = function (t, n, r) { if (!c(n) || isNaN(n)) return "Invalid date"; var t = d(t, "%Y-%m-%d %H:%M:%S"), i = new Date(n - Ot), s, o = i[_t](), u = i[Dt](), a = i[Pt](), f = i[Ht](), l = i[Bt](), h = gt.lang, p = h.weekdays, i = e({ a: p[u].substr(0, 3), A: p[u], d: b(a), e: a, b: h.shortMonths[f], B: h.months[f], m: b(f + 1), y: l.toString().substr(2, 2), Y: l, H: b(o), I: b(o % 12 || 12), l: o % 12 || 12, M: b(i[Mt]()), p: o < 12 ? "AM" : "PM", P: o < 12 ? "am" : "pm", S: b(i.getSeconds()), L: b(X(n % 1e3), 3) }, zt.dateFormats); for (s in i) for (; t.indexOf("%" + s) !== -1;) t = t.replace("%" + s, typeof i[s] === "function" ? i[s](n) : i[s]); return r ? t.substr(0, 1).toUpperCase() + t.substr(1) : t }; T.prototype = { wrapColor: function (e) { if (this.color >= e) this.color = 0 }, wrapSymbol: function (e) { if (this.symbol >= e) this.symbol = 0 } }; Et = n("millisecond", 1, "second", 1e3, "minute", 6e4, "hour", 36e5, "day", 864e5, "week", 6048e5, "month", 26784e5, "year", 31556952e3); wt = { init: function (e, t, n) { var t = t || "", r = e.shift, i = t.indexOf("C") > -1, s = i ? 7 : 3, o, t = t.split(" "), n = [].concat(n), u, a, f = function (e) { for (o = e.length; o--;) e[o] === "M" && e.splice(o + 1, 0, e[o + 1], e[o + 2], e[o + 1], e[o + 2]) }; i && (f(t), f(n)); e.isArea && (u = t.splice(t.length - 6, 6), a = n.splice(n.length - 6, 6)); if (r <= n.length / s && t.length === n.length) for (; r--;) n = [].concat(n).splice(0, s).concat(n); e.shift = 0; if (t.length) for (e = n.length; t.length < e;) r = [].concat(t).splice(t.length - s, s), i && (r[s - 6] = r[s - 2], r[s - 5] = r[s - 1]), t = t.concat(r); u && (t = t.concat(u), n = n.concat(a)); return [t, n] }, step: function (e, t, n, r) { var i = [], s = e.length; if (n === 1) i = r; else if (s === t.length && n < 1) for (; s--;) r = parseFloat(e[s]), i[s] = isNaN(r) ? e[s] : n * parseFloat(t[s] - r) + r; else i = t; return i } }; (function (t) { z.HighchartsAdapter = z.HighchartsAdapter || t && { init: function (e) { var n = t.fx, r = n.step, s, o = t.Tween, u = o && o.propHooks; s = t.cssHooks.opacity; t.extend(t.easing, { easeOutQuad: function (e, t, n, r, i) { return -r * (t /= i) * (t - 2) + n } }); t.each(["cur", "_default", "width", "height", "opacity"], function (e, t) { var i = r, s; t === "cur" ? i = n.prototype : t === "_default" && o && (i = u[t], t = "set"); (s = i[t]) && (i[t] = function (n) { var r, n = e ? n : this; if (n.prop !== "align") return r = n.elem, r.attr ? r.attr(n.prop, t === "cur" ? R : n.now) : s.apply(this, arguments) }) }); w(s, "get", function (e, t, n) { return t.attr ? t.opacity || 0 : e.call(this, t, n) }); s = function (t) { var n = t.elem, r; if (!t.started) r = e.init(n, n.d, n.toD), t.start = r[0], t.end = r[1], t.started = !0; n.attr("d", e.step(t.start, t.end, t.pos, n.toD)) }; o ? u.d = { set: s } : r.d = s; this.each = Array.prototype.forEach ? function (e, t) { return Array.prototype.forEach.call(e, t) } : function (e, t) { for (var n = 0, r = e.length; n < r; n++) if (t.call(e[n], e[n], n, e) === !1) return n }; t.fn.highcharts = function () { var e = "Chart", t = arguments, n, r; if (this[0]) { i(t[0]) && (e = t[0], t = Array.prototype.slice.call(t, 1)); n = t[0]; if (n !== R) n.chart = n.chart || {}, n.chart.renderTo = this[0], new zt[e](n, t[1]), r = this; n === R && (r = xt[h(this[0], "data-highcharts-chart")]) } return r } }, getScript: t.getScript, inArray: t.inArray, adapterRun: function (e, n) { return t(e)[n]() }, grep: t.grep, map: function (e, t) { for (var n = [], r = 0, i = e.length; r < i; r++) n[r] = t.call(e[r], e[r], r, e); return n }, offset: function (e) { return t(e).offset() }, addEvent: function (e, n, r) { t(e).bind(n, r) }, removeEvent: function (e, n, r) { var i = U.removeEventListener ? "removeEventListener" : "detachEvent"; U[i] && e && !e[i] && (e[i] = function () { }); t(e).unbind(n, r) }, fireEvent: function (n, r, i, s) { var o = t.Event(r), u = "detached" + r, a; !rt && i && (delete i.layerX, delete i.layerY, delete i.returnValue); e(o, i); n[r] && (n[u] = n[r], n[r] = null); t.each(["preventDefault", "stopPropagation"], function (e, t) { var n = o[t]; o[t] = function () { try { n.call(o) } catch (e) { t === "preventDefault" && (a = !0) } } }); t(n).trigger(o); n[u] && (n[r] = n[u], n[u] = null); s && !o.isDefaultPrevented() && !a && s(o) }, washMouseEvent: function (e) { var t = e.originalEvent || e; if (t.pageX === R) t.pageX = e.pageX, t.pageY = e.pageY; return t }, animate: function (e, n, r) { var i = t(e); if (!e.style) e.style = {}; if (n.d) e.toD = n.d, n.d = 1; i.stop(); n.opacity !== R && e.attr && (n.opacity += "px"); i.animate(n, r) }, stop: function (e) { t(e).stop() } } })(z.jQuery); var Wt = z.HighchartsAdapter, Xt = Wt || {}; Wt && Wt.init.call(Wt, wt); var Vt = Xt.adapterRun, $t = Xt.getScript, Jt = Xt.inArray, Kt = Xt.each, Qt = Xt.grep, Gt = Xt.offset, Yt = Xt.map, Zt = Xt.addEvent, en = Xt.removeEvent, tn = Xt.fireEvent, nn = Xt.washMouseEvent, rn = Xt.animate, sn = Xt.stop, Xt = { enabled: !0, x: 0, y: 15, style: { color: "#606060", cursor: "default", fontSize: "11px" } }; gt = { colors: "#7cb5ec,#434348,#90ed7d,#f7a35c,#8085e9,#f15c80,#e4d354,#8085e8,#8d4653,#91e8e1".split(","), symbols: ["circle", "diamond", "square", "triangle", "triangle-down"], lang: { loading: "Loading...", months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","), shortMonths: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","), weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","), decimalPoint: ".", numericSymbols: "k,M,G,T,P,E".split(","), resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1", thousandsSep: "," }, global: { useUTC: !0, canvasToolsURL: "http://code.highcharts.com/stock/2.0.1/modules/canvas-tools.js", VMLRadialGradientURL: "http://code.highcharts.com/stock/2.0.1/gfx/vml-radial-gradient.png" }, chart: { borderColor: "#4572A7", borderRadius: 0, defaultSeriesType: "line", ignoreHiddenSeries: !0, spacing: [10, 10, 15, 10], backgroundColor: "#FFFFFF", plotBorderColor: "#C0C0C0", resetZoomButton: { theme: { zIndex: 20 }, position: { align: "right", x: -10, y: 10 } } }, title: { text: "Chart title", align: "center", margin: 15, style: { color: "#333333", fontSize: "18px" } }, subtitle: { text: "", align: "center", style: { color: "#555555" } }, plotOptions: { line: { allowPointSelect: !1, showCheckbox: !1, animation: { duration: 1e3 }, events: {}, lineWidth: 2, marker: { lineWidth: 0, radius: 4, lineColor: "#FFFFFF", states: { hover: { enabled: !0 }, select: { fillColor: "#FFFFFF", lineColor: "#000000", lineWidth: 2 } } }, point: { events: {} }, dataLabels: t(Xt, { align: "center", enabled: !1, formatter: function () { return this.y === null ? "" : y(this.y, -1) }, verticalAlign: "bottom", y: 0 }), cropThreshold: 300, pointRange: 0, states: { hover: { marker: {}, halo: { size: 10, opacity: .25 } }, select: { marker: {} } }, stickyTracking: !0, turboThreshold: 1e3 } }, labels: { style: { position: "absolute", color: "#3E576F" } }, legend: { enabled: !0, align: "center", layout: "horizontal", labelFormatter: function () { return this.name }, borderColor: "#909090", borderRadius: 0, navigation: { activeColor: "#274b6d", inactiveColor: "#CCC" }, shadow: !1, itemStyle: { color: "#333333", fontSize: "12px", fontWeight: "bold" }, itemHoverStyle: { color: "#000" }, itemHiddenStyle: { color: "#CCC" }, itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" }, symbolPadding: 5, verticalAlign: "bottom", x: 0, y: 0, title: { style: { fontWeight: "bold" } } }, loading: { labelStyle: { fontWeight: "bold", position: "relative", top: "1em" }, style: { position: "absolute", backgroundColor: "white", opacity: .5, textAlign: "center" } }, tooltip: { enabled: !0, animation: ft, backgroundColor: "rgba(249, 249, 249, .85)", borderWidth: 1, borderRadius: 3, dateTimeLabelFormats: { millisecond: "%A, %b %e, %H:%M:%S.%L", second: "%A, %b %e, %H:%M:%S", minute: "%A, %b %e, %H:%M", hour: "%A, %b %e, %H:%M", day: "%A, %b %e, %Y", week: "Week from %A, %b %e, %Y", month: "%B %Y", year: "%Y" }, headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>', pointFormat: '<span style="color:{series.color}">●</span> {series.name}: <b>{point.y}</b><br/>', shadow: !0, snap: ut ? 25 : 10, style: { color: "#333333", cursor: "default", fontSize: "12px", padding: "8px", whiteSpace: "nowrap" } }, credits: { enabled: !0, text: "Highcharts.com", href: "http://www.highcharts.com", position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 }, style: { cursor: "pointer", color: "#909090", fontSize: "9px" } } }; var on = gt.plotOptions, Wt = on.line; D(); var un = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/, an = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/, fn = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/, ln = function (e) { var n = [], i, s; (function (e) { e && e.stops ? s = Yt(e.stops, function (e) { return ln(e[1]) }) : (i = un.exec(e)) ? n = [r(i[1]), r(i[2]), r(i[3]), parseFloat(i[4], 10)] : (i = an.exec(e)) ? n = [r(i[1], 16), r(i[2], 16), r(i[3], 16), 1] : (i = fn.exec(e)) && (n = [r(i[1]), r(i[2]), r(i[3]), 1]) })(e); return { get: function (r) { var i; s ? (i = t(e), i.stops = [].concat(i.stops), Kt(s, function (e, t) { i.stops[t] = [i.stops[t][0], e.get(r)] })) : i = n && !isNaN(n[0]) ? r === "rgb" ? "rgb(" + n[0] + "," + n[1] + "," + n[2] + ")" : r === "a" ? n[3] : "rgba(" + n.join(",") + ")" : e; return i }, brighten: function (e) { if (s) Kt(s, function (t) { t.brighten(e) }); else if (u(e) && e !== 0) { var t; for (t = 0; t < 3; t++) n[t] += r(e * 255), n[t] < 0 && (n[t] = 0), n[t] > 255 && (n[t] = 255) } return this }, rgba: n, setOpacity: function (e) { n[3] = e; return this } } }; P.prototype = { init: function (e, t) { this.element = t === "span" ? m(t) : U.createElementNS(at, t); this.renderer = e }, opacity: 1, animate: function (e, n, r) { n = d(n, bt, !0); sn(this); if (n) { n = t(n, {}); if (r) n.complete = r; rn(this, e, n) } else this.attr(e), r && r() }, colorGradient: function (e, n, r) { var i = this.renderer, s, u, a, f, l, h, p, d, v, m, g = []; e.linearGradient ? u = "linearGradient" : e.radialGradient && (u = "radialGradient"); if (u) { a = e[u]; f = i.gradients; h = e.stops; v = r.radialReference; o(a) && (e[u] = a = { x1: a[0], y1: a[1], x2: a[2], y2: a[3], gradientUnits: "userSpaceOnUse" }); u === "radialGradient" && v && !c(a.gradientUnits) && (a = t(a, { cx: v[0] - v[2] / 2 + a.cx * v[2], cy: v[1] - v[2] / 2 + a.cy * v[2], r: a.r * v[2], gradientUnits: "userSpaceOnUse" })); for (m in a) m !== "id" && g.push(m, a[m]); for (m in h) g.push(h[m]); g = g.join(","); f[g] ? e = f[g].attr("id") : (a.id = e = "highcharts-" + vt++, f[g] = l = i.createElement(u).attr(a).add(i.defs), l.stops = [], Kt(h, function (e) { e[1].indexOf("rgba") === 0 ? (s = ln(e[1]), p = s.get("rgb"), d = s.get("a")) : (p = e[1], d = 1); e = i.createElement("stop").attr({ offset: e[0], "stop-color": p, "stop-opacity": d }).add(l); l.stops.push(e) })); r.setAttribute(n, "url(" + i.url + "#" + e + ")") } }, attr: function (e, t) { var n, r, i = this.element, s, o = this, u; typeof e === "string" && t !== R && (n = e, e = {}, e[n] = t); if (typeof e === "string") o = (this[e + "Getter"] || this._defaultGetter).call(this, e, i); else { for (n in e) { r = e[n]; u = !1; this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(n) && (s || (this.symbolAttr(e), s = !0), u = !0); if (this.rotation && (n === "x" || n === "y")) this.doTransform = !0; u || (this[n + "Setter"] || this._defaultSetter).call(this, r, n, i); this.shadows && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(n) && this.updateShadows(n, r) } if (this.doTransform) this.updateTransform(), this.doTransform = !1 } return o }, updateShadows: function (e, t) { for (var n = this.shadows, r = n.length; r--;) n[r].setAttribute(e, e === "height" ? J(t - (n[r].cutHeight || 0), 0) : e === "d" ? this.d : t) }, addClass: function (e) { var t = this.element, n = h(t, "class") || ""; n.indexOf(e) === -1 && h(t, "class", n + " " + e); return this }, symbolAttr: function (e) { var t = this; Kt("x,y,r,start,end,width,height,innerR,anchorX,anchorY".split(","), function (n) { t[n] = d(e[n], t[n]) }); t.attr({ d: t.renderer.symbols[t.symbolName](t.x, t.y, t.width, t.height, t) }) }, clip: function (e) { return this.attr("clip-path", e ? "url(" + this.renderer.url + "#" + e.id + ")" : Ct) }, crisp: function (e) { var t, n = {}, r, i = e.strokeWidth || this.strokeWidth || this.attr && this.attr("stroke-width") || 0; r = X(i) % 2 / 2; e.x = V(e.x || this.x || 0) + r; e.y = V(e.y || this.y || 0) + r; e.width = V((e.width || this.width || 0) - 2 * r); e.height = V((e.height || this.height || 0) - 2 * r); e.strokeWidth = i; for (t in e) this[t] !== e[t] && (this[t] = n[t] = e[t]); return n }, css: function (t) { var n = this.styles, i = {}, s = this.element, o, u, a = ""; o = !n; if (t && t.color) t.fill = t.color; if (n) for (u in t) t[u] !== n[u] && (i[u] = t[u], o = !0); if (o) { o = this.textWidth = t && t.width && s.nodeName.toLowerCase() === "text" && r(t.width); n && (t = e(n, i)); this.styles = t; o && (ct || !ft && this.renderer.forExport) && delete t.width; if (rt && !ft) v(this.element, t); else { n = function (e, t) { return "-" + t.toLowerCase() }; for (u in t) a += u.replace(/([A-Z])/g, n) + ":" + t[u] + ";"; h(s, "style", a) } o && this.added && this.renderer.buildText(this) } return this }, on: function (e, t) { var n = this, r = n.element; pt && e === "click" ? (r.ontouchstart = function (e) { n.touchEventFired = Date.now(); e.preventDefault(); t.call(r, e) }, r.onclick = function (e) { (tt.indexOf("Android") === -1 || Date.now() - (n.touchEventFired || 0) > 1100) && t.call(r, e) }) : r["on" + e] = t; return this }, setRadialReference: function (e) { this.element.radialReference = e; return this }, translate: function (e, t) { return this.attr({ translateX: e, translateY: t }) }, invert: function () { this.inverted = !0; this.updateTransform(); return this }, updateTransform: function () { var e = this.translateX || 0, t = this.translateY || 0, n = this.scaleX, r = this.scaleY, i = this.inverted, s = this.rotation, o = this.element; i && (e += this.attr("width"), t += this.attr("height")); e = ["translate(" + e + "," + t + ")"]; i ? e.push("rotate(90) scale(-1,1)") : s && e.push("rotate(" + s + " " + (o.getAttribute("x") || 0) + " " + (o.getAttribute("y") || 0) + ")"); (c(n) || c(r)) && e.push("scale(" + d(n, 1) + " " + d(r, 1) + ")"); e.length && o.setAttribute("transform", e.join(" ")) }, toFront: function () { var e = this.element; e.parentNode.appendChild(e); return this }, align: function (e, t, n) { var r, s, o, u, a = {}; s = this.renderer; o = s.alignedObjects; if (e) { if (this.alignOptions = e, this.alignByTranslate = t, !n || i(n)) this.alignTo = r = n || "renderer", l(o, this), o.push(this), n = null } else e = this.alignOptions, t = this.alignByTranslate, r = this.alignTo; n = d(n, s[r], s); r = e.align; s = e.verticalAlign; o = (n.x || 0) + (e.x || 0); u = (n.y || 0) + (e.y || 0); if (r === "right" || r === "center") o += (n.width - (e.width || 0)) / { right: 1, center: 2 }[r]; a[t ? "translateX" : "x"] = X(o); if (s === "bottom" || s === "middle") u += (n.height - (e.height || 0)) / ({ bottom: 1, middle: 2 }[s] || 1); a[t ? "translateY" : "y"] = X(u); this[this.placed ? "animate" : "attr"](a); this.placed = !0; this.alignAttr = a; return this }, getBBox: function () { var t = this.bBox, n = this.renderer, r, i, s = this.rotation; r = this.element; var o = this.styles, u = s * et; i = this.textStr; var a; if (i === "" || kt.test(i)) a = "num." + i.toString().length + (o ? "|" + o.fontSize + "|" + o.fontFamily : ""); a && (t = n.cache[a]); if (!t) { if (r.namespaceURI === at || n.forExport) { try { t = r.getBBox ? e({}, r.getBBox()) : { width: r.offsetWidth, height: r.offsetHeight } } catch (f) { } if (!t || t.width < 0) t = { width: 0, height: 0 } } else t = this.htmlGetBBox(); if (n.isSVG) { r = t.width; i = t.height; if (rt && o && o.fontSize === "11px" && i.toPrecision(3) === "16.9") t.height = i = 14; if (s) t.width = Q(i * Y(u)) + Q(r * G(u)), t.height = Q(i * G(u)) + Q(r * Y(u)) } this.bBox = t; a && (n.cache[a] = t) } return t }, show: function (e) { return e && this.element.namespaceURI === at ? (this.element.removeAttribute("visibility"), this) : this.attr({ visibility: e ? "inherit" : "visible" }) }, hide: function () { return this.attr({ visibility: "hidden" }) }, fadeOut: function (e) { var t = this; t.animate({ opacity: 0 }, { duration: e || 150, complete: function () { t.hide() } }) }, add: function (e) { var t = this.renderer, n = e || t, i = n.element || t.box, s = this.element, o = this.zIndex, u, a; if (e) this.parentGroup = e; this.parentInverted = e && e.inverted; this.textStr !== void 0 && t.buildText(this); if (o) n.handleZ = !0, o = r(o); if (n.handleZ) { e = i.childNodes; for (u = 0; u < e.length; u++) if (t = e[u], n = h(t, "zIndex"), t !== s && (r(n) > o || !c(o) && c(n))) { i.insertBefore(s, t); a = !0; break } } a || i.appendChild(s); this.added = !0; if (this.onAdd) this.onAdd(); return this }, safeRemoveChild: function (e) { var t = e.parentNode; t && t.removeChild(e) }, destroy: function () { var e = this, t = e.element || {}, n = e.shadows, r = e.renderer.isSVG && t.nodeName === "SPAN" && e.parentGroup, i, s; t.onclick = t.onmouseout = t.onmouseover = t.onmousemove = t.point = null; sn(e); if (e.clipPath) e.clipPath = e.clipPath.destroy(); if (e.stops) { for (s = 0; s < e.stops.length; s++) e.stops[s] = e.stops[s].destroy(); e.stops = null } e.safeRemoveChild(t); for (n && Kt(n, function (t) { e.safeRemoveChild(t) }) ; r && r.div.childNodes.length === 0;) t = r.parentGroup, e.safeRemoveChild(r.div), delete r.div, r = t; e.alignTo && l(e.renderer.alignedObjects, e); for (i in e) delete e[i]; return null }, shadow: function (e, t, n) { var r = [], i, s, o = this.element, u, a, f, l; if (e) { a = d(e.width, 3); f = (e.opacity || .15) / a; l = this.parentInverted ? "(-1,-1)" : "(" + d(e.offsetX, 1) + ", " + d(e.offsetY, 1) + ")"; for (i = 1; i <= a; i++) { s = o.cloneNode(0); u = a * 2 + 1 - 2 * i; h(s, { isShadow: "true", stroke: e.color || "black", "stroke-opacity": f * i, "stroke-width": u, transform: "translate" + l, fill: Ct }); if (n) h(s, "height", J(h(s, "height") - u, 0)), s.cutHeight = u; t ? t.element.appendChild(s) : o.parentNode.insertBefore(s, o); r.push(s) } this.shadows = r } return this }, xGetter: function (e) { this.element.nodeName === "circle" && (e = { x: "cx", y: "cy" }[e] || e); return this._defaultGetter(e) }, _defaultGetter: function (e) { e = d(this[e], this.element ? this.element.getAttribute(e) : null, 0); /^[0-9\.]+$/.test(e) && (e = parseFloat(e)); return e }, dSetter: function (e, t, n) { e && e.join && (e = e.join(" ")); /(NaN| {2}|^$)/.test(e) && (e = "M 0 0"); n.setAttribute(t, e); this[t] = e }, dashstyleSetter: function (e) { var t; if (e = e && e.toLowerCase()) { e = e.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(","); for (t = e.length; t--;) e[t] = r(e[t]) * this.element.getAttribute("stroke-width"); e = e.join(","); this.element.setAttribute("stroke-dasharray", e) } }, alignSetter: function (e) { this.element.setAttribute("text-anchor", { left: "start", center: "middle", right: "end" }[e]) }, opacitySetter: function (e, t, n) { this[t] = e; n.setAttribute(t, e) }, "stroke-widthSetter": function (e, t, n) { e === 0 && (e = 1e-5); this.strokeWidth = e; n.setAttribute(t, e) }, titleSetter: function (e) { var t = this.element.getElementsByTagName("title")[0]; t || (t = U.createElementNS(at, "title"), this.element.appendChild(t)); t.textContent = e }, textSetter: function (e) { if (e !== this.textStr) delete this.bBox, this.textStr = e, this.added && this.renderer.buildText(this) }, fillSetter: function (e, t, n) { typeof e === "string" ? n.setAttribute(t, e) : e && this.colorGradient(e, t, n) }, zIndexSetter: function (e, t, n) { n.setAttribute(t, e); this[t] = e }, _defaultSetter: function (e, t, n) { n.setAttribute(t, e) } }; P.prototype.yGetter = P.prototype.xGetter; P.prototype.translateXSetter = P.prototype.translateYSetter = P.prototype.rotationSetter = P.prototype.verticalAlignSetter = P.prototype.scaleXSetter = P.prototype.scaleYSetter = function (e, t) { this[t] = e; this.doTransform = !0 }; P.prototype.strokeSetter = P.prototype.fillSetter; var cn = function () { this.init.apply(this, arguments) }; cn.prototype = { Element: P, init: function (e, t, n, r, i) { var s = location, o, r = this.createElement("svg").attr({ version: "1.1" }).css(this.getStyle(r)); o = r.element; e.appendChild(o); e.innerHTML.indexOf("xmlns") === -1 && h(o, "xmlns", at); this.isSVG = !0; this.box = o; this.boxWrapper = r; this.alignedObjects = []; this.url = (ot || st) && U.getElementsByTagName("base").length ? s.href.replace(/#.*?$/, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : ""; this.createElement("desc").add().element.appendChild(U.createTextNode("Created with Highstock 2.0.1")); this.defs = this.createElement("defs").add(); this.forExport = i; this.gradients = {}; this.cache = {}; this.setSize(t, n, !1); var u; if (ot && e.getBoundingClientRect) this.subPixelFix = t = function () { v(e, { left: 0, top: 0 }); u = e.getBoundingClientRect(); v(e, { left: $(u.left) - u.left + "px", top: $(u.top) - u.top + "px" }) }, t(), Zt(z, "resize", t) }, getStyle: function (t) { return this.style = e({ fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif', fontSize: "12px" }, t) }, isHidden: function () { return !this.boxWrapper.getBBox().width }, destroy: function () { var e = this.defs; this.box = null; this.boxWrapper = this.boxWrapper.destroy(); L(this.gradients || {}); this.gradients = null; if (e) this.defs = e.destroy(); this.subPixelFix && en(z, "resize", this.subPixelFix); return this.alignedObjects = null }, createElement: function (e) { var t = new this.Element; t.init(this, e); return t }, draw: function () { }, buildText: function (e) { for (var t = e.element, n = this, i = n.forExport, s = d(e.textStr, "").toString(), o = s.indexOf("<") !== -1, u = t.childNodes, a, f, l = h(t, "x"), c = e.styles, p = e.textWidth, m = c && c.lineHeight, g = u.length, y = function (e) { return m ? r(m) : n.fontMetrics(/(px|em)$/.test(e && e.style.fontSize) ? e.style.fontSize : c && c.fontSize || n.style.fontSize || 12).h }; g--;) t.removeChild(u[g]); !o && s.indexOf(" ") === -1 ? t.appendChild(U.createTextNode(s)) : (a = /<.*style="([^"]+)".*>/, f = /<.*href="(http[^"]+)".*>/, p && !e.added && this.box.appendChild(t), s = o ? s.replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">').replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(/<br.*?>/g) : [s], s[s.length - 1] === "" && s.pop(), Kt(s, function (r, s) { var o, u = 0, r = r.replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||"); o = r.split("|||"); Kt(o, function (r) { if (r !== "" || o.length === 1) { var d = {}, m = U.createElementNS(at, "tspan"), g; a.test(r) && (g = r.match(a)[1].replace(/(;| |^)color([ :])/, "$1fill$2"), h(m, "style", g)); f.test(r) && !i && (h(m, "onclick", 'location.href="' + r.match(f)[1] + '"'), v(m, { cursor: "pointer" })); r = (r.replace(/<(.|\n)*?>/g, "") || " ").replace(/&lt;/g, "<").replace(/&gt;/g, ">"); if (r !== " ") { m.appendChild(U.createTextNode(r)); if (u) d.dx = 0; else if (s && l !== null) d.x = l; h(m, d); !u && s && (!ft && i && v(m, { display: "block" }), h(m, "dy", y(m), st && m.offsetHeight)); t.appendChild(m); u++; if (p) for (var r = r.replace(/([^\^])-/g, "$1- ").split(" "), d = r.length > 1 && c.whiteSpace !== "nowrap", b, w, E = e._clipHeight, S = [], x = y(), T = 1; d && (r.length || S.length) ;) delete e.bBox, b = e.getBBox(), w = b.width, !ft && n.forExport && (w = n.measureSpanWidth(m.firstChild.data, e.styles)), b = w > p, !b || r.length === 1 ? (r = S, S = [], r.length && (T++, E && T * x > E ? (r = ["..."], e.attr("title", e.textStr)) : (m = U.createElementNS(at, "tspan"), h(m, { dy: x, x: l }), g && h(m, "style", g), t.appendChild(m), w > p && (p = w)))) : (m.removeChild(m.firstChild), S.unshift(r.pop())), r.length && m.appendChild(U.createTextNode(r.join(" ").replace(/- /g, "-"))) } } }) })) }, button: function (n, r, i, s, o, u, a, f, l) { var c = this.label(n, r, i, l, null, null, null, null, "button"), h = 0, p, d, v, m, g, y, n = { x1: 0, y1: 0, x2: 0, y2: 1 }, o = t({ "stroke-width": 1, stroke: "#CCCCCC", fill: { linearGradient: n, stops: [[0, "#FEFEFE"], [1, "#F6F6F6"]] }, r: 2, padding: 5, style: { color: "black" } }, o); v = o.style; delete o.style; u = t(o, { stroke: "#68A", fill: { linearGradient: n, stops: [[0, "#FFF"], [1, "#ACF"]] } }, u); m = u.style; delete u.style; a = t(o, { stroke: "#68A", fill: { linearGradient: n, stops: [[0, "#9BD"], [1, "#CDF"]] } }, a); g = a.style; delete a.style; f = t(o, { style: { color: "#CCC" } }, f); y = f.style; delete f.style; Zt(c.element, rt ? "mouseover" : "mouseenter", function () { h !== 3 && c.attr(u).css(m) }); Zt(c.element, rt ? "mouseout" : "mouseleave", function () { h !== 3 && (p = [o, u, a][h], d = [v, m, g][h], c.attr(p).css(d)) }); c.setState = function (e) { (c.state = h = e) ? e === 2 ? c.attr(a).css(g) : e === 3 && c.attr(f).css(y) : c.attr(o).css(v) }; return c.on("click", function () { h !== 3 && s.call(c) }).attr(o).css(e({ cursor: "default" }, v)) }, crispLine: function (e, t) { e[1] === e[4] && (e[1] = e[4] = X(e[1]) - t % 2 / 2); e[2] === e[5] && (e[2] = e[5] = X(e[2]) + t % 2 / 2); return e }, path: function (t) { var n = { fill: Ct }; o(t) ? n.d = t : s(t) && e(n, t); return this.createElement("path").attr(n) }, circle: function (e, t, n) { e = s(e) ? e : { x: e, y: t, r: n }; t = this.createElement("circle"); t.xSetter = function (e) { this.element.setAttribute("cx", e) }; t.ySetter = function (e) { this.element.setAttribute("cy", e) }; return t.attr(e) }, arc: function (e, t, n, r, i, o) { if (s(e)) t = e.y, n = e.r, r = e.innerR, i = e.start, o = e.end, e = e.x; e = this.symbol("arc", e || 0, t || 0, n || 0, n || 0, { innerR: r || 0, start: i || 0, end: o || 0 }); e.r = n; return e }, rect: function (e, t, n, r, i, o) { var i = s(e) ? e.r : i, u = this.createElement("rect"), e = s(e) ? e : e === R ? {} : { x: e, y: t, width: J(n, 0), height: J(r, 0) }; if (o !== R) e.strokeWidth = o, e = u.crisp(e); if (i) e.r = i; u.rSetter = function (e) { h(this.element, { rx: e, ry: e }) }; return u.attr(e) }, setSize: function (e, t, n) { var r = this.alignedObjects, i = r.length; this.width = e; this.height = t; for (this.boxWrapper[d(n, !0) ? "animate" : "attr"]({ width: e, height: t }) ; i--;) r[i].align() }, g: function (e) { var t = this.createElement("g"); return c(e) ? t.attr({ "class": "highcharts-" + e }) : t }, image: function (t, n, r, i, s) { var o = { preserveAspectRatio: Ct }; arguments.length > 1 && e(o, { x: n, y: r, width: i, height: s }); o = this.createElement("image").attr(o); o.element.setAttributeNS ? o.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", t) : o.element.setAttribute("hc-svg-href", t); return o }, symbol: function (t, n, r, i, s, o) { var u, a = this.symbols[t], a = a && a(X(n), X(r), i, s, o), f = /^url\((.*?)\)$/, l, c; if (a) u = this.path(a), e(u, { symbolName: t, x: n, y: r, width: i, height: s }), o && e(u, o); else if (f.test(t)) c = function (e, t) { e.element && (e.attr({ width: t[0], height: t[1] }), e.alignByTranslate || e.translate(X((i - t[0]) / 2), X((s - t[1]) / 2))) }, l = t.match(f)[1], t = dt[l], u = this.image(l).attr({ x: n, y: r }), u.isImg = !0, t ? c(u, t) : (u.attr({ width: 0, height: 0 }), m("img", { onload: function () { c(u, dt[l] = [this.width, this.height]) }, src: l })); return u }, symbols: { circle: function (e, t, n, r) { var i = .166 * n; return ["M", e + n / 2, t, "C", e + n + i, t, e + n + i, t + r, e + n / 2, t + r, "C", e - i, t + r, e - i, t, e + n / 2, t, "Z"] }, square: function (e, t, n, r) { return ["M", e, t, "L", e + n, t, e + n, t + r, e, t + r, "Z"] }, triangle: function (e, t, n, r) { return ["M", e + n / 2, t, "L", e + n, t + r, e, t + r, "Z"] }, "triangle-down": function (e, t, n, r) { return ["M", e, t, "L", e + n, t, e + n / 2, t + r, "Z"] }, diamond: function (e, t, n, r) { return ["M", e + n / 2, t, "L", e + n, t + r / 2, e + n / 2, t + r, e, t + r / 2, "Z"] }, arc: function (e, t, n, r, i) { var s = i.start, n = i.r || n || r, o = i.end - .001, r = i.innerR, u = i.open, a = G(s), f = Y(s), l = G(o), o = Y(o), i = i.end - s < Z ? 0 : 1; return ["M", e + n * a, t + n * f, "A", n, n, 0, i, 1, e + n * l, t + n * o, u ? "M" : "L", e + r * l, t + r * o, "A", r, r, 0, i, 0, e + r * a, t + r * f, u ? "" : "Z"] }, callout: function (e, t, n, r, i) { var s = K(i && i.r || 0, n, r), o = s + 6, u = i && i.anchorX, a = i && i.anchorY, i = X(i.strokeWidth || 0) % 2 / 2; e += i; t += i; i = ["M", e + s, t, "L", e + n - s, t, "C", e + n, t, e + n, t, e + n, t + s, "L", e + n, t + r - s, "C", e + n, t + r, e + n, t + r, e + n - s, t + r, "L", e + s, t + r, "C", e, t + r, e, t + r, e, t + r - s, "L", e, t + s, "C", e, t, e, t, e + s, t]; u && u > n && a > t + o && a < t + r - o ? i.splice(13, 3, "L", e + n, a - 6, e + n + 6, a, e + n, a + 6, e + n, t + r - s) : u && u < 0 && a > t + o && a < t + r - o ? i.splice(33, 3, "L", e, a + 6, e - 6, a, e, a - 6, e, t + s) : a && a > r && u > e + o && u < e + n - o ? i.splice(23, 3, "L", u + 6, t + r, u, t + r + 6, u - 6, t + r, e + s, t + r) : a && a < 0 && u > e + o && u < e + n - o && i.splice(3, 3, "L", u - 6, t, u, t - 6, u + 6, t, n - s, t); return i } }, clipRect: function (e, t, n, r) { var i = "highcharts-" + vt++, s = this.createElement("clipPath").attr({ id: i }).add(this.defs), e = this.rect(e, t, n, r, 0).add(s); e.id = i; e.clipPath = s; return e }, text: function (e, t, n, r) { var i = ct || !ft && this.forExport, s = {}; if (r && !this.forExport) return this.html(e, t, n); s.x = Math.round(t || 0); if (n) s.y = Math.round(n); if (e || e === 0) s.text = e; e = this.createElement("text").attr(s); i && e.css({ position: "absolute" }); if (!r) e.xSetter = function (e, t, n) { var r = n.childNodes, i, s; for (s = 1; s < r.length; s++) i = r[s], i.getAttribute("x") === n.getAttribute("x") && i.setAttribute("x", e); n.setAttribute(t, e) }; return e }, fontMetrics: function (e) { var e = e || this.style.fontSize, e = /px/.test(e) ? r(e) : /em/.test(e) ? parseFloat(e) * 12 : 12, e = e < 24 ? e + 4 : X(e * 1.2), t = X(e * .8); return { h: e, b: t } }, label: function (n, r, i, s, o, u, a, f, l) { function h() { var t, n; t = g.element.style; b = (x === void 0 || T === void 0 || m.styles.textAlign) && g.textStr && g.getBBox(); m.width = (x || b.width || 0) + 2 * E + S; m.height = (T || b.height || 0) + 2 * E; A = E + v.fontMetrics(t && t.fontSize).b; if (O) { if (!y) t = X(-w * E), n = f ? -A : 0, m.box = y = s ? v.symbol(s, t, n, m.width, m.height, L) : v.rect(t, n, m.width, m.height, 0, L[Lt]), y.attr("fill", Ct).add(m); y.isImg || y.attr(e({ width: X(m.width), height: X(m.height) }, L)); L = null } } function p() { var e = m.styles, e = e && e.textAlign, t = S + E * (1 - w), n; n = f ? 0 : A; if (c(x) && b && (e === "center" || e === "right")) t += { center: .5, right: 1 }[e] * (x - b.width); if (t !== g.x || n !== g.y) g.attr("x", t), n !== R && g.attr("y", n); g.x = t; g.y = n } function d(e, t) { y ? y.attr(e, t) : L[e] = t } var v = this, m = v.g(l), g = v.text("", 0, 0, a).attr({ zIndex: 1 }), y, b, w = 0, E = 3, S = 0, x, T, N, C, k = 0, L = {}, A, O; m.onAdd = function () { g.add(m); m.attr({ text: n || "", x: r, y: i }); y && c(o) && m.attr({ anchorX: o, anchorY: u }) }; m.widthSetter = function (e) { x = e }; m.heightSetter = function (e) { T = e }; m.paddingSetter = function (e) { c(e) && e !== E && (E = e, p()) }; m.paddingLeftSetter = function (e) { c(e) && e !== S && (S = e, p()) }; m.alignSetter = function (e) { w = { left: 0, center: .5, right: 1 }[e] }; m.textSetter = function (e) { e !== R && g.textSetter(e); h(); p() }; m["stroke-widthSetter"] = function (e, t) { e && (O = !0); k = e % 2 / 2; d(t, e) }; m.strokeSetter = m.fillSetter = m.rSetter = function (e, t) { t === "fill" && e && (O = !0); d(t, e) }; m.anchorXSetter = function (e, t) { o = e; d(t, e + k - N) }; m.anchorYSetter = function (e, t) { u = e; d(t, e - C) }; m.xSetter = function (e) { m.x = e; w && (e -= w * ((x || b.width) + E)); N = X(e); m.attr("translateX", N) }; m.ySetter = function (e) { C = m.y = X(e); m.attr("translateY", C) }; var M = m.css; return e(m, { css: function (e) { if (e) { var n = {}, e = t(e); Kt("fontSize,fontWeight,fontFamily,color,lineHeight,width,textDecoration,textShadow".split(","), function (t) { e[t] !== R && (n[t] = e[t], delete e[t]) }); g.css(n) } return M.call(m, e) }, getBBox: function () { return { width: b.width + 2 * E, height: b.height + 2 * E, x: b.x - E, y: b.y - E } }, shadow: function (e) { y && y.shadow(e); return m }, destroy: function () { en(m.element, "mouseenter"); en(m.element, "mouseleave"); g && (g = g.destroy()); y && (y = y.destroy()); P.prototype.destroy.call(m); m = v = h = p = d = null } }) } }; ht = cn; e(P.prototype, { htmlCss: function (t) { var n = this.element; if (n = t && n.tagName === "SPAN" && t.width) delete t.width, this.textWidth = n, this.updateTransform(); this.styles = e(this.styles, t); v(this.element, t); return this }, htmlGetBBox: function () { var e = this.element, t = this.bBox; if (!t) { if (e.nodeName === "text") e.style.position = "absolute"; t = this.bBox = { x: e.offsetLeft, y: e.offsetTop, width: e.offsetWidth, height: e.offsetHeight } } return t }, htmlUpdateTransform: function () { if (this.added) { var e = this.renderer, t = this.element, n = this.translateX || 0, i = this.translateY || 0, s = this.x || 0, o = this.y || 0, u = this.textAlign || "left", a = { left: 0, center: .5, right: 1 }[u], f = this.shadows; v(t, { marginLeft: n, marginTop: i }); f && Kt(f, function (e) { v(e, { marginLeft: n + 1, marginTop: i + 1 }) }); this.inverted && Kt(t.childNodes, function (n) { e.invertChild(n, t) }); if (t.tagName === "SPAN") { var l = this.rotation, h, p = r(this.textWidth), m = [l, u, t.innerHTML, this.textWidth].join(","); if (m !== this.cTT) { h = e.fontMetrics(t.style.fontSize).b; c(l) && this.setSpanRotation(l, a, h); f = d(this.elemWidth, t.offsetWidth); if (f > p && /[ \-]/.test(t.textContent || t.innerText)) v(t, { width: p + "px", display: "block", whiteSpace: "normal" }), f = p; this.getSpanCorrection(f, h, a, l, u) } v(t, { left: s + (this.xCorr || 0) + "px", top: o + (this.yCorr || 0) + "px" }); if (st) h = t.offsetHeight; this.cTT = m } } else this.alignOnAdd = !0 }, setSpanRotation: function (e, t, n) { var r = {}, i = rt ? "-ms-transform" : st ? "-webkit-transform" : ot ? "MozTransform" : nt ? "-o-transform" : ""; r[i] = r.transform = "rotate(" + e + "deg)"; r[i + (ot ? "Origin" : "-origin")] = r.transformOrigin = t * 100 + "% " + n + "px"; v(this.element, r) }, getSpanCorrection: function (e, t, n) { this.xCorr = -e * n; this.yCorr = -t } }); e(cn.prototype, { html: function (t, n, r) { var i = this.createElement("span"), s = i.element, o = i.renderer; i.textSetter = function (e) { e !== s.innerHTML && delete this.bBox; s.innerHTML = this.textStr = e }; i.xSetter = i.ySetter = i.alignSetter = i.rotationSetter = function (e, t) { t === "align" && (t = "textAlign"); i[t] = e; i.htmlUpdateTransform() }; i.attr({ text: t, x: X(n), y: X(r) }).css({ position: "absolute", whiteSpace: "nowrap", fontFamily: this.style.fontFamily, fontSize: this.style.fontSize }); i.css = i.htmlCss; if (o.isSVG) i.add = function (t) { var n, r = o.box.parentNode, u = []; if (this.parentGroup = t) { if (n = t.div, !n) { for (; t;) u.push(t), t = t.parentGroup; Kt(u.reverse(), function (t) { var i; n = t.div = t.div || m(Nt, { className: h(t.element, "class") }, { position: "absolute", left: (t.translateX || 0) + "px", top: (t.translateY || 0) + "px" }, n || r); i = n.style; e(t, { translateXSetter: function (e, n) { i.left = e + "px"; t[n] = e; t.doTransform = !0 }, translateYSetter: function (e, n) { i.top = e + "px"; t[n] = e; t.doTransform = !0 }, visibilitySetter: function (e, t) { i[t] = e } }) }) } } else n = r; n.appendChild(s); i.added = !0; i.alignOnAdd && i.htmlUpdateTransform(); return i }; return i } }); var hn, pn; if (!ft && !ct) zt.VMLElement = pn = { init: function (e, t) { var n = ["<", t, ' filled="f" stroked="f"'], r = ["position: ", "absolute", ";"], i = t === Nt; (t === "shape" || i) && r.push("left:0;top:0;width:1px;height:1px;"); r.push("visibility: ", i ? "hidden" : "visible"); n.push(' style="', r.join(""), '"/>'); if (t) n = i || t === "span" || t === "img" ? n.join("") : e.prepVML(n), this.element = m(n); this.renderer = e }, add: function (e) { var t = this.renderer, n = this.element, r = t.box, r = e ? e.element || e : r; e && e.inverted && t.invertChild(n, r); r.appendChild(n); this.added = !0; this.alignOnAdd && !this.deferUpdateTransform && this.updateTransform(); if (this.onAdd) this.onAdd(); return this }, updateTransform: P.prototype.htmlUpdateTransform, setSpanRotation: function () { var e = this.rotation, t = G(e * et), n = Y(e * et); v(this.element, { filter: e ? ["progid:DXImageTransform.Microsoft.Matrix(M11=", t, ", M12=", -n, ", M21=", n, ", M22=", t, ", sizingMethod='auto expand')"].join("") : Ct }) }, getSpanCorrection: function (e, t, n, r, i) { var s = r ? G(r * et) : 1, o = r ? Y(r * et) : 0, u = d(this.elemHeight, this.element.offsetHeight), a; this.xCorr = s < 0 && -e; this.yCorr = o < 0 && -u; a = s * o < 0; this.xCorr += o * t * (a ? 1 - n : n); this.yCorr -= s * t * (r ? a ? n : 1 - n : 1); i && i !== "left" && (this.xCorr -= e * n * (s < 0 ? -1 : 1), r && (this.yCorr -= u * n * (o < 0 ? -1 : 1)), v(this.element, { textAlign: i })) }, pathToVML: function (e) { for (var t = e.length, n = []; t--;) if (u(e[t])) n[t] = X(e[t] * 10) - 5; else if (e[t] === "Z") n[t] = "x"; else if (n[t] = e[t], e.isArc && (e[t] === "wa" || e[t] === "at")) n[t + 5] === n[t + 7] && (n[t + 7] += e[t + 7] > e[t + 5] ? 1 : -1), n[t + 6] === n[t + 8] && (n[t + 8] += e[t + 8] > e[t + 6] ? 1 : -1); return n.join(" ") || "x" }, clip: function (e) { var t = this, n; e ? (n = e.members, l(n, t), n.push(t), t.destroyClip = function () { l(n, t) }, e = e.getCSS(t)) : (t.destroyClip && t.destroyClip(), e = { clip: it ? "inherit" : "rect(auto)" }); return t.css(e) }, css: P.prototype.htmlCss, safeRemoveChild: function (e) { e.parentNode && A(e) }, destroy: function () { this.destroyClip && this.destroyClip(); return P.prototype.destroy.apply(this) }, on: function (e, t) { this.element["on" + e] = function () { var e = z.event; e.target = e.srcElement; t(e) }; return this }, cutOffPath: function (e, t) { var n, e = e.split(/[ ,]/); n = e.length; if (n === 9 || n === 11) e[n - 4] = e[n - 2] = r(e[n - 2]) - 10 * t; return e.join(" ") }, shadow: function (e, t, n) { var i = [], s, o = this.element, u = this.renderer, a, f = o.style, l, c = o.path, h, p, v, g; c && typeof c.value !== "string" && (c = "x"); p = c; if (e) { v = d(e.width, 3); g = (e.opacity || .15) / v; for (s = 1; s <= 3; s++) { h = v * 2 + 1 - 2 * s; n && (p = this.cutOffPath(c.value, h + .5)); l = ['<shape isShadow="true" strokeweight="', h, '" filled="false" path="', p, '" coordsize="10 10" style="', o.style.cssText, '" />']; a = m(u.prepVML(l), null, { left: r(f.left) + d(e.offsetX, 1), top: r(f.top) + d(e.offsetY, 1) }); if (n) a.cutOff = h + 1; l = ['<stroke color="', e.color || "black", '" opacity="', g * s, '"/>']; m(u.prepVML(l), null, null, a); t ? t.element.appendChild(a) : o.parentNode.insertBefore(a, o); i.push(a) } this.shadows = i } return this }, updateShadows: St, setAttr: function (e, t) { it ? this.element[e] = t : this.element.setAttribute(e, t) }, classSetter: function (e) { this.element.className = e }, dashstyleSetter: function (e, t, n) { (n.getElementsByTagName("stroke")[0] || m(this.renderer.prepVML(["<stroke/>"]), null, null, n))[t] = e || "solid"; this[t] = e }, dSetter: function (e, t, n) { var r = this.shadows, e = e || []; this.d = e.join(" "); n.path = e = this.pathToVML(e); if (r) for (n = r.length; n--;) r[n].path = r[n].cutOff ? this.cutOffPath(e, r[n].cutOff) : e; this.setAttr(t, e) }, fillSetter: function (e, t, n) { var r = n.nodeName; if (r === "SPAN") n.style.color = e; else if (r !== "IMG") n.filled = e !== Ct, this.setAttr("fillcolor", this.renderer.color(e, n, t, this)) }, opacitySetter: St, rotationSetter: function (e, t, n) { n = n.style; this[t] = n[t] = e; n.left = -X(Y(e * et) + 1) + "px"; n.top = X(G(e * et)) + "px" }, strokeSetter: function (e, t, n) { this.setAttr("strokecolor", this.renderer.color(e, n, t)) }, "stroke-widthSetter": function (e, t, n) { n.stroked = !!e; this[t] = e; u(e) && (e += "px"); this.setAttr("strokeweight", e) }, titleSetter: function (e, t) { this.setAttr(t, e) }, visibilitySetter: function (e, t, n) { e === "inherit" && (e = "visible"); this.shadows && Kt(this.shadows, function (n) { n.style[t] = e }); n.nodeName === "DIV" && (e = e === "hidden" ? "-999em" : 0, it || (n.style[t] = e ? "visible" : "hidden"), t = "top"); n.style[t] = e }, xSetter: function (e, t, n) { this[t] = e; t === "x" ? t = "left" : t === "y" && (t = "top"); this.updateClipping ? (this[t] = e, this.updateClipping()) : n.style[t] = e }, zIndexSetter: function (e, t, n) { n.style[t] = e } }, pn = g(P, pn), pn.prototype.ySetter = pn.prototype.widthSetter = pn.prototype.heightSetter = pn.prototype.xSetter, pn = { Element: pn, isIE8: tt.indexOf("MSIE 8.0") > -1, init: function (t, n, r, i) { var s; this.alignedObjects = []; i = this.createElement(Nt).css(e(this.getStyle(i), { position: "relative" })); s = i.element; t.appendChild(i.element); this.isVML = !0; this.box = s; this.boxWrapper = i; this.cache = {}; this.setSize(n, r, !1); if (!U.namespaces.hcv) { U.namespaces.add("hcv", "urn:schemas-microsoft-com:vml"); try { U.createStyleSheet().cssText = "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } " } catch (o) { U.styleSheets[0].cssText += "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } " } } }, isHidden: function () { return !this.box.offsetWidth }, clipRect: function (t, n, r, i) { var o = this.createElement(), u = s(t); return e(o, { members: [], left: (u ? t.x : t) + 1, top: (u ? t.y : n) + 1, width: (u ? t.width : r) - 1, height: (u ? t.height : i) - 1, getCSS: function (t) { var n = t.element, r = n.nodeName, t = t.inverted, i = this.top - (r === "shape" ? n.offsetTop : 0), s = this.left, n = s + this.width, o = i + this.height, i = { clip: "rect(" + X(t ? s : i) + "px," + X(t ? o : n) + "px," + X(t ? n : o) + "px," + X(t ? i : s) + "px)" }; !t && it && r === "DIV" && e(i, { width: n + "px", height: o + "px" }); return i }, updateClipping: function () { Kt(o.members, function (e) { e.element && e.css(o.getCSS(e)) }) } }) }, color: function (e, t, n, r) { var i = this, s, o = /^rgba/, u, a, f = Ct; e && e.linearGradient ? a = "gradient" : e && e.radialGradient && (a = "pattern"); if (a) { var l, c, h = e.linearGradient || e.radialGradient, p, d, v, g, y, b = "", e = e.stops, w, E = [], S = function () { u = ['<fill colors="' + E.join(",") + '" opacity="', v, '" o:opacity2="', d, '" type="', a, '" ', b, 'focus="100%" method="any" />']; m(i.prepVML(u), null, null, t) }; p = e[0]; w = e[e.length - 1]; p[0] > 0 && e.unshift([0, p[1]]); w[0] < 1 && e.push([1, w[1]]); Kt(e, function (e, t) { o.test(e[1]) ? (s = ln(e[1]), l = s.get("rgb"), c = s.get("a")) : (l = e[1], c = 1); E.push(e[0] * 100 + "% " + l); t ? (v = c, g = l) : (d = c, y = l) }); if (n === "fill") if (a === "gradient") n = h.x1 || h[0] || 0, e = h.y1 || h[1] || 0, p = h.x2 || h[2] || 0, h = h.y2 || h[3] || 0, b = 'angle="' + (90 - W.atan((h - e) / (p - n)) * 180 / Z) + '"', S(); else { var f = h.r, x = f * 2, T = f * 2, N = h.cx, C = h.cy, k = t.radialReference, L, f = function () { k && (L = r.getBBox(), N += (k[0] - L.x) / L.width - .5, C += (k[1] - L.y) / L.height - .5, x *= k[2] / L.width, T *= k[2] / L.height); b = 'src="' + gt.global.VMLRadialGradientURL + '" size="' + x + "," + T + '" origin="0.5,0.5" position="' + N + "," + C + '" color2="' + y + '" '; S() }; r.added ? f() : r.onAdd = f; f = g } else f = l } else if (o.test(e) && t.tagName !== "IMG") s = ln(e), u = ["<", n, ' opacity="', s.get("a"), '"/>'], m(this.prepVML(u), null, null, t), f = s.get("rgb"); else { f = t.getElementsByTagName(n); if (f.length) f[0].opacity = 1, f[0].type = "solid"; f = e } return f }, prepVML: function (e) { var t = this.isIE8, e = e.join(""); t ? (e = e.replace("/>", ' xmlns="urn:schemas-microsoft-com:vml" />'), e = e.indexOf('style="') === -1 ? e.replace("/>", ' style="display:inline-block;behavior:url(#default#VML);" />') : e.replace('style="', 'style="display:inline-block;behavior:url(#default#VML);')) : e = e.replace("<", "<hcv:"); return e }, text: cn.prototype.html, path: function (t) { var n = { coordsize: "10 10" }; o(t) ? n.d = t : s(t) && e(n, t); return this.createElement("shape").attr(n) }, circle: function (e, t, n) { var r = this.symbol("circle"); if (s(e)) n = e.r, t = e.y, e = e.x; r.isCircle = !0; r.r = n; return r.attr({ x: e, y: t }) }, g: function (e) { var t; e && (t = { className: "highcharts-" + e, "class": "highcharts-" + e }); return this.createElement(Nt).attr(t) }, image: function (e, t, n, r, i) { var s = this.createElement("img").attr({ src: e }); arguments.length > 1 && s.attr({ x: t, y: n, width: r, height: i }); return s }, createElement: function (e) { return e === "rect" ? this.symbol(e) : cn.prototype.createElement.call(this, e) }, invertChild: function (e, t) { var n = this, i = t.style, s = e.tagName === "IMG" && e.style; v(e, { flip: "x", left: r(i.width) - (s ? r(s.top) : 1), top: r(i.height) - (s ? r(s.left) : 1), rotation: -90 }); Kt(e.childNodes, function (t) { n.invertChild(t, e) }) }, symbols: { arc: function (e, t, n, r, i) { var s = i.start, o = i.end, u = i.r || n || r, n = i.innerR, r = G(s), a = Y(s), f = G(o), l = Y(o); if (o - s === 0) return ["x"]; s = ["wa", e - u, t - u, e + u, t + u, e + u * r, t + u * a, e + u * f, t + u * l]; i.open && !n && s.push("e", "M", e, t); s.push("at", e - n, t - n, e + n, t + n, e + n * f, t + n * l, e + n * r, t + n * a, "x", "e"); s.isArc = !0; return s }, circle: function (e, t, n, r, i) { i && (n = r = 2 * i.r); i && i.isCircle && (e -= n / 2, t -= r / 2); return ["wa", e, t, e + n, t + r, e + n, t + r / 2, e + n, t + r / 2, "e"] }, rect: function (e, t, n, r, i) { return cn.prototype.symbols[!c(i) || !i.r ? "square" : "callout"].call(0, e, t, n, r, i) } } }, zt.VMLRenderer = hn = function () { this.init.apply(this, arguments) }, hn.prototype = t(cn.prototype, pn), ht = hn; cn.prototype.measureSpanWidth = function (e, t) { var n = U.createElement("span"), r; r = U.createTextNode(e); n.appendChild(r); v(n, t); this.box.appendChild(n); r = n.offsetWidth; A(n); return r }; var dn; if (ct) zt.CanVGRenderer = pn = function () { at = "http://www.w3.org/1999/xhtml" }, pn.prototype.symbols = {}, dn = function () { function e() { var e = t.length, n; for (n = 0; n < e; n++) t[n](); t = [] } var t = []; return { push: function (n, r) { t.length === 0 && $t(r, e); t.push(n) } } }(), ht = pn; H.prototype = { addLabel: function () { var t = this.axis, n = t.options, r = t.chart, i = t.horiz, s = t.categories, o = t.names, a = this.pos, l = n.labels, h = t.tickPositions, i = i && s && !l.step && !l.staggerLines && !l.rotation && r.plotWidth / h.length || !i && (r.margin[3] || r.chartWidth * .33), p = a === h[0], v = a === h[h.length - 1], m, o = s ? d(s[a], o[a], a) : a, s = this.label, g = h.info; t.isDatetimeAxis && g && (m = n.dateTimeLabelFormats[g.higherRanks[a] || g.unitName]); this.isFirst = p; this.isLast = v; n = t.labelFormatter.call({ axis: t, chart: r, isFirst: p, isLast: v, dateTimeLabelFormat: m, value: t.isLog ? M(f(o)) : o }); a = i && { width: J(1, X(i - 2 * (l.padding || 10))) + "px" }; a = e(a, l.style); if (c(s)) s && s.attr({ text: n }).css(a); else { m = { align: t.labelAlign }; if (u(l.rotation)) m.rotation = l.rotation; if (i && l.ellipsis) m._clipHeight = t.len / h.length; this.label = c(n) && l.enabled ? r.renderer.text(n, 0, 0, l.useHTML).attr(m).css(a).add(t.labelGroup) : null } }, getLabelSize: function () { var e = this.label, t = this.axis; return e ? e.getBBox()[t.horiz ? "height" : "width"] : 0 }, getLabelSides: function () { var e = this.label.getBBox(), t = this.axis, n = t.horiz, r = t.options.labels, e = n ? e.width : e.height, t = n ? r.x - e * { left: 0, center: .5, right: 1 }[t.labelAlign] : 0; return [t, n ? e + t : e] }, handleOverflow: function (e, t) { var n = !0, r = this.axis, i = this.isFirst, s = this.isLast, o = r.horiz ? t.x : t.y, u = r.reversed, a = r.tickPositions, f = this.getLabelSides(), l = f[0], f = f[1], c, h, p, d = this.label.line || 0; c = r.labelEdge; h = r.justifyLabels && (i || s); c[d] === R || o + l > c[d] ? c[d] = o + f : h || (n = !1); if (h) { c = (h = r.justifyToPlot) ? r.pos : 0; h = h ? c + r.len : r.chart.chartWidth; do e += i ? 1 : -1, p = r.ticks[a[e]]; while (a[e] && (!p || p.label.line !== d)); r = p && p.label.xy && p.label.xy.x + p.getLabelSides()[i ? 0 : 1]; i && !u || s && u ? o + l < c && (o = c - l, p && o + f > r && (n = !1)) : o + f > h && (o = h - f, p && o + l < r && (n = !1)); t.x = o } return n }, getPosition: function (e, t, n, r) { var i = this.axis, s = i.chart, o = r && s.oldChartHeight || s.chartHeight; return { x: e ? i.translate(t + n, null, null, r) + i.transB : i.left + i.offset + (i.opposite ? (r && s.oldChartWidth || s.chartWidth) - i.right - i.left : 0), y: e ? o - i.bottom + i.offset - (i.opposite ? i.height : 0) : o - i.translate(t + n, null, null, r) - i.transB } }, getLabelPosition: function (e, t, n, r, i, s, o, u) { var a = this.axis, f = a.transA, l = a.reversed, h = a.staggerLines, p = a.chart.renderer.fontMetrics(i.style.fontSize).b, d = i.rotation, e = e + i.x - (s && r ? s * f * (l ? -1 : 1) : 0), t = t + i.y - (s && !r ? s * f * (l ? 1 : -1) : 0); d && a.side === 2 && (t -= p - p * G(d * et)); !c(i.y) && !d && (t += p - n.getBBox().height / 2); if (h) n.line = o / (u || 1) % h, t += n.line * (a.labelOffset / h); return { x: e, y: t } }, getMarkPath: function (e, t, n, r, i, s) { return s.crispLine(["M", e, t, "L", e + (i ? 0 : -n), t + (i ? n : 0)], r) }, render: function (e, t, n) { var r = this.axis, i = r.options, s = r.chart.renderer, o = r.horiz, u = this.type, a = this.label, f = this.pos, l = i.labels, c = this.gridLine, h = u ? u + "Grid" : "grid", p = u ? u + "Tick" : "tick", v = i[h + "LineWidth"], m = i[h + "LineColor"], g = i[h + "LineDashStyle"], y = i[p + "Length"], h = i[p + "Width"] || 0, b = i[p + "Color"], w = i[p + "Position"], p = this.mark, E = l.step, S = !0, x = r.tickmarkOffset, T = this.getPosition(o, f, x, t), N = T.x, T = T.y, C = o && N === r.pos + r.len || !o && T === r.pos ? -1 : 1; this.isActive = !0; if (v) { f = r.getPlotLinePath(f + x, v * C, t, !0); if (c === R) { c = { stroke: m, "stroke-width": v }; if (g) c.dashstyle = g; if (!u) c.zIndex = 1; if (t) c.opacity = 0; this.gridLine = c = v ? s.path(f).attr(c).add(r.gridGroup) : null } if (!t && c && f) c[this.isNew ? "attr" : "animate"]({ d: f, opacity: n }) } if (h && y) w === "inside" && (y = -y), r.opposite && (y = -y), u = this.getMarkPath(N, T, y, h * C, o, s), p ? p.animate({ d: u, opacity: n }) : this.mark = s.path(u).attr({ stroke: b, "stroke-width": h, opacity: n }).add(r.axisGroup); if (a && !isNaN(N)) a.xy = T = this.getLabelPosition(N, T, a, o, l, x, e, E), this.isFirst && !this.isLast && !d(i.showFirstLabel, 1) || this.isLast && !this.isFirst && !d(i.showLastLabel, 1) ? S = !1 : !r.isRadial && !l.step && !l.rotation && !t && n !== 0 && (S = this.handleOverflow(e, T)), E && e % E && (S = !1), S && !isNaN(T.y) ? (T.opacity = n, a[this.isNew ? "attr" : "animate"](T), this.isNew = !1) : a.attr("y", -9999) }, destroy: function () { L(this, this.axis) } }; zt.PlotLineOrBand = function (e, t) { this.axis = e; if (t) this.options = t, this.id = t.id }; zt.PlotLineOrBand.prototype = { render: function () { var e = this, n = e.axis, r = n.horiz, i = (n.pointRange || 0) / 2, s = e.options, o = s.label, u = e.label, f = s.width, l = s.to, h = s.from, p = c(h) && c(l), v = s.value, m = s.dashStyle, g = e.svgElem, y = [], b, w = s.color, E = s.zIndex, S = s.events, x = {}, T = n.chart.renderer; n.isLog && (h = a(h), l = a(l), v = a(v)); if (f) { if (y = n.getPlotLinePath(v, f), x = { stroke: w, "stroke-width": f }, m) x.dashstyle = m } else if (p) { h = J(h, n.min - i); l = K(l, n.max + i); y = n.getPlotBandPath(h, l, s); if (w) x.fill = w; if (s.borderWidth) x.stroke = s.borderColor, x["stroke-width"] = s.borderWidth } else return; if (c(E)) x.zIndex = E; if (g) if (y) g.animate({ d: y }, null, g.onGetPath); else { if (g.hide(), g.onGetPath = function () { g.show() }, u) e.label = u = u.destroy() } else if (y && y.length && (e.svgElem = g = T.path(y).attr(x).add(), S)) for (b in i = function (t) { g.on(t, function (n) { S[t].apply(e, [n]) }) }, S) i(b); if (o && c(o.text) && y && y.length && n.width > 0 && n.height > 0) { o = t({ align: r && p && "center", x: r ? !p && 4 : 10, verticalAlign: !r && p && "middle", y: r ? p ? 16 : 10 : p ? 6 : -4, rotation: r && !p && 90 }, o); if (!u) { x = { align: o.textAlign || o.align, rotation: o.rotation }; if (c(E)) x.zIndex = E; e.label = u = T.text(o.text, 0, 0, o.useHTML).attr(x).css(o.style).add() } n = [y[1], y[4], d(y[6], y[1])]; y = [y[2], y[5], d(y[7], y[2])]; r = C(n); p = C(y); u.align(o, !1, { x: r, y: p, width: k(n) - r, height: k(y) - p }); u.show() } else u && u.hide(); return e }, destroy: function () { l(this.axis.plotLinesAndBands, this); delete this.axis; L(this) } }; B.prototype = { defaultOptions: { dateTimeLabelFormats: { millisecond: "%H:%M:%S.%L", second: "%H:%M:%S", minute: "%H:%M", hour: "%H:%M", day: "%e. %b", week: "%e. %b", month: "%b '%y", year: "%Y" }, endOnTick: !1, gridLineColor: "#C0C0C0", labels: Xt, lineColor: "#C0D0E0", lineWidth: 1, minPadding: .01, maxPadding: .01, minorGridLineColor: "#E0E0E0", minorGridLineWidth: 1, minorTickColor: "#A0A0A0", minorTickLength: 2, minorTickPosition: "outside", startOfWeek: 1, startOnTick: !1, tickColor: "#C0D0E0", tickLength: 10, tickmarkPlacement: "between", tickPixelInterval: 100, tickPosition: "outside", tickWidth: 1, title: { align: "middle", style: { color: "#707070" } }, type: "linear" }, defaultYAxisOptions: { endOnTick: !0, gridLineWidth: 1, tickPixelInterval: 72, showLastLabel: !0, labels: { x: -8, y: 3 }, lineWidth: 0, maxPadding: .05, minPadding: .05, startOnTick: !0, tickWidth: 0, title: { rotation: 270, text: "Values" }, stackLabels: { enabled: !1, formatter: function () { return y(this.total, -1) }, style: Xt.style } }, defaultLeftAxisOptions: { labels: { x: -15, y: null }, title: { rotation: 270 } }, defaultRightAxisOptions: { labels: { x: 15, y: null }, title: { rotation: 90 } }, defaultBottomAxisOptions: { labels: { x: 0, y: 20 }, title: { rotation: 0 } }, defaultTopAxisOptions: { labels: { x: 0, y: -15 }, title: { rotation: 0 } }, init: function (e, t) { var n = t.isX; this.horiz = e.inverted ? !n : n; this.coll = (this.isXAxis = n) ? "xAxis" : "yAxis"; this.opposite = t.opposite; this.side = t.side || (this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3); this.setOptions(t); var r = this.options, i = r.type; this.labelFormatter = r.labels.formatter || this.defaultLabelFormatter; this.userOptions = t; this.minPixelPadding = 0; this.chart = e; this.reversed = r.reversed; this.zoomEnabled = r.zoomEnabled !== !1; this.categories = r.categories || i === "category"; this.names = []; this.isLog = i === "logarithmic"; this.isDatetimeAxis = i === "datetime"; this.isLinked = c(r.linkedTo); this.tickmarkOffset = this.categories && r.tickmarkPlacement === "between" ? .5 : 0; this.ticks = {}; this.labelEdge = []; this.minorTicks = {}; this.plotLinesAndBands = []; this.alternateBands = {}; this.len = 0; this.minRange = this.userMinRange = r.minRange || r.maxZoom; this.range = r.range; this.offset = r.offset || 0; this.stacks = {}; this.oldStacks = {}; this.min = this.max = null; this.crosshair = d(r.crosshair, p(e.options.tooltip.crosshairs)[n ? 0 : 1], !1); var s, r = this.options.events; Jt(this, e.axes) === -1 && (n && !this.isColorAxis ? e.axes.splice(e.xAxis.length, 0, this) : e.axes.push(this), e[this.coll].push(this)); this.series = this.series || []; if (e.inverted && n && this.reversed === R) this.reversed = !0; this.removePlotLine = this.removePlotBand = this.removePlotBandOrLine; for (s in r) Zt(this, s, r[s]); if (this.isLog) this.val2lin = a, this.lin2val = f }, setOptions: function (e) { this.options = t(this.defaultOptions, this.isXAxis ? {} : this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], t(gt[this.coll], e)) }, defaultLabelFormatter: function () { var e = this.axis, t = this.value, n = e.categories, r = this.dateTimeLabelFormat, i = gt.lang.numericSymbols, s = i && i.length, o, u = e.options.labels.format, e = e.isLog ? t : e.tickInterval; if (u) o = E(u, this); else if (n) o = t; else if (r) o = yt(r, t); else if (s && e >= 1e3) for (; s-- && o === R;) n = Math.pow(1e3, s + 1), e >= n && i[s] !== null && (o = y(t / n, -1) + i[s]); o === R && (o = Q(t) >= 1e4 ? y(t, 0) : y(t, -1, R, "")); return o }, getSeriesExtremes: function () { var e = this, t = e.chart; e.hasVisibleSeries = !1; e.dataMin = e.dataMax = null; e.buildStacks && e.buildStacks(); Kt(e.series, function (n) { if (n.visible || !t.options.chart.ignoreHiddenSeries) { var r; r = n.options.threshold; var i; e.hasVisibleSeries = !0; e.isLog && r <= 0 && (r = null); if (e.isXAxis) { if (r = n.xData, r.length) e.dataMin = K(d(e.dataMin, r[0]), C(r)), e.dataMax = J(d(e.dataMax, r[0]), k(r)) } else { n.getExtremes(); i = n.dataMax; n = n.dataMin; if (c(n) && c(i)) e.dataMin = K(d(e.dataMin, n), n), e.dataMax = J(d(e.dataMax, i), i); if (c(r)) if (e.dataMin >= r) e.dataMin = r, e.ignoreMinPadding = !0; else if (e.dataMax < r) e.dataMax = r, e.ignoreMaxPadding = !0 } } }) }, translate: function (e, t, n, r, i, s) { var o = 1, a = 0, f = r ? this.oldTransA : this.transA, r = r ? this.oldMin : this.min, l = this.minPixelPadding, i = (this.options.ordinal || this.isLog && i) && this.lin2val; if (!f) f = this.transA; if (n) o *= -1, a = this.len; this.reversed && (o *= -1, a -= o * (this.sector || this.len)); t ? (e = e * o + a, e -= l, e = e / f + r, i && (e = this.lin2val(e))) : (i && (e = this.val2lin(e)), s === "between" && (s = .5), e = o * (e - r) * f + a + o * l + (u(s) ? f * s * this.pointRange : 0)); return e }, toPixels: function (e, t) { return this.translate(e, !1, !this.horiz, null, !0) + (t ? 0 : this.pos) }, toValue: function (e, t) { return this.translate(e - (t ? 0 : this.pos), !0, !this.horiz, null, !0) }, getPlotLinePath: function (e, t, n, r, i) { var s = this.chart, o = this.left, u = this.top, a, f, l = n && s.oldChartHeight || s.chartHeight, c = n && s.oldChartWidth || s.chartWidth, h; a = this.transB; i = d(i, this.translate(e, null, null, n)); e = n = X(i + a); a = f = X(l - i - a); if (isNaN(i)) h = !0; else if (this.horiz) { if (a = u, f = l - this.bottom, e < o || e > o + this.width) h = !0 } else if (e = o, n = c - this.right, a < u || a > u + this.height) h = !0; return h && !r ? null : s.renderer.crispLine(["M", e, a, "L", n, f], t || 1) }, getLinearTickPositions: function (e, t, n) { var r, i = M(V(t / e) * e), s = M($(n / e) * e), o = []; if (t === n && u(t)) return [t]; for (t = i; t <= s;) { o.push(t); t = M(t + e); if (t === r) break; r = t } return o }, getMinorTickPositions: function () { var e = this.options, t = this.tickPositions, n = this.minorTickInterval, r = [], i; if (this.isLog) { i = t.length; for (e = 1; e < i; e++) r = r.concat(this.getLogTickPositions(n, t[e - 1], t[e], !0)) } else if (this.isDatetimeAxis && e.minorTickInterval === "auto") r = r.concat(this.getTimeTicks(this.normalizeTimeTickInterval(n), this.min, this.max, e.startOfWeek)), r[0] < this.min && r.shift(); else for (t = this.min + (t[0] - this.min) % n; t <= this.max; t += n) r.push(t); return r }, adjustForMinRange: function () { var e = this.options, t = this.min, n = this.max, r, i = this.dataMax - this.dataMin >= this.minRange, s, o, u, a, f; if (this.isXAxis && this.minRange === R && !this.isLog) c(e.min) || c(e.max) ? this.minRange = null : (Kt(this.series, function (e) { a = e.xData; for (o = f = e.xIncrement ? 1 : a.length - 1; o > 0; o--) if (u = a[o] - a[o - 1], s === R || u < s) s = u }), this.minRange = K(s * 5, this.dataMax - this.dataMin)); if (n - t < this.minRange) { var l = this.minRange; r = (l - n + t) / 2; r = [t - r, d(e.min, t - r)]; if (i) r[2] = this.dataMin; t = k(r); n = [t + l, d(e.max, t + l)]; if (i) n[2] = this.dataMax; n = C(n); n - t < l && (r[0] = n - l, r[1] = d(e.min, n - l), t = k(r)) } this.min = t; this.max = n }, setAxisTranslation: function (e) { var t = this, n = t.max - t.min, r = t.axisPointRange || 0, s, o = 0, u = 0, a = t.linkedParent, f = !!t.categories, l = t.transA; if (t.isXAxis || f || r) a ? (o = a.minPointOffset, u = a.pointRangePadding) : Kt(t.series, function (e) { var a = f ? 1 : t.isXAxis ? e.pointRange : t.axisPointRange || 0, l = e.options.pointPlacement, h = e.closestPointRange; a > n && (a = 0); r = J(r, a); o = J(o, i(l) ? 0 : a / 2); u = J(u, l === "on" ? 0 : a); !e.noSharedTooltip && c(h) && (s = c(s) ? K(s, h) : h) }), a = t.ordinalSlope && s ? t.ordinalSlope / s : 1, t.minPointOffset = o *= a, t.pointRangePadding = u *= a, t.pointRange = K(r, n), t.closestPointRange = s; if (e) t.oldTransA = l; t.translationSlope = t.transA = l = t.len / (n + u || 1); t.transB = t.horiz ? t.left : t.bottom; t.minPixelPadding = l * o }, setTickPositions: function (e) { var t = this, n = t.chart, r = t.options, i = t.isLog, s = t.isDatetimeAxis, o = t.isXAxis, f = t.isLinked, l = t.options.tickPositioner, h = r.maxPadding, p = r.minPadding, v = r.tickInterval, m = r.minTickInterval, g = r.tickPixelInterval, y, b = t.categories; f ? (t.linkedParent = n[t.coll][r.linkedTo], n = t.linkedParent.getExtremes(), t.min = d(n.min, n.dataMin), t.max = d(n.max, n.dataMax), r.type !== t.linkedParent.options.type && O(11, 1)) : (t.min = d(t.userMin, r.min, t.dataMin), t.max = d(t.userMax, r.max, t.dataMax)); if (i) !e && K(t.min, d(t.dataMin, t.min)) <= 0 && O(10, 1), t.min = M(a(t.min)), t.max = M(a(t.max)); if (t.range && c(t.max)) t.userMin = t.min = J(t.min, t.max - t.range), t.userMax = t.max, t.range = null; t.beforePadding && t.beforePadding(); t.adjustForMinRange(); if (!b && !t.axisPointRange && !t.usePercentage && !f && c(t.min) && c(t.max) && (n = t.max - t.min)) { if (!c(r.min) && !c(t.userMin) && p && (t.dataMin < 0 || !t.ignoreMinPadding)) t.min -= n * p; if (!c(r.max) && !c(t.userMax) && h && (t.dataMax > 0 || !t.ignoreMaxPadding)) t.max += n * h } if (u(r.floor)) t.min = J(t.min, r.floor); if (u(r.ceiling)) t.max = K(t.max, r.ceiling); t.min === t.max || t.min === void 0 || t.max === void 0 ? t.tickInterval = 1 : f && !v && g === t.linkedParent.options.tickPixelInterval ? t.tickInterval = t.linkedParent.tickInterval : (t.tickInterval = d(v, b ? 1 : (t.max - t.min) * g / J(t.len, g)), !c(v) && t.len < g && !this.isRadial && !this.isLog && !b && r.startOnTick && r.endOnTick && (y = !0, t.tickInterval /= 4)); o && !e && Kt(t.series, function (e) { e.processData(t.min !== t.oldMin || t.max !== t.oldMax) }); t.setAxisTranslation(!0); t.beforeSetTickPositions && t.beforeSetTickPositions(); if (t.postProcessTickInterval) t.tickInterval = t.postProcessTickInterval(t.tickInterval); if (t.pointRange) t.tickInterval = J(t.pointRange, t.tickInterval); if (!v && t.tickInterval < m) t.tickInterval = m; if (!s && !i && !v) t.tickInterval = x(t.tickInterval, null, S(t.tickInterval), r); t.minorTickInterval = r.minorTickInterval === "auto" && t.tickInterval ? t.tickInterval / 5 : r.minorTickInterval; t.tickPositions = e = r.tickPositions ? [].concat(r.tickPositions) : l && l.apply(t, [t.min, t.max]); if (!e) !t.ordinalPositions && (t.max - t.min) / t.tickInterval > J(2 * t.len, 200) && O(19, !0), e = s ? t.getTimeTicks(t.normalizeTimeTickInterval(t.tickInterval, r.units), t.min, t.max, r.startOfWeek, t.ordinalPositions, t.closestPointRange, !0) : i ? t.getLogTickPositions(t.tickInterval, t.min, t.max) : t.getLinearTickPositions(t.tickInterval, t.min, t.max), y && e.splice(1, e.length - 2), t.tickPositions = e; if (!f) i = e[0], s = e[e.length - 1], f = t.minPointOffset || 0, r.startOnTick ? t.min = i : t.min - f > i && e.shift(), r.endOnTick ? t.max = s : t.max + f < s && e.pop(), e.length === 1 && (r = Q(t.max) > 1e13 ? 1 : .001, t.min -= r, t.max += r) }, setMaxTicks: function () { var e = this.chart, t = e.maxTicks || {}, n = this.tickPositions, r = this._maxTicksKey = [this.coll, this.pos, this.len].join("-"); if (!this.isLinked && !this.isDatetimeAxis && n && n.length > (t[r] || 0) && this.options.alignTicks !== !1) t[r] = n.length; e.maxTicks = t }, adjustTickAmount: function () { var e = this._maxTicksKey, t = this.tickPositions, n = this.chart.maxTicks; if (n && n[e] && !this.isDatetimeAxis && !this.categories && !this.isLinked && this.options.alignTicks !== !1 && this.min !== R) { var r = this.tickAmount, i = t.length; this.tickAmount = e = n[e]; if (i < e) { for (; t.length < e;) t.push(M(t[t.length - 1] + this.tickInterval)); this.transA *= (i - 1) / (e - 1); this.max = t[t.length - 1] } if (c(r) && e !== r) this.isDirty = !0 } }, setScale: function () { var e = this.stacks, t, n, r, i; this.oldMin = this.min; this.oldMax = this.max; this.oldAxisLength = this.len; this.setAxisSize(); i = this.len !== this.oldAxisLength; Kt(this.series, function (e) { if (e.isDirtyData || e.isDirty || e.xAxis.isDirty) r = !0 }); if (i || r || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax) { if (!this.isXAxis) for (t in e) for (n in e[t]) e[t][n].total = null, e[t][n].cum = 0; this.forceRedraw = !1; this.getSeriesExtremes(); this.setTickPositions(); this.oldUserMin = this.userMin; this.oldUserMax = this.userMax; if (!this.isDirty) this.isDirty = i || this.min !== this.oldMin || this.max !== this.oldMax } else if (!this.isXAxis) { if (this.oldStacks) e = this.stacks = this.oldStacks; for (t in e) for (n in e[t]) e[t][n].cum = e[t][n].total } this.setMaxTicks() }, setExtremes: function (t, n, r, i, s) { var o = this, u = o.chart, r = d(r, !0), s = e(s, { min: t, max: n }); tn(o, "setExtremes", s, function () { o.userMin = t; o.userMax = n; o.eventArgs = s; o.isDirtyExtremes = !0; r && u.redraw(i) }) }, zoom: function (e, t) { var n = this.dataMin, r = this.dataMax, i = this.options; this.allowZoomOutside || (c(n) && e <= K(n, d(i.min, n)) && (e = R), c(r) && t >= J(r, d(i.max, r)) && (t = R)); this.displayBtn = e !== R || t !== R; this.setExtremes(e, t, !1, R, { trigger: "zoom" }); return !0 }, setAxisSize: function () { var e = this.chart, t = this.options, n = t.offsetLeft || 0, r = this.horiz, i = d(t.width, e.plotWidth - n + (t.offsetRight || 0)), s = d(t.height, e.plotHeight), o = d(t.top, e.plotTop), t = d(t.left, e.plotLeft + n), n = /%$/; n.test(s) && (s = parseInt(s, 10) / 100 * e.plotHeight); n.test(o) && (o = parseInt(o, 10) / 100 * e.plotHeight + e.plotTop); this.left = t; this.top = o; this.width = i; this.height = s; this.bottom = e.chartHeight - s - o; this.right = e.chartWidth - i - t; this.len = J(r ? i : s, 0); this.pos = r ? t : o }, getExtremes: function () { var e = this.isLog; return { min: e ? M(f(this.min)) : this.min, max: e ? M(f(this.max)) : this.max, dataMin: this.dataMin, dataMax: this.dataMax, userMin: this.userMin, userMax: this.userMax } }, getThreshold: function (e) { var t = this.isLog, n = t ? f(this.min) : this.min, t = t ? f(this.max) : this.max; n > e || e === null ? e = n : t < e && (e = t); return this.translate(e, 0, 1, 0, 1) }, autoLabelAlign: function (e) { e = (d(e, 0) - this.side * 90 + 720) % 360; return e > 15 && e < 165 ? "right" : e > 195 && e < 345 ? "left" : "center" }, getOffset: function () { var e = this, t = e.chart, n = t.renderer, r = e.options, i = e.tickPositions, s = e.ticks, o = e.horiz, u = e.side, a = t.inverted ? [1, 0, 3, 2][u] : u, f, l = 0, h, p = 0, v = r.title, m = r.labels, g = 0, y = t.axisOffset, b = t.clipOffset, w = [-1, 1, 1, -1][u], E, S = 1, x = d(m.maxStaggerLines, 5), T, N, C, k, L = u === 2 ? n.fontMetrics(m.style.fontSize).b : 0; e.hasData = f = e.hasVisibleSeries || c(e.min) && c(e.max) && !!i; e.showAxis = t = f || d(r.showEmpty, !0); e.staggerLines = e.horiz && m.staggerLines; if (!e.axisGroup) e.gridGroup = n.g("grid").attr({ zIndex: r.gridZIndex || 1 }).add(), e.axisGroup = n.g("axis").attr({ zIndex: r.zIndex || 2 }).add(), e.labelGroup = n.g("axis-labels").attr({ zIndex: m.zIndex || 7 }).addClass("highcharts-" + e.coll.toLowerCase() + "-labels").add(); if (f || e.isLinked) { e.labelAlign = d(m.align || e.autoLabelAlign(m.rotation)); Kt(i, function (t) { s[t] ? s[t].addLabel() : s[t] = new H(e, t) }); if (e.horiz && !e.staggerLines && x && !m.rotation) { for (E = e.reversed ? [].concat(i).reverse() : i; S < x;) { f = []; T = !1; for (m = 0; m < E.length; m++) N = E[m], C = (C = s[N].label && s[N].label.getBBox()) ? C.width : 0, k = m % S, C && (N = e.translate(N), f[k] !== R && N < f[k] && (T = !0), f[k] = N + C); if (T) S++; else break } if (S > 1) e.staggerLines = S } Kt(i, function (t) { if (u === 0 || u === 2 || { 1: "left", 3: "right" }[u] === e.labelAlign) g = J(s[t].getLabelSize(), g) }); if (e.staggerLines) g *= e.staggerLines, e.labelOffset = g } else for (E in s) s[E].destroy(), delete s[E]; if (v && v.text && v.enabled !== !1) { if (!e.axisTitle) e.axisTitle = n.text(v.text, 0, 0, v.useHTML).attr({ zIndex: 7, rotation: v.rotation || 0, align: v.textAlign || { low: "left", middle: "center", high: "right" }[v.align] }).addClass("highcharts-" + this.coll.toLowerCase() + "-title").css(v.style).add(e.axisGroup), e.axisTitle.isNew = !0; if (t) l = e.axisTitle.getBBox()[o ? "height" : "width"], p = d(v.margin, o ? 5 : 10), h = v.offset; e.axisTitle[t ? "show" : "hide"]() } e.offset = w * d(r.offset, y[u]); e.axisTitleMargin = d(h, g + p + (g && w * r.labels[o ? "y" : "x"] - L)); y[u] = J(y[u], e.axisTitleMargin + l + w * e.offset); b[a] = J(b[a], V(r.lineWidth / 2) * 2) }, getLinePath: function (e) { var t = this.chart, n = this.opposite, r = this.offset, i = this.horiz, s = this.left + (n ? this.width : 0) + r, r = t.chartHeight - this.bottom - (n ? this.height : 0) + r; n && (e *= -1); return t.renderer.crispLine(["M", i ? this.left : s, i ? r : this.top, "L", i ? t.chartWidth - this.right : s, i ? r : t.chartHeight - this.bottom], e) }, getTitlePosition: function () { var e = this.horiz, t = this.left, n = this.top, i = this.len, s = this.options.title, o = e ? t : n, u = this.opposite, a = this.offset, f = r(s.style.fontSize || 12), i = { low: o + (e ? 0 : i), middle: o + i / 2, high: o + (e ? i : 0) }[s.align], t = (e ? n + this.height : t) + (e ? 1 : -1) * (u ? -1 : 1) * this.axisTitleMargin + (this.side === 2 ? f : 0); return { x: e ? i : t + (u ? this.width : 0) + a + (s.x || 0), y: e ? t - (u ? this.height : 0) + a : i + (s.y || 0) } }, render: function () { var e = this, t = e.horiz, n = e.reversed, r = e.chart, i = r.renderer, s = e.options, o = e.isLog, u = e.isLinked, a = e.tickPositions, l, h = e.axisTitle, p = e.ticks, d = e.minorTicks, v = e.alternateBands, m = s.stackLabels, g = s.alternateGridColor, y = e.tickmarkOffset, b = s.lineWidth, w = r.hasRendered && c(e.oldMin) && !isNaN(e.oldMin), E = e.hasData, S = e.showAxis, x, T = s.labels.overflow, N = e.justifyLabels = t && T !== !1, C; e.labelEdge.length = 0; e.justifyToPlot = T === "justify"; Kt([p, d, v], function (e) { for (var t in e) e[t].isActive = !1 }); if (E || u) if (e.minorTickInterval && !e.categories && Kt(e.getMinorTickPositions(), function (t) { d[t] || (d[t] = new H(e, t, "minor")); w && d[t].isNew && d[t].render(null, !0); d[t].render(null, !1, 1) }), a.length && (l = a.slice(), (t && n || !t && !n) && l.reverse(), N && (l = l.slice(1).concat([l[0]])), Kt(l, function (t, n) { N && (n = n === l.length - 1 ? 0 : n + 1); if (!u || t >= e.min && t <= e.max) p[t] || (p[t] = new H(e, t)), w && p[t].isNew && p[t].render(n, !0, .1), p[t].render(n, !1, 1) }), y && e.min === 0 && (p[-1] || (p[-1] = new H(e, -1, null, !0)), p[-1].render(-1))), g && Kt(a, function (t, n) { if (n % 2 === 0 && t < e.max) v[t] || (v[t] = new zt.PlotLineOrBand(e)), x = t + y, C = a[n + 1] !== R ? a[n + 1] + y : e.max, v[t].options = { from: o ? f(x) : x, to: o ? f(C) : C, color: g }, v[t].render(), v[t].isActive = !0 }), !e._addedPlotLB) Kt((s.plotLines || []).concat(s.plotBands || []), function (t) { e.addPlotBandOrLine(t) }), e._addedPlotLB = !0; Kt([p, d, v], function (e) { var t, n, i = [], s = bt ? bt.duration || 500 : 0, o = function () { for (n = i.length; n--;) e[i[n]] && !e[i[n]].isActive && (e[i[n]].destroy(), delete e[i[n]]) }; for (t in e) if (!e[t].isActive) e[t].render(t, !1, 0), e[t].isActive = !1, i.push(t); e === v || !r.hasRendered || !s ? o() : s && setTimeout(o, s) }); if (b) t = e.getLinePath(b), e.axisLine ? e.axisLine.animate({ d: t }) : e.axisLine = i.path(t).attr({ stroke: s.lineColor, "stroke-width": b, zIndex: 7 }).add(e.axisGroup), e.axisLine[S ? "show" : "hide"](); if (h && S) h[h.isNew ? "attr" : "animate"](e.getTitlePosition()), h.isNew = !1; m && m.enabled && e.renderStackTotals(); e.isDirty = !1 }, redraw: function () { var e = this.chart.pointer; e && e.reset(!0); this.render(); Kt(this.plotLinesAndBands, function (e) { e.render() }); Kt(this.series, function (e) { e.isDirty = !0 }) }, destroy: function (e) { var t = this, n = t.stacks, r, i = t.plotLinesAndBands; e || en(t); for (r in n) L(n[r]), n[r] = null; Kt([t.ticks, t.minorTicks, t.alternateBands], function (e) { L(e) }); for (e = i.length; e--;) i[e].destroy(); Kt("stackTotalGroup,axisLine,axisTitle,axisGroup,cross,gridGroup,labelGroup".split(","), function (e) { t[e] && (t[e] = t[e].destroy()) }); this.cross && this.cross.destroy() }, drawCrosshair: function (e, t) { if (this.crosshair) if ((c(t) || !d(this.crosshair.snap, !0)) === !1) this.hideCrosshair(); else { var n, r = this.crosshair, i = r.animation; d(r.snap, !0) ? c(t) && (n = this.chart.inverted != this.horiz ? t.plotX : this.len - t.plotY) : n = this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos; n = this.isRadial ? this.getPlotLinePath(this.isXAxis ? t.x : d(t.stackY, t.y)) : this.getPlotLinePath(null, null, null, null, n); if (n === null) this.hideCrosshair(); else if (this.cross) this.cross.attr({ visibility: "visible" })[i ? "animate" : "attr"]({ d: n }, i); else { i = { "stroke-width": r.width || 1, stroke: r.color || "#C0C0C0", zIndex: r.zIndex || 2 }; if (r.dashStyle) i.dashstyle = r.dashStyle; this.cross = this.chart.renderer.path(n).attr(i).add() } } }, hideCrosshair: function () { this.cross && this.cross.hide() } }; e(B.prototype, { getPlotBandPath: function (e, t) { var n = this.getPlotLinePath(t), r = this.getPlotLinePath(e); r && n ? r.push(n[4], n[5], n[1], n[2]) : r = null; return r }, addPlotBand: function (e) { this.addPlotBandOrLine(e, "plotBands") }, addPlotLine: function (e) { this.addPlotBandOrLine(e, "plotLines") }, addPlotBandOrLine: function (e, t) { var n = (new zt.PlotLineOrBand(this, e)).render(), r = this.userOptions; n && (t && (r[t] = r[t] || [], r[t].push(e)), this.plotLinesAndBands.push(n)); return n }, removePlotBandOrLine: function (e) { for (var t = this.plotLinesAndBands, n = this.options, r = this.userOptions, i = t.length; i--;) t[i].id === e && t[i].destroy(); Kt([n.plotLines || [], r.plotLines || [], n.plotBands || [], r.plotBands || []], function (t) { for (i = t.length; i--;) t[i].id === e && l(t, t[i]) }) } }); B.prototype.getTimeTicks = function (t, n, r, i) { var s = [], o = {}, u = gt.global.useUTC, a, f = new Date(n - Ot), l = t.unitRange, h = t.count; if (c(n)) { l >= Et.second && (f.setMilliseconds(0), f.setSeconds(l >= Et.minute ? 0 : h * V(f.getSeconds() / h))); if (l >= Et.minute) f[jt](l >= Et.hour ? 0 : h * V(f[Mt]() / h)); if (l >= Et.hour) f[Ft](l >= Et.day ? 0 : h * V(f[_t]() / h)); if (l >= Et.day) f[It](l >= Et.month ? 1 : h * V(f[Pt]() / h)); l >= Et.month && (f[qt](l >= Et.year ? 0 : h * V(f[Ht]() / h)), a = f[Bt]()); l >= Et.year && (a -= a % h, f[Rt](a)); if (l === Et.week) f[It](f[Pt]() - f[Dt]() + d(i, 1)); n = 1; Ot && (f = new Date(f.getTime() + Ot)); a = f[Bt](); for (var i = f.getTime(), p = f[Ht](), v = f[Pt](), m = u ? Ot : (864e5 + f.getTimezoneOffset() * 6e4) % 864e5; i < r;) s.push(i), l === Et.year ? i = At(a + n * h, 0) : l === Et.month ? i = At(a, p + n * h) : !u && (l === Et.day || l === Et.week) ? i = At(a, p, v + n * h * (l === Et.day ? 1 : 7)) : i += l * h, n++; s.push(i); Kt(Qt(s, function (e) { return l <= Et.hour && e % Et.day === m }), function (e) { o[e] = "day" }) } s.info = e(t, { higherRanks: o, totalRange: l * h }); return s }; B.prototype.normalizeTimeTickInterval = function (e, t) { var n = t || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]], r = n[n.length - 1], i = Et[r[0]], s = r[1], o; for (o = 0; o < n.length; o++) if (r = n[o], i = Et[r[0]], s = r[1], n[o + 1] && e <= (i * s[s.length - 1] + Et[n[o + 1][0]]) / 2) break; i === Et.year && e < 5 * i && (s = [1, 2, 5]); n = x(e / i, s, r[0] === "year" ? J(S(e / i), 1) : 1); return { unitRange: i, count: n, unitName: r[0] } }; B.prototype.getLogTickPositions = function (e, t, n, r) { var i = this.options, s = this.len, o = []; if (!r) this._minorAutoInterval = null; if (e >= .5) e = X(e), o = this.getLinearTickPositions(e, t, n); else if (e >= .08) for (var s = V(t), u, l, c, h, p, i = e > .3 ? [1, 2, 4] : e > .15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; s < n + 1 && !p; s++) { l = i.length; for (u = 0; u < l && !p; u++) c = a(f(s) * i[u]), c > t && (!r || h <= n) && o.push(h), h > n && (p = !0), h = c } else if (t = f(t), n = f(n), e = i[r ? "minorTickInterval" : "tickInterval"], e = d(e === "auto" ? null : e, this._minorAutoInterval, (n - t) * (i.tickPixelInterval / (r ? 5 : 1)) / ((r ? s / this.tickPositions.length : s) || 1)), e = x(e, null, S(e)), o = Yt(this.getLinearTickPositions(e, t, n), a), !r) this._minorAutoInterval = e / 5; if (!r) this.tickInterval = e; return o }; var vn = zt.Tooltip = function () { this.init.apply(this, arguments) }; vn.prototype = { init: function (e, t) { var n = t.borderWidth, i = t.style, s = r(i.padding); this.chart = e; this.options = t; this.crosshairs = []; this.now = { x: 0, y: 0 }; this.isHidden = !0; this.label = e.renderer.label("", 0, 0, t.shape || "callout", null, null, t.useHTML, null, "tooltip").attr({ padding: s, fill: t.backgroundColor, "stroke-width": n, r: t.borderRadius, zIndex: 8 }).css(i).css({ padding: 0 }).add().attr({ y: -9999 }); ct || this.label.shadow(t.shadow); this.shared = t.shared }, destroy: function () { if (this.label) this.label = this.label.destroy(); clearTimeout(this.hideTimer); clearTimeout(this.tooltipTimeout) }, move: function (t, n, r, i) { var s = this, o = s.now, u = s.options.animation !== !1 && !s.isHidden, a = s.followPointer || s.len > 1; e(o, { x: u ? (2 * o.x + t) / 3 : t, y: u ? (o.y + n) / 2 : n, anchorX: a ? R : u ? (2 * o.anchorX + r) / 3 : r, anchorY: a ? R : u ? (o.anchorY + i) / 2 : i }); s.label.attr(o); if (u && (Q(t - o.x) > 1 || Q(n - o.y) > 1)) clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () { s && s.move(t, n, r, i) }, 32) }, hide: function () { var e = this, t; clearTimeout(this.hideTimer); if (!this.isHidden) t = this.chart.hoverPoints, this.hideTimer = setTimeout(function () { e.label.fadeOut(); e.isHidden = !0 }, d(this.options.hideDelay, 500)), t && Kt(t, function (e) { e.setState() }), this.chart.hoverPoints = null }, getAnchor: function (e, t) { var n, r = this.chart, i = r.inverted, s = r.plotTop, o = 0, u = 0, a, e = p(e); n = e[0].tooltipPos; this.followPointer && t && (t.chartX === R && (t = r.pointer.normalize(t)), n = [t.chartX - r.plotLeft, t.chartY - s]); n || (Kt(e, function (e) { a = e.series.yAxis; o += e.plotX; u += (e.plotLow ? (e.plotLow + e.plotHigh) / 2 : e.plotY) + (!i && a ? a.top - s : 0) }), o /= e.length, u /= e.length, n = [i ? r.plotWidth - u : o, this.shared && !i && e.length > 1 && t ? t.chartY - s : i ? r.plotHeight - o : u]); return Yt(n, X) }, getPosition: function (e, t, n) { var r = this.chart, i = this.distance, s = {}, o, u = ["y", r.chartHeight, t, n.plotY + r.plotTop], a = ["x", r.chartWidth, e, n.plotX + r.plotLeft], f = n.ttBelow || r.inverted && !n.negative || !r.inverted && n.negative, l = function (e, t, n, r) { var o = n < r - i, t = r + i + n < t, n = r - i - n; r += i; if (f && t) s[e] = r; else if (!f && o) s[e] = n; else if (o) s[e] = n; else if (t) s[e] = r; else return !1 }, c = function (e, t, n, r) { if (r < i || r > t - i) return !1; else s[e] = r < n / 2 ? 1 : r > t - n / 2 ? t - n - 2 : r - n / 2 }, h = function (e) { var t = u; u = a; a = t; o = e }, p = function () { l.apply(0, u) !== !1 ? c.apply(0, a) === !1 && !o && (h(!0), p()) : o ? s.x = s.y = 0 : (h(!0), p()) }; (r.inverted || this.len > 1) && h(); p(); return s }, defaultFormatter: function (e) { var t = this.points || p(this), n = t[0].series, r; r = [e.tooltipHeaderFormatter(t[0])]; Kt(t, function (e) { n = e.series; r.push(n.tooltipFormatter && n.tooltipFormatter(e) || e.point.tooltipFormatter(n.tooltipOptions.pointFormat)) }); r.push(e.options.footerFormat || ""); return r.join("") }, refresh: function (e, t) { var n = this.chart, r = this.label, i = this.options, s, o, u = {}, a, f = []; a = i.formatter || this.defaultFormatter; var u = n.hoverPoints, l, c = this.shared; clearTimeout(this.hideTimer); this.followPointer = p(e)[0].series.tooltipOptions.followPointer; o = this.getAnchor(e, t); s = o[0]; o = o[1]; c && (!e.series || !e.series.noSharedTooltip) ? (n.hoverPoints = e, u && Kt(u, function (e) { e.setState() }), Kt(e, function (e) { e.setState("hover"); f.push(e.getLabelConfig()) }), u = { x: e[0].category, y: e[0].y }, u.points = f, this.len = f.length, e = e[0]) : u = e.getLabelConfig(); a = a.call(u, this); u = e.series; this.distance = d(u.tooltipOptions.distance, 16); a === !1 ? this.hide() : (this.isHidden && (sn(r), r.attr("opacity", 1).show()), r.attr({ text: a }), l = i.borderColor || e.color || u.color || "#606060", r.attr({ stroke: l }), this.updatePosition({ plotX: s, plotY: o, negative: e.negative, ttBelow: e.ttBelow }), this.isHidden = !1); tn(n, "tooltipRefresh", { text: a, x: s + n.plotLeft, y: o + n.plotTop, borderColor: l }) }, updatePosition: function (e) { var t = this.chart, n = this.label, n = (this.options.positioner || this.getPosition).call(this, n.width, n.height, e); this.move(X(n.x), X(n.y), e.plotX + t.plotLeft, e.plotY + t.plotTop) }, tooltipHeaderFormatter: function (e) { var t = e.series, n = t.tooltipOptions, r = n.dateTimeLabelFormats, i = n.xDateFormat, s = t.xAxis, o = s && s.options.type === "datetime" && u(e.key), n = n.headerFormat, s = s && s.closestPointRange, a; if (o && !i) { if (s) for (a in Et) { if (Et[a] >= s || Et[a] <= Et.day && e.key % Et[a] > 0) { i = r[a]; break } } else i = r.day; i = i || r.year } o && i && (n = n.replace("{point.key}", "{point.key:" + i + "}")); return E(n, { point: e, series: t }) } }; var mn; pt = U.documentElement.ontouchstart !== R; var gn = zt.Pointer = function (e, t) { this.init(e, t) }; gn.prototype = { init: function (e, t) { var n = t.chart, r = n.events, i = ct ? "" : n.zoomType, n = e.inverted, s; this.options = t; this.chart = e; this.zoomX = s = /x/.test(i); this.zoomY = i = /y/.test(i); this.zoomHor = s && !n || i && n; this.zoomVert = i && !n || s && n; this.hasZoom = s || i; this.runChartClick = r && !!r.click; this.pinchDown = []; this.lastValidTouch = {}; if (zt.Tooltip && t.tooltip.enabled) e.tooltip = new vn(e, t.tooltip), this.followTouchMove = t.tooltip.followTouchMove; this.setDOMEvents() }, normalize: function (t, n) { var r, i, t = t || window.event, t = nn(t); if (!t.target) t.target = t.srcElement; i = t.touches ? t.touches.length ? t.touches.item(0) : t.changedTouches[0] : t; if (!n) this.chartPosition = n = Gt(this.chart.container); i.pageX === R ? (r = J(t.x, t.clientX - n.left), i = t.y) : (r = i.pageX - n.left, i = i.pageY - n.top); return e(t, { chartX: X(r), chartY: X(i) }) }, getCoordinates: function (e) { var t = { xAxis: [], yAxis: [] }; Kt(this.chart.axes, function (n) { t[n.isXAxis ? "xAxis" : "yAxis"].push({ axis: n, value: n.toValue(e[n.horiz ? "chartX" : "chartY"]) }) }); return t }, getIndex: function (e) { var t = this.chart; return t.inverted ? t.plotHeight + t.plotTop - e.chartY : e.chartX - t.plotLeft }, runPointActions: function (e) { var t = this.chart, n = t.series, r = t.tooltip, i, s, o = t.hoverPoint, u = t.hoverSeries, a, f, l = t.chartWidth, c = this.getIndex(e); if (r && this.options.tooltip.shared && (!u || !u.noSharedTooltip)) { s = []; a = n.length; for (f = 0; f < a; f++) if (n[f].visible && n[f].options.enableMouseTracking !== !1 && !n[f].noSharedTooltip && n[f].singularTooltips !== !0 && n[f].tooltipPoints.length && (i = n[f].tooltipPoints[c]) && i.series) i._dist = Q(c - i.clientX), l = K(l, i._dist), s.push(i); for (a = s.length; a--;) s[a]._dist > l && s.splice(a, 1); if (s.length && s[0].clientX !== this.hoverX) r.refresh(s, e), this.hoverX = s[0].clientX } n = u && u.tooltipOptions.followPointer; if (u && u.tracker && !n) { if ((i = u.tooltipPoints[c]) && i !== o) i.onMouseOver(e) } else r && n && !r.isHidden && (u = r.getAnchor([{}], e), r.updatePosition({ plotX: u[0], plotY: u[1] })); if (r && !this._onDocumentMouseMove) this._onDocumentMouseMove = function (e) { if (xt[mn]) xt[mn].pointer.onDocumentMouseMove(e) }, Zt(U, "mousemove", this._onDocumentMouseMove); Kt(t.axes, function (t) { t.drawCrosshair(e, d(i, o)) }) }, reset: function (e) { var t = this.chart, n = t.hoverSeries, r = t.hoverPoint, i = t.tooltip, s = i && i.shared ? t.hoverPoints : r; (e = e && i && s) && p(s)[0].plotX === R && (e = !1); if (e) i.refresh(s), r && r.setState(r.state, !0); else { if (r) r.onMouseOut(); if (n) n.onMouseOut(); i && i.hide(); if (this._onDocumentMouseMove) en(U, "mousemove", this._onDocumentMouseMove), this._onDocumentMouseMove = null; Kt(t.axes, function (e) { e.hideCrosshair() }); this.hoverX = null } }, scaleGroups: function (e, t) { var n = this.chart, r; Kt(n.series, function (i) { r = e || i.getPlotBox(); i.xAxis && i.xAxis.zoomEnabled && (i.group.attr(r), i.markerGroup && (i.markerGroup.attr(r), i.markerGroup.clip(t ? n.clipRect : null)), i.dataLabelsGroup && i.dataLabelsGroup.attr(r)) }); n.clipRect.attr(t || n.clipBox) }, dragStart: function (e) { var t = this.chart; t.mouseIsDown = e.type; t.cancelClick = !1; t.mouseDownX = this.mouseDownX = e.chartX; t.mouseDownY = this.mouseDownY = e.chartY }, drag: function (e) { var t = this.chart, n = t.options.chart, r = e.chartX, i = e.chartY, s = this.zoomHor, o = this.zoomVert, u = t.plotLeft, a = t.plotTop, f = t.plotWidth, l = t.plotHeight, c, h = this.mouseDownX, p = this.mouseDownY; r < u ? r = u : r > u + f && (r = u + f); i < a ? i = a : i > a + l && (i = a + l); this.hasDragged = Math.sqrt(Math.pow(h - r, 2) + Math.pow(p - i, 2)); if (this.hasDragged > 10) { c = t.isInsidePlot(h - u, p - a); if (t.hasCartesianSeries && (this.zoomX || this.zoomY) && c && !this.selectionMarker) this.selectionMarker = t.renderer.rect(u, a, s ? 1 : f, o ? 1 : l, 0).attr({ fill: n.selectionMarkerFill || "rgba(69,114,167,0.25)", zIndex: 7 }).add(); this.selectionMarker && s && (r -= h, this.selectionMarker.attr({ width: Q(r), x: (r > 0 ? 0 : r) + h })); this.selectionMarker && o && (r = i - p, this.selectionMarker.attr({ height: Q(r), y: (r > 0 ? 0 : r) + p })); c && !this.selectionMarker && n.panning && t.pan(e, n.panning) } }, drop: function (t) { var n = this.chart, r = this.hasPinched; if (this.selectionMarker) { var i = { xAxis: [], yAxis: [], originalEvent: t.originalEvent || t }, t = this.selectionMarker, s = t.attr ? t.attr("x") : t.x, o = t.attr ? t.attr("y") : t.y, u = t.attr ? t.attr("width") : t.width, a = t.attr ? t.attr("height") : t.height, f; if (this.hasDragged || r) Kt(n.axes, function (e) { if (e.zoomEnabled) { var t = e.horiz, n = e.toValue(t ? s : o), t = e.toValue(t ? s + u : o + a); !isNaN(n) && !isNaN(t) && (i[e.coll].push({ axis: e, min: K(n, t), max: J(n, t) }), f = !0) } }), f && tn(n, "selection", i, function (t) { n.zoom(e(t, r ? { animation: !1 } : null)) }); this.selectionMarker = this.selectionMarker.destroy(); r && this.scaleGroups() } if (n) v(n.container, { cursor: n._cursor }), n.cancelClick = this.hasDragged > 10, n.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = [] }, onContainerMouseDown: function (e) { e = this.normalize(e); e.preventDefault && e.preventDefault(); this.dragStart(e) }, onDocumentMouseUp: function (e) { xt[mn] && xt[mn].pointer.drop(e) }, onDocumentMouseMove: function (e) { var t = this.chart, n = this.chartPosition, r = t.hoverSeries, e = this.normalize(e, n); n && r && !this.inClass(e.target, "highcharts-tracker") && !t.isInsidePlot(e.chartX - t.plotLeft, e.chartY - t.plotTop) && this.reset() }, onContainerMouseLeave: function () { var e = xt[mn]; if (e) e.pointer.reset(), e.pointer.chartPosition = null }, onContainerMouseMove: function (e) { var t = this.chart; mn = t.index; e = this.normalize(e); t.mouseIsDown === "mousedown" && this.drag(e); (this.inClass(e.target, "highcharts-tracker") || t.isInsidePlot(e.chartX - t.plotLeft, e.chartY - t.plotTop)) && !t.openMenu && this.runPointActions(e) }, inClass: function (e, t) { for (var n; e;) { if (n = h(e, "class")) if (n.indexOf(t) !== -1) return !0; else if (n.indexOf("highcharts-container") !== -1) return !1; e = e.parentNode } }, onTrackerMouseOut: function (e) { var t = this.chart.hoverSeries, n = (e = e.relatedTarget || e.toElement) && e.point && e.point.series; if (t && !t.options.stickyTracking && !this.inClass(e, "highcharts-tooltip") && n !== t) t.onMouseOut() }, onContainerClick: function (t) { var n = this.chart, r = n.hoverPoint, i = n.plotLeft, s = n.plotTop, t = this.normalize(t); t.cancelBubble = !0; n.cancelClick || (r && this.inClass(t.target, "highcharts-tracker") ? (tn(r.series, "click", e(t, { point: r })), n.hoverPoint && r.firePointEvent("click", t)) : (e(t, this.getCoordinates(t)), n.isInsidePlot(t.chartX - i, t.chartY - s) && tn(n, "click", t))) }, setDOMEvents: function () { var e = this, t = e.chart.container; t.onmousedown = function (t) { e.onContainerMouseDown(t) }; t.onmousemove = function (t) { e.onContainerMouseMove(t) }; t.onclick = function (t) { e.onContainerClick(t) }; Zt(t, "mouseleave", e.onContainerMouseLeave); Tt === 1 && Zt(U, "mouseup", e.onDocumentMouseUp); if (pt) t.ontouchstart = function (t) { e.onContainerTouchStart(t) }, t.ontouchmove = function (t) { e.onContainerTouchMove(t) }, Tt === 1 && Zt(U, "touchend", e.onDocumentTouchEnd) }, destroy: function () { var e; en(this.chart.container, "mouseleave", this.onContainerMouseLeave); Tt || (en(U, "mouseup", this.onDocumentMouseUp), en(U, "touchend", this.onDocumentTouchEnd)); clearInterval(this.tooltipTimeout); for (e in this) this[e] = null } }; e(zt.Pointer.prototype, { pinchTranslate: function (e, t, n, r, i, s) { (this.zoomHor || this.pinchHor) && this.pinchTranslateDirection(!0, e, t, n, r, i, s); (this.zoomVert || this.pinchVert) && this.pinchTranslateDirection(!1, e, t, n, r, i, s) }, pinchTranslateDirection: function (e, t, n, r, i, s, o, u) { var a = this.chart, f = e ? "x" : "y", l = e ? "X" : "Y", c = "chart" + l, h = e ? "width" : "height", p = a["plot" + (e ? "Left" : "Top")], d, v, m = u || 1, g = a.inverted, y = a.bounds[e ? "h" : "v"], b = t.length === 1, w = t[0][c], E = n[0][c], S = !b && t[1][c], x = !b && n[1][c], T, n = function () { !b && Q(w - S) > 20 && (m = u || Q(E - x) / Q(w - S)); v = (p - E) / m + w; d = a["plot" + (e ? "Width" : "Height")] / m }; n(); t = v; t < y.min ? (t = y.min, T = !0) : t + d > y.max && (t = y.max - d, T = !0); T ? (E -= .8 * (E - o[f][0]), b || (x -= .8 * (x - o[f][1])), n()) : o[f] = [E, x]; g || (s[f] = v - p, s[h] = d); s = g ? 1 / m : m; i[h] = d; i[f] = t; r[g ? e ? "scaleY" : "scaleX" : "scale" + l] = m; r["translate" + l] = s * p + (E - s * w) }, pinch: function (t) { var n = this, r = n.chart, i = n.pinchDown, s = n.followTouchMove, o = t.touches, u = o.length, a = n.lastValidTouch, f = n.hasZoom, l = n.selectionMarker, c = {}, h = u === 1 && (n.inClass(t.target, "highcharts-tracker") && r.runTrackerClick || r.runChartClick), p = {}; (f || s) && !h && t.preventDefault(); Yt(o, function (e) { return n.normalize(e) }); if (t.type === "touchstart") Kt(o, function (e, t) { i[t] = { chartX: e.chartX, chartY: e.chartY } }), a.x = [i[0].chartX, i[1] && i[1].chartX], a.y = [i[0].chartY, i[1] && i[1].chartY], Kt(r.axes, function (e) { if (e.zoomEnabled) { var t = r.bounds[e.horiz ? "h" : "v"], n = e.minPixelPadding, i = e.toPixels(e.dataMin), s = e.toPixels(e.dataMax), o = K(i, s), i = J(i, s); t.min = K(e.pos, o - n); t.max = J(e.pos + e.len, i + n) } }); else if (i.length) { if (!l) n.selectionMarker = l = e({ destroy: St }, r.plotBox); n.pinchTranslate(i, o, c, l, p, a); n.hasPinched = f; n.scaleGroups(c, p); !f && s && u === 1 && this.runPointActions(n.normalize(t)) } }, onContainerTouchStart: function (e) { var t = this.chart; mn = t.index; e.touches.length === 1 ? (e = this.normalize(e), t.isInsidePlot(e.chartX - t.plotLeft, e.chartY - t.plotTop) ? (this.runPointActions(e), this.pinch(e)) : this.reset()) : e.touches.length === 2 && this.pinch(e) }, onContainerTouchMove: function (e) { (e.touches.length === 1 || e.touches.length === 2) && this.pinch(e) }, onDocumentTouchEnd: function (e) { xt[mn] && xt[mn].pointer.drop(e) } }); if (z.PointerEvent || z.MSPointerEvent) { var yn = {}, bn = !!z.PointerEvent, wn = function () { var e, t = []; t.item = function (e) { return this[e] }; for (e in yn) yn.hasOwnProperty(e) && t.push({ pageX: yn[e].pageX, pageY: yn[e].pageY, target: yn[e].target }); return t }, En = function (e, t, n, r) { e = e.originalEvent || e; if ((e.pointerType === "touch" || e.pointerType === e.MSPOINTER_TYPE_TOUCH) && xt[mn]) r(e), r = xt[mn].pointer, r[t]({ type: n, target: e.currentTarget, preventDefault: St, touches: wn() }) }; e(gn.prototype, { onContainerPointerDown: function (e) { En(e, "onContainerTouchStart", "touchstart", function (e) { yn[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget } }) }, onContainerPointerMove: function (e) { En(e, "onContainerTouchMove", "touchmove", function (e) { yn[e.pointerId] = { pageX: e.pageX, pageY: e.pageY }; if (!yn[e.pointerId].target) yn[e.pointerId].target = e.currentTarget }) }, onDocumentPointerUp: function (e) { En(e, "onContainerTouchEnd", "touchend", function (e) { delete yn[e.pointerId] }) }, batchMSEvents: function (e) { e(this.chart.container, bn ? "pointerdown" : "MSPointerDown", this.onContainerPointerDown); e(this.chart.container, bn ? "pointermove" : "MSPointerMove", this.onContainerPointerMove); e(U, bn ? "pointerup" : "MSPointerUp", this.onDocumentPointerUp) } }); w(gn.prototype, "init", function (e, t, n) { e.call(this, t, n); (this.hasZoom || this.followTouchMove) && v(t.container, { "-ms-touch-action": Ct, "touch-action": Ct }) }); w(gn.prototype, "setDOMEvents", function (e) { e.apply(this); (this.hasZoom || this.followTouchMove) && this.batchMSEvents(Zt) }); w(gn.prototype, "destroy", function (e) { this.batchMSEvents(en); e.call(this) }) } var Sn = zt.Legend = function (e, t) { this.init(e, t) }; Sn.prototype = { init: function (e, n) { var i = this, s = n.itemStyle, o = d(n.padding, 8), u = n.itemMarginTop || 0; this.options = n; if (n.enabled) i.baseline = r(s.fontSize) + 3 + u, i.itemStyle = s, i.itemHiddenStyle = t(s, n.itemHiddenStyle), i.itemMarginTop = u, i.padding = o, i.initialItemX = o, i.initialItemY = o - 5, i.maxItemWidth = 0, i.chart = e, i.itemHeight = 0, i.lastLineHeight = 0, i.symbolWidth = d(n.symbolWidth, 16), i.pages = [], i.render(), Zt(i.chart, "endResize", function () { i.positionCheckboxes() }) }, colorizeItem: function (e, t) { var n = this.options, r = e.legendItem, i = e.legendLine, s = e.legendSymbol, o = this.itemHiddenStyle.color, n = t ? n.itemStyle.color : o, u = t ? e.legendColor || e.color || "#CCC" : o, o = e.options && e.options.marker, a = { fill: u }, f; r && r.css({ fill: n, color: n }); i && i.attr({ stroke: u }); if (s) { if (o && s.isMarker) for (f in a.stroke = u, o = e.convertAttribs(o), o) r = o[f], r !== R && (a[f] = r); s.attr(a) } }, positionItem: function (e) { var t = this.options, n = t.symbolPadding, t = !t.rtl, r = e._legendItemPos, i = r[0], r = r[1], s = e.checkbox; e.legendGroup && e.legendGroup.translate(t ? i : this.legendWidth - i - 2 * n - 4, r); if (s) s.x = i, s.y = r }, destroyItem: function (e) { var t = e.checkbox; Kt(["legendItem", "legendLine", "legendSymbol", "legendGroup"], function (t) { e[t] && (e[t] = e[t].destroy()) }); t && A(e.checkbox) }, destroy: function () { var e = this.group, t = this.box; if (t) this.box = t.destroy(); if (e) this.group = e.destroy() }, positionCheckboxes: function (e) { var t = this.group.alignAttr, n, r = this.clipHeight || this.legendHeight; if (t) n = t.translateY, Kt(this.allItems, function (i) { var s = i.checkbox, o; s && (o = n + s.y + (e || 0) + 3, v(s, { left: t.translateX + i.checkboxOffset + s.x - 20 + "px", top: o + "px", display: o > n - 6 && o < n + r - 6 ? "" : Ct })) }) }, renderTitle: function () { var e = this.padding, t = this.options.title, n = 0; if (t.text) { if (!this.title) this.title = this.chart.renderer.label(t.text, e - 3, e - 4, null, null, null, null, null, "legend-title").attr({ zIndex: 1 }).css(t.style).add(this.group); e = this.title.getBBox(); n = e.height; this.offsetWidth = e.width; this.contentGroup.attr({ translateY: n }) } this.titleHeight = n }, renderItem: function (e) { var n = this.chart, r = n.renderer, i = this.options, s = i.layout === "horizontal", o = this.symbolWidth, u = i.symbolPadding, a = this.itemStyle, f = this.itemHiddenStyle, l = this.padding, c = s ? d(i.itemDistance, 20) : 0, h = !i.rtl, p = i.width, v = i.itemMarginBottom || 0, m = this.itemMarginTop, g = this.initialItemX, y = e.legendItem, b = e.series && e.series.drawLegendSymbol ? e.series : e, w = b.options, w = this.createCheckboxForItem && w && w.showCheckbox, S = i.useHTML; if (!y) e.legendGroup = r.g("legend-item").attr({ zIndex: 1 }).add(this.scrollGroup), b.drawLegendSymbol(this, e), e.legendItem = y = r.text(i.labelFormat ? E(i.labelFormat, e) : i.labelFormatter.call(e), h ? o + u : -u, this.baseline, S).css(t(e.visible ? a : f)).attr({ align: h ? "left" : "right", zIndex: 2 }).add(e.legendGroup), this.setItemEvents && this.setItemEvents(e, y, S, a, f), this.colorizeItem(e, e.visible), w && this.createCheckboxForItem(e); r = y.getBBox(); o = e.checkboxOffset = i.itemWidth || e.legendItemWidth || o + u + r.width + c + (w ? 20 : 0); this.itemHeight = u = X(e.legendItemHeight || r.height); if (s && this.itemX - g + o > (p || n.chartWidth - 2 * l - g - i.x)) this.itemX = g, this.itemY += m + this.lastLineHeight + v, this.lastLineHeight = 0; this.maxItemWidth = J(this.maxItemWidth, o); this.lastItemY = m + this.itemY + v; this.lastLineHeight = J(u, this.lastLineHeight); e._legendItemPos = [this.itemX, this.itemY]; s ? this.itemX += o : (this.itemY += m + u + v, this.lastLineHeight = u); this.offsetWidth = p || J((s ? this.itemX - g - c : o) + l, this.offsetWidth) }, getAllItems: function () { var e = []; Kt(this.chart.series, function (t) { var n = t.options; if (d(n.showInLegend, !c(n.linkedTo) ? R : !1, !0)) e = e.concat(t.legendItems || (n.legendType === "point" ? t.data : t)) }); return e }, render: function () { var t = this, n = t.chart, r = n.renderer, i = t.group, s, o, u, a, f = t.box, l = t.options, c = t.padding, h = l.borderWidth, p = l.backgroundColor; t.itemX = t.initialItemX; t.itemY = t.initialItemY; t.offsetWidth = 0; t.lastItemY = 0; if (!i) t.group = i = r.g("legend").attr({ zIndex: 7 }).add(), t.contentGroup = r.g().attr({ zIndex: 1 }).add(i), t.scrollGroup = r.g().add(t.contentGroup); t.renderTitle(); s = t.getAllItems(); N(s, function (e, t) { return (e.options && e.options.legendIndex || 0) - (t.options && t.options.legendIndex || 0) }); l.reversed && s.reverse(); t.allItems = s; t.display = o = !!s.length; Kt(s, function (e) { t.renderItem(e) }); u = l.width || t.offsetWidth; a = t.lastItemY + t.lastLineHeight + t.titleHeight; a = t.handleOverflow(a); if (h || p) { u += c; a += c; if (f) { if (u > 0 && a > 0) f[f.isNew ? "attr" : "animate"](f.crisp({ width: u, height: a })), f.isNew = !1 } else t.box = f = r.rect(0, 0, u, a, l.borderRadius, h || 0).attr({ stroke: l.borderColor, "stroke-width": h || 0, fill: p || Ct }).add(i).shadow(l.shadow), f.isNew = !0; f[o ? "show" : "hide"]() } t.legendWidth = u; t.legendHeight = a; Kt(s, function (e) { t.positionItem(e) }); o && i.align(e({ width: u, height: a }, l), !0, "spacingBox"); n.isResizing || this.positionCheckboxes() }, handleOverflow: function (e) { var t = this, n = this.chart, r = n.renderer, i = this.options, s = i.y, s = n.spacingBox.height + (i.verticalAlign === "top" ? -s : s) - this.padding, o = i.maxHeight, u, a = this.clipRect, f = i.navigation, l = d(f.animation, !0), c = f.arrowSize || 12, h = this.nav, p = this.pages, v, m = this.allItems; i.layout === "horizontal" && (s /= 2); o && (s = K(s, o)); p.length = 0; if (e > s && !i.useHTML) { this.clipHeight = u = s - 20 - this.titleHeight - this.padding; this.currentPage = d(this.currentPage, 1); this.fullHeight = e; Kt(m, function (e, t) { var n = e._legendItemPos[1], r = X(e.legendItem.getBBox().height), i = p.length; if (!i || n - p[i - 1] > u && (v || n) !== p[i - 1]) p.push(v || n), i++; t === m.length - 1 && n + r - p[i - 1] > u && p.push(n); n !== v && (v = n) }); if (!a) a = t.clipRect = r.clipRect(0, this.padding, 9999, 0), t.contentGroup.clip(a); a.attr({ height: u }); if (!h) this.nav = h = r.g().attr({ zIndex: 1 }).add(this.group), this.up = r.symbol("triangle", 0, 0, c, c).on("click", function () { t.scroll(-1, l) }).add(h), this.pager = r.text("", 15, 10).css(f.style).add(h), this.down = r.symbol("triangle-down", 0, 0, c, c).on("click", function () { t.scroll(1, l) }).add(h); t.scroll(0); e = s } else if (h) a.attr({ height: n.chartHeight }), h.hide(), this.scrollGroup.attr({ translateY: 1 }), this.clipHeight = 0; return e }, scroll: function (e, t) { var n = this.pages, r = n.length, i = this.currentPage + e, s = this.clipHeight, o = this.options.navigation, u = o.activeColor, o = o.inactiveColor, a = this.pager, f = this.padding; i > r && (i = r); if (i > 0) t !== R && _(t, this.chart), this.nav.attr({ translateX: f, translateY: s + this.padding + 7 + this.titleHeight, visibility: "visible" }), this.up.attr({ fill: i === 1 ? o : u }).css({ cursor: i === 1 ? "default" : "pointer" }), a.attr({ text: i + "/" + r }), this.down.attr({ x: 18 + this.pager.getBBox().width, fill: i === r ? o : u }).css({ cursor: i === r ? "default" : "pointer" }), n = -n[i - 1] + this.initialItemY, this.scrollGroup.animate({ translateY: n }), this.currentPage = i, this.positionCheckboxes(n) } }; Xt = zt.LegendSymbolMixin = { drawRectangle: function (e, t) { var n = e.options.symbolHeight || 12; t.legendSymbol = this.chart.renderer.rect(0, e.baseline - 5 - n / 2, e.symbolWidth, n, e.options.symbolRadius || 0).attr({ zIndex: 3 }).add(t.legendGroup) }, drawLineMarker: function (e) { var t = this.options, n = t.marker, r; r = e.symbolWidth; var i = this.chart.renderer, s = this.legendGroup, e = e.baseline - X(i.fontMetrics(e.options.itemStyle.fontSize).b * .3), o; if (t.lineWidth) { o = { "stroke-width": t.lineWidth }; if (t.dashStyle) o.dashstyle = t.dashStyle; this.legendLine = i.path(["M", 0, e, "L", r, e]).attr(o).add(s) } if (n && n.enabled !== !1) t = n.radius, this.legendSymbol = r = i.symbol(this.symbol, r / 2 - t, e - t, 2 * t, 2 * t).add(s), r.isMarker = !0 } }; (/Trident\/7\.0/.test(tt) || ot) && w(Sn.prototype, "positionItem", function (e, t) { var n = this, r = function () { t._legendItemPos && e.call(n, t) }; r(); setTimeout(r) }); j.prototype = { init: function (e, n) { var r, i = e.series; e.series = null; r = t(gt, e); r.series = e.series = i; this.userOptions = e; i = r.chart; this.margin = this.splashArray("margin", i); this.spacing = this.splashArray("spacing", i); var s = i.events; this.bounds = { h: {}, v: {} }; this.callback = n; this.isResizing = 0; this.options = r; this.axes = []; this.series = []; this.hasCartesianSeries = i.showAxes; var o = this, u; o.index = xt.length; xt.push(o); Tt++; i.reflow !== !1 && Zt(o, "load", function () { o.initReflow() }); if (s) for (u in s) Zt(o, u, s[u]); o.xAxis = []; o.yAxis = []; o.animation = ct ? !1 : d(i.animation, !0); o.pointCount = 0; o.counters = new T; o.firstRender() }, initSeries: function (e) { var t = this.options.chart; (t = Ut[e.type || t.type || t.defaultSeriesType]) || O(17, !0); t = new t; t.init(this, e); return t }, isInsidePlot: function (e, t, n) { var r = n ? t : e, e = n ? e : t; return r >= 0 && r <= this.plotWidth && e >= 0 && e <= this.plotHeight }, adjustTickAmounts: function () { this.options.chart.alignTicks !== !1 && Kt(this.axes, function (e) { e.adjustTickAmount() }); this.maxTicks = null }, redraw: function (t) { var n = this.axes, r = this.series, i = this.pointer, s = this.legend, o = this.isDirtyLegend, u, a, f = this.isDirtyBox, l = r.length, c = l, h = this.renderer, p = h.isHidden(), d = []; _(t, this); p && this.cloneRenderTo(); for (this.layOutTitles() ; c--;) if (t = r[c], t.options.stacking && (u = !0, t.isDirty)) { a = !0; break } if (a) for (c = l; c--;) if (t = r[c], t.options.stacking) t.isDirty = !0; Kt(r, function (e) { e.isDirty && e.options.legendType === "point" && (o = !0) }); if (o && s.options.enabled) s.render(), this.isDirtyLegend = !1; u && this.getStacks(); if (this.hasCartesianSeries) { if (!this.isResizing) this.maxTicks = null, Kt(n, function (e) { e.setScale() }); this.adjustTickAmounts(); this.getMargins(); Kt(n, function (e) { e.isDirty && (f = !0) }); Kt(n, function (t) { if (t.isDirtyExtremes) t.isDirtyExtremes = !1, d.push(function () { tn(t, "afterSetExtremes", e(t.eventArgs, t.getExtremes())); delete t.eventArgs }); (f || u) && t.redraw() }) } f && this.drawChartBox(); Kt(r, function (e) { e.isDirty && e.visible && (!e.isCartesian || e.xAxis) && e.redraw() }); i && i.reset(!0); h.draw(); tn(this, "redraw"); p && this.cloneRenderTo(!0); Kt(d, function (e) { e.call() }) }, get: function (e) { var t = this.axes, n = this.series, r, i; for (r = 0; r < t.length; r++) if (t[r].options.id === e) return t[r]; for (r = 0; r < n.length; r++) if (n[r].options.id === e) return n[r]; for (r = 0; r < n.length; r++) { i = n[r].points || []; for (t = 0; t < i.length; t++) if (i[t].id === e) return i[t] } return null }, getAxes: function () { var e = this, t = this.options, n = t.xAxis = p(t.xAxis || {}), t = t.yAxis = p(t.yAxis || {}); Kt(n, function (e, t) { e.index = t; e.isX = !0 }); Kt(t, function (e, t) { e.index = t }); n = n.concat(t); Kt(n, function (t) { new B(e, t) }); e.adjustTickAmounts() }, getSelectedPoints: function () { var e = []; Kt(this.series, function (t) { e = e.concat(Qt(t.points || [], function (e) { return e.selected })) }); return e }, getSelectedSeries: function () { return Qt(this.series, function (e) { return e.selected }) }, getStacks: function () { var e = this; Kt(e.yAxis, function (e) { if (e.stacks && e.hasVisibleSeries) e.oldStacks = e.stacks }); Kt(e.series, function (t) { if (t.options.stacking && (t.visible === !0 || e.options.chart.ignoreHiddenSeries === !1)) t.stackKey = t.type + d(t.options.stack, "") }) }, setTitle: function (e, n, r) { var i; var s = this, o = s.options, u; u = o.title = t(o.title, e); i = o.subtitle = t(o.subtitle, n), o = i; Kt([["title", e, u], ["subtitle", n, o]], function (e) { var t = e[0], n = s[t], r = e[1], e = e[2]; n && r && (s[t] = n = n.destroy()); e && e.text && !n && (s[t] = s.renderer.text(e.text, 0, 0, e.useHTML).attr({ align: e.align, "class": "highcharts-" + t, zIndex: e.zIndex || 4 }).css(e.style).add()) }); s.layOutTitles(r) }, layOutTitles: function (t) { var n = 0, r = this.title, i = this.subtitle, s = this.options, o = s.title, s = s.subtitle, u = this.spacingBox.width - 44; if (r && (r.css({ width: (o.width || u) + "px" }).align(e({ y: 15 }, o), !1, "spacingBox"), !o.floating && !o.verticalAlign)) n = r.getBBox().height; i && (i.css({ width: (s.width || u) + "px" }).align(e({ y: n + o.margin }, s), !1, "spacingBox"), !s.floating && !s.verticalAlign && (n = $(n + i.getBBox().height))); r = this.titleOffset !== n; this.titleOffset = n; if (!this.isDirtyBox && r) this.isDirtyBox = r, this.hasRendered && d(t, !0) && this.isDirtyBox && this.redraw() }, getChartSize: function () { var e = this.options.chart, t = e.width, e = e.height, n = this.renderToClone || this.renderTo; if (!c(t)) this.containerWidth = Vt(n, "width"); if (!c(e)) this.containerHeight = Vt(n, "height"); this.chartWidth = J(0, t || this.containerWidth || 600); this.chartHeight = J(0, d(e, this.containerHeight > 19 ? this.containerHeight : 400)) }, cloneRenderTo: function (e) { var t = this.renderToClone, n = this.container; e ? t && (this.renderTo.appendChild(n), A(t), delete this.renderToClone) : (n && n.parentNode === this.renderTo && this.renderTo.removeChild(n), this.renderToClone = t = this.renderTo.cloneNode(0), v(t, { position: "absolute", top: "-9999px", display: "block" }), t.style.setProperty && t.style.setProperty("display", "block", "important"), U.body.appendChild(t), n && t.appendChild(n)) }, getContainer: function () { var t, n = this.options.chart, s, o, u; this.renderTo = t = n.renderTo; u = "highcharts-" + vt++; if (i(t)) this.renderTo = t = U.getElementById(t); t || O(13, !0); s = r(h(t, "data-highcharts-chart")); !isNaN(s) && xt[s] && xt[s].hasRendered && xt[s].destroy(); h(t, "data-highcharts-chart", this.index); t.innerHTML = ""; !n.skipClone && !t.offsetWidth && this.cloneRenderTo(); this.getChartSize(); s = this.chartWidth; o = this.chartHeight; this.container = t = m(Nt, { className: "highcharts-container" + (n.className ? " " + n.className : ""), id: u }, e({ position: "relative", overflow: "hidden", width: s + "px", height: o + "px", textAlign: "left", lineHeight: "normal", zIndex: 0, "-webkit-tap-highlight-color": "rgba(0,0,0,0)" }, n.style), this.renderToClone || t); this._cursor = t.style.cursor; this.renderer = n.forExport ? new cn(t, s, o, n.style, !0) : new ht(t, s, o, n.style); ct && this.renderer.create(this, t, s, o) }, getMargins: function () { var e = this.spacing, t, n = this.legend, r = this.margin, i = this.options.legend, s = d(i.margin, 20), o = i.x, u = i.y, a = i.align, f = i.verticalAlign, l = this.titleOffset; this.resetMargins(); t = this.axisOffset; if (l && !c(r[0])) this.plotTop = J(this.plotTop, l + this.options.title.margin + e[0]); if (n.display && !i.floating) if (a === "right") { if (!c(r[1])) this.marginRight = J(this.marginRight, n.legendWidth - o + s + e[1]) } else if (a === "left") { if (!c(r[3])) this.plotLeft = J(this.plotLeft, n.legendWidth + o + s + e[3]) } else if (f === "top") { if (!c(r[0])) this.plotTop = J(this.plotTop, n.legendHeight + u + s + e[0]) } else if (f === "bottom" && !c(r[2])) this.marginBottom = J(this.marginBottom, n.legendHeight - u + s + e[2]); this.extraBottomMargin && (this.marginBottom += this.extraBottomMargin); this.extraTopMargin && (this.plotTop += this.extraTopMargin); this.hasCartesianSeries && Kt(this.axes, function (e) { e.getOffset() }); c(r[3]) || (this.plotLeft += t[3]); c(r[0]) || (this.plotTop += t[0]); c(r[2]) || (this.marginBottom += t[2]); c(r[1]) || (this.marginRight += t[1]); this.setChartSize() }, reflow: function (e) { var t = this, n = t.options.chart, r = t.renderTo, i = n.width || Vt(r, "width"), s = n.height || Vt(r, "height"), n = e ? e.target : z, r = function () { if (t.container) t.setSize(i, s, !1), t.hasUserSize = null }; if (!t.hasUserSize && i && s && (n === z || n === U)) { if (i !== t.containerWidth || s !== t.containerHeight) clearTimeout(t.reflowTimeout), e ? t.reflowTimeout = setTimeout(r, 100) : r(); t.containerWidth = i; t.containerHeight = s } }, initReflow: function () { var e = this, t = function (t) { e.reflow(t) }; Zt(z, "resize", t); Zt(e, "destroy", function () { en(z, "resize", t) }) }, setSize: function (e, t, n) { var r = this, i, s, o; r.isResizing += 1; o = function () { r && tn(r, "endResize", null, function () { r.isResizing -= 1 }) }; _(n, r); r.oldChartHeight = r.chartHeight; r.oldChartWidth = r.chartWidth; if (c(e)) r.chartWidth = i = J(0, X(e)), r.hasUserSize = !!i; if (c(t)) r.chartHeight = s = J(0, X(t)); (bt ? rn : v)(r.container, { width: i + "px", height: s + "px" }, bt); r.setChartSize(!0); r.renderer.setSize(i, s, n); r.maxTicks = null; Kt(r.axes, function (e) { e.isDirty = !0; e.setScale() }); Kt(r.series, function (e) { e.isDirty = !0 }); r.isDirtyLegend = !0; r.isDirtyBox = !0; r.layOutTitles(); r.getMargins(); r.redraw(n); r.oldChartHeight = null; tn(r, "resize"); bt === !1 ? o() : setTimeout(o, bt && bt.duration || 500) }, setChartSize: function (e) { var t = this.inverted, n = this.renderer, r = this.chartWidth, i = this.chartHeight, s = this.options.chart, o = this.spacing, u = this.clipOffset, a, f, l, c; this.plotLeft = a = X(this.plotLeft); this.plotTop = f = X(this.plotTop); this.plotWidth = l = J(0, X(r - a - this.marginRight)); this.plotHeight = c = J(0, X(i - f - this.marginBottom)); this.plotSizeX = t ? c : l; this.plotSizeY = t ? l : c; this.plotBorderWidth = s.plotBorderWidth || 0; this.spacingBox = n.spacingBox = { x: o[3], y: o[0], width: r - o[3] - o[1], height: i - o[0] - o[2] }; this.plotBox = n.plotBox = { x: a, y: f, width: l, height: c }; r = 2 * V(this.plotBorderWidth / 2); t = $(J(r, u[3]) / 2); n = $(J(r, u[0]) / 2); this.clipBox = { x: t, y: n, width: V(this.plotSizeX - J(r, u[1]) / 2 - t), height: V(this.plotSizeY - J(r, u[2]) / 2 - n) }; e || Kt(this.axes, function (e) { e.setAxisSize(); e.setAxisTranslation() }) }, resetMargins: function () { var e = this.spacing, t = this.margin; this.plotTop = d(t[0], e[0]); this.marginRight = d(t[1], e[1]); this.marginBottom = d(t[2], e[2]); this.plotLeft = d(t[3], e[3]); this.axisOffset = [0, 0, 0, 0]; this.clipOffset = [0, 0, 0, 0] }, drawChartBox: function () { var e = this.options.chart, t = this.renderer, n = this.chartWidth, r = this.chartHeight, i = this.chartBackground, s = this.plotBackground, o = this.plotBorder, u = this.plotBGImage, a = e.borderWidth || 0, f = e.backgroundColor, l = e.plotBackgroundColor, c = e.plotBackgroundImage, h = e.plotBorderWidth || 0, p, d = this.plotLeft, v = this.plotTop, m = this.plotWidth, g = this.plotHeight, y = this.plotBox, b = this.clipRect, w = this.clipBox; p = a + (e.shadow ? 8 : 0); if (a || f) if (i) i.animate(i.crisp({ width: n - p, height: r - p })); else { i = { fill: f || Ct }; if (a) i.stroke = e.borderColor, i["stroke-width"] = a; this.chartBackground = t.rect(p / 2, p / 2, n - p, r - p, e.borderRadius, a).attr(i).addClass("highcharts-background").add().shadow(e.shadow) } if (l) s ? s.animate(y) : this.plotBackground = t.rect(d, v, m, g, 0).attr({ fill: l }).add().shadow(e.plotShadow); if (c) u ? u.animate(y) : this.plotBGImage = t.image(c, d, v, m, g).add(); b ? b.animate({ width: w.width, height: w.height }) : this.clipRect = t.clipRect(w); if (h) o ? o.animate(o.crisp({ x: d, y: v, width: m, height: g })) : this.plotBorder = t.rect(d, v, m, g, 0, -h).attr({ stroke: e.plotBorderColor, "stroke-width": h, fill: Ct, zIndex: 1 }).add(); this.isDirtyBox = !1 }, propFromSeries: function () { var e = this, t = e.options.chart, n, r = e.options.series, i, s; Kt(["inverted", "angular", "polar"], function (o) { n = Ut[t.type || t.defaultSeriesType]; s = e[o] || t[o] || n && n.prototype[o]; for (i = r && r.length; !s && i--;) (n = Ut[r[i].type]) && n.prototype[o] && (s = !0); e[o] = s }) }, linkSeries: function () { var e = this, t = e.series; Kt(t, function (e) { e.linkedSeries.length = 0 }); Kt(t, function (t) { var n = t.options.linkedTo; if (i(n) && (n = n === ":previous" ? e.series[t.index - 1] : e.get(n))) n.linkedSeries.push(t), t.linkedParent = n }) }, renderSeries: function () { Kt(this.series, function (e) { e.translate(); e.setTooltipPoints && e.setTooltipPoints(); e.render() }) }, render: function () { var t = this, n = t.axes, i = t.renderer, s = t.options, o = s.labels, u = s.credits, a; t.setTitle(); t.legend = new Sn(t, s.legend); t.getStacks(); Kt(n, function (e) { e.setScale() }); t.getMargins(); t.maxTicks = null; Kt(n, function (e) { e.setTickPositions(!0); e.setMaxTicks() }); t.adjustTickAmounts(); t.getMargins(); t.drawChartBox(); t.hasCartesianSeries && Kt(n, function (e) { e.render() }); if (!t.seriesGroup) t.seriesGroup = i.g("series-group").attr({ zIndex: 3 }).add(); t.renderSeries(); o.items && Kt(o.items, function (n) { var s = e(o.style, n.style), u = r(s.left) + t.plotLeft, a = r(s.top) + t.plotTop + 12; delete s.left; delete s.top; i.text(n.html, u, a).attr({ zIndex: 2 }).css(s).add() }); if (u.enabled && !t.credits) a = u.href, t.credits = i.text(u.text, 0, 0).on("click", function () { if (a) location.href = a }).attr({ align: u.position.align, zIndex: 8 }).css(u.style).add().align(u.position); t.hasRendered = !0 }, destroy: function () { var e = this, t = e.axes, n = e.series, r = e.container, i, s = r && r.parentNode; tn(e, "destroy"); xt[e.index] = R; Tt--; e.renderTo.removeAttribute("data-highcharts-chart"); en(e); for (i = t.length; i--;) t[i] = t[i].destroy(); for (i = n.length; i--;) n[i] = n[i].destroy(); Kt("title,subtitle,chartBackground,plotBackground,plotBGImage,plotBorder,seriesGroup,clipRect,credits,pointer,scroller,rangeSelector,legend,resetZoomButton,tooltip,renderer".split(","), function (t) { var n = e[t]; n && n.destroy && (e[t] = n.destroy()) }); if (r) r.innerHTML = "", en(r), s && A(r); for (i in e) delete e[i] }, isReadyToRender: function () { var e = this; return !ft && z == z.top && U.readyState !== "complete" || ct && !z.canvg ? (ct ? dn.push(function () { e.firstRender() }, e.options.global.canvasToolsURL) : U.attachEvent("onreadystatechange", function () { U.detachEvent("onreadystatechange", e.firstRender); U.readyState === "complete" && e.firstRender() }), !1) : !0 }, firstRender: function () { var e = this, t = e.options, n = e.callback; if (e.isReadyToRender()) { e.getContainer(); tn(e, "init"); e.resetMargins(); e.setChartSize(); e.propFromSeries(); e.getAxes(); Kt(t.series || [], function (t) { e.initSeries(t) }); e.linkSeries(); tn(e, "beforeRender"); if (zt.Pointer) e.pointer = new gn(e, t); e.render(); e.renderer.draw(); n && n.apply(e, [e]); Kt(e.callbacks, function (t) { t.apply(e, [e]) }); e.cloneRenderTo(!0); tn(e, "load") } }, splashArray: function (e, t) { var n = t[e], n = s(n) ? n : [n, n, n, n]; return [d(t[e + "Top"], n[0]), d(t[e + "Right"], n[1]), d(t[e + "Bottom"], n[2]), d(t[e + "Left"], n[3])] } }; j.prototype.callbacks = []; pn = zt.CenteredSeriesMixin = { getCenter: function () { var e = this.options, t = this.chart, n = 2 * (e.slicedOffset || 0), i, s = t.plotWidth - 2 * n, o = t.plotHeight - 2 * n, t = e.center, e = [d(t[0], "50%"), d(t[1], "50%"), e.size || "100%", e.innerSize || 0], u = K(s, o), a; return Yt(e, function (e, t) { a = /%$/.test(e); i = t < 2 || t === 2 && a; return (a ? [s, o, u, u][t] * r(e) / 100 : e) + (i ? n : 0) }) } }; var xn = function () { }; xn.prototype = { init: function (e, t, n) { this.series = e; this.applyOptions(t, n); this.pointAttr = {}; if (e.options.colorByPoint && (t = e.options.colors || e.chart.options.colors, this.color = this.color || t[e.colorCounter++], e.colorCounter === t.length)) e.colorCounter = 0; e.chart.pointCount++; return this }, applyOptions: function (t, n) { var r = this.series, i = r.pointValKey, t = xn.prototype.optionsToObject.call(this, t); e(this, t); this.options = this.options ? e(this.options, t) : t; if (i) this.y = this[i]; if (this.x === R && r) this.x = n === R ? r.autoIncrement() : n; return this }, optionsToObject: function (e) { var t = {}, n = this.series, r = n.pointArrayMap || ["y"], i = r.length, s = 0, u = 0; if (typeof e === "number" || e === null) t[r[0]] = e; else if (o(e)) { if (e.length > i) { n = typeof e[0]; if (n === "string") t.name = e[0]; else if (n === "number") t.x = e[0]; s++ } for (; u < i;) t[r[u++]] = e[s++] } else if (typeof e === "object") { t = e; if (e.dataLabels) n._hasPointLabels = !0; if (e.marker) n._hasPointMarkers = !0 } return t }, destroy: function () { var e = this.series.chart, t = e.hoverPoints, n; e.pointCount--; if (t && (this.setState(), l(t, this), !t.length)) e.hoverPoints = null; if (this === e.hoverPoint) this.onMouseOut(); if (this.graphic || this.dataLabel) en(this), this.destroyElements(); this.legendItem && e.legend.destroyItem(this); for (n in this) this[n] = null }, destroyElements: function () { for (var e = "graphic,dataLabel,dataLabelUpper,group,connector,shadowGroup".split(","), t, n = 6; n--;) t = e[n], this[t] && (this[t] = this[t].destroy()) }, getLabelConfig: function () { return { x: this.category, y: this.y, key: this.name || this.category, series: this.series, point: this, percentage: this.percentage, total: this.total || this.stackTotal } }, tooltipFormatter: function (e) { var t = this.series, n = t.tooltipOptions, r = d(n.valueDecimals, ""), i = n.valuePrefix || "", s = n.valueSuffix || ""; Kt(t.pointArrayMap || ["y"], function (t) { t = "{point." + t; if (i || s) e = e.replace(t + "}", i + t + "}" + s); e = e.replace(t + "}", t + ":,." + r + "f}") }); return E(e, { point: this, series: this.series }) }, firePointEvent: function (e, t, n) { var r = this, i = this.series.options; (i.point.events[e] || r.options && r.options.events && r.options.events[e]) && this.importEvents(); e === "click" && i.allowPointSelect && (n = function (e) { r.select(null, e.ctrlKey || e.metaKey || e.shiftKey) }); tn(this, e, t, n) } }; var Tn = function () { }; Tn.prototype = { isCartesian: !0, type: "line", pointClass: xn, sorted: !0, requireSorting: !0, pointAttrToOptions: { stroke: "lineColor", "stroke-width": "lineWidth", fill: "fillColor", r: "radius" }, axisTypes: ["xAxis", "yAxis"], colorCounter: 0, parallelArrays: ["x", "y"], init: function (t, n) { var r = this, i, s, o = t.series, u = function (e, t) { return d(e.options.index, e._i) - d(t.options.index, t._i) }; r.chart = t; r.options = n = r.setOptions(n); r.linkedSeries = []; r.bindAxes(); e(r, { name: n.name, state: "", pointAttr: {}, visible: n.visible !== !1, selected: n.selected === !0 }); if (ct) n.animation = !1; s = n.events; for (i in s) Zt(r, i, s[i]); if (s && s.click || n.point && n.point.events && n.point.events.click || n.allowPointSelect) t.runTrackerClick = !0; r.getColor(); r.getSymbol(); Kt(r.parallelArrays, function (e) { r[e + "Data"] = [] }); r.setData(n.data, !1); if (r.isCartesian) t.hasCartesianSeries = !0; o.push(r); r._i = o.length - 1; N(o, u); this.yAxis && N(this.yAxis.series, u); Kt(o, function (e, t) { e.index = t; e.name = e.name || "Series " + (t + 1) }) }, bindAxes: function () { var e = this, t = e.options, n = e.chart, r; Kt(e.axisTypes || [], function (i) { Kt(n[i], function (n) { r = n.options; if (t[i] === r.index || t[i] !== R && t[i] === r.id || t[i] === R && r.index === 0) n.series.push(e), e[i] = n, n.isDirty = !0 }); !e[i] && e.optionalAxis !== i && O(18, !0) }) }, updateParallelArrays: function (e, t) { var n = e.series, r = arguments; Kt(n.parallelArrays, typeof t === "number" ? function (r) { var i = r === "y" && n.toYData ? n.toYData(e) : e[r]; n[r + "Data"][t] = i } : function (e) { Array.prototype[t].apply(n[e + "Data"], Array.prototype.slice.call(r, 2)) }) }, autoIncrement: function () { var e = this.options, t = this.xIncrement, t = d(t, e.pointStart, 0); this.pointInterval = d(this.pointInterval, e.pointInterval, 1); this.xIncrement = t + this.pointInterval; return t }, getSegments: function () { var e = -1, t = [], n, r = this.points, i = r.length; if (i) if (this.options.connectNulls) { for (n = i; n--;) r[n].y === null && r.splice(n, 1); r.length && (t = [r]) } else Kt(r, function (n, s) { n.y === null ? (s > e + 1 && t.push(r.slice(e + 1, s)), e = s) : s === i - 1 && t.push(r.slice(e + 1, s + 1)) }); this.segments = t }, setOptions: function (e) { var n = this.chart, r = n.options.plotOptions, n = n.userOptions || {}, i = n.plotOptions || {}, s = r[this.type]; this.userOptions = e; r = t(s, r.series, e); this.tooltipOptions = t(gt.tooltip, gt.plotOptions[this.type].tooltip, n.tooltip, i.series && i.series.tooltip, i[this.type] && i[this.type].tooltip, e.tooltip); s.marker === null && delete r.marker; return r }, getColor: function () { var e = this.options, t = this.userOptions, n = this.chart.options.colors, r = this.chart.counters, i; i = e.color || on[this.type].color; if (!i && !e.colorByPoint) c(t._colorIndex) ? e = t._colorIndex : (t._colorIndex = r.color, e = r.color++), i = n[e]; this.color = i; r.wrapColor(n.length) }, getSymbol: function () { var e = this.userOptions, t = this.options.marker, n = this.chart, r = n.options.symbols, n = n.counters; this.symbol = t.symbol; if (!this.symbol) c(e._symbolIndex) ? e = e._symbolIndex : (e._symbolIndex = n.symbol, e = n.symbol++), this.symbol = r[e]; if (/^url/.test(this.symbol)) t.radius = 0; n.wrapSymbol(r.length) }, drawLegendSymbol: Xt.drawLineMarker, setData: function (e, t, n, r) { var s = this, a = s.points, f = a && a.length || 0, l, c = s.options, h = s.chart, p = null, v = s.xAxis, m = v && !!v.categories, g = s.tooltipPoints, y = c.turboThreshold, b = this.xData, w = this.yData, E = (l = s.pointArrayMap) && l.length, e = e || []; l = e.length; t = d(t, !0); if (r !== !1 && l && f === l && !s.cropped && !s.hasGroupedData) Kt(e, function (e, t) { a[t].update(e, !1) }); else { s.xIncrement = null; s.pointRange = m ? 1 : c.pointRange; s.colorCounter = 0; Kt(this.parallelArrays, function (e) { s[e + "Data"].length = 0 }); if (y && l > y) { for (n = 0; p === null && n < l;) p = e[n], n++; if (u(p)) { m = d(c.pointStart, 0); c = d(c.pointInterval, 1); for (n = 0; n < l; n++) b[n] = m, w[n] = e[n], m += c; s.xIncrement = m } else if (o(p)) if (E) for (n = 0; n < l; n++) c = e[n], b[n] = c[0], w[n] = c.slice(1, E + 1); else for (n = 0; n < l; n++) c = e[n], b[n] = c[0], w[n] = c[1]; else O(12) } else for (n = 0; n < l; n++) if (e[n] !== R && (c = { series: s }, s.pointClass.prototype.applyOptions.apply(c, [e[n]]), s.updateParallelArrays(c, n), m && c.name)) v.names[c.x] = c.name; i(w[0]) && O(14, !0); s.data = []; s.options.data = e; for (n = f; n--;) a[n] && a[n].destroy && a[n].destroy(); if (g) g.length = 0; if (v) v.minRange = v.userMinRange; s.isDirty = s.isDirtyData = h.isDirtyBox = !0; n = !1 } t && h.redraw(n) }, processData: function (e) { var t = this.xData, n = this.yData, r = t.length, i; i = 0; var s, o, u = this.xAxis, a = this.options, f = a.cropThreshold, l = 0, c = this.isCartesian, h, p; if (c && !this.isDirty && !u.isDirty && !this.yAxis.isDirty && !e) return !1; if (c && this.sorted && (!f || r > f || this.forceCrop)) if (h = u.min, p = u.max, t[r - 1] < h || t[0] > p) t = [], n = []; else if (t[0] < h || t[r - 1] > p) i = this.cropData(this.xData, this.yData, h, p), t = i.xData, n = i.yData, i = i.start, s = !0, l = t.length; for (r = t.length - 1; r >= 0; r--) e = t[r] - t[r - 1], !s && t[r] > h && t[r] < p && l++, e > 0 && (o === R || e < o) ? o = e : e < 0 && this.requireSorting && O(15); this.cropped = s; this.cropStart = i; this.processedXData = t; this.processedYData = n; this.activePointCount = l; if (a.pointRange === null) this.pointRange = o || 1; this.closestPointRange = o }, cropData: function (e, t, n, r) { var i = e.length, s = 0, o = i, u = d(this.cropShoulder, 1), a; for (a = 0; a < i; a++) if (e[a] >= n) { s = J(0, a - u); break } for (; a < i; a++) if (e[a] > r) { o = a + u; break } return { xData: e.slice(s, o), yData: t.slice(s, o), start: s, end: o } }, generatePoints: function () { var e = this.options.data, t = this.data, n, r = this.processedXData, i = this.processedYData, s = this.pointClass, o = r.length, u = this.cropStart || 0, a, f = this.hasGroupedData, l, c = [], h; if (!t && !f) t = [], t.length = e.length, t = this.data = t; for (h = 0; h < o; h++) a = u + h, f ? c[h] = (new s).init(this, [r[h]].concat(p(i[h]))) : (t[a] ? l = t[a] : e[a] !== R && (t[a] = l = (new s).init(this, e[a], r[h])), c[h] = l); if (t && (o !== (n = t.length) || f)) for (h = 0; h < n; h++) if (h === u && !f && (h += o), t[h]) t[h].destroyElements(), t[h].plotX = R; this.data = t; this.points = c }, getExtremes: function (e) { var t = this.yAxis, n = this.processedXData, r, i = [], s = 0; r = this.xAxis.getExtremes(); var o = r.min, u = r.max, a, f, l, c, e = e || this.stackedYData || this.processedYData; r = e.length; for (c = 0; c < r; c++) if (f = n[c], l = e[c], a = l !== null && l !== R && (!t.isLog || l.length || l > 0), f = this.getExtremesFromAll || this.cropped || (n[c + 1] || f) >= o && (n[c - 1] || f) <= u, a && f) if (a = l.length) for (; a--;) l[a] !== null && (i[s++] = l[a]); else i[s++] = l; this.dataMin = d(void 0, C(i)); this.dataMax = d(void 0, k(i)) }, translate: function () { this.processedXData || this.processData(); this.generatePoints(); for (var e = this.options, t = e.stacking, n = this.xAxis, r = n.categories, i = this.yAxis, s = this.points, o = s.length, a = !!this.modifyValue, f = e.pointPlacement, l = f === "between" || u(f), h = e.threshold, e = 0; e < o; e++) { var p = s[e], v = p.x, m = p.y, g = p.low, y = t && i.stacks[(this.negStacks && m < h ? "-" : "") + this.stackKey]; if (i.isLog && m <= 0) p.y = m = null; p.plotX = n.translate(v, 0, 0, 0, 1, f, this.type === "flags"); if (t && this.visible && y && y[v]) y = y[v], m = y.points[this.index + "," + e], g = m[0], m = m[1], g === 0 && (g = d(h, i.min)), i.isLog && g <= 0 && (g = null), p.total = p.stackTotal = y.total, p.percentage = y.total && p.y / y.total * 100, p.stackY = m, y.setOffset(this.pointXOffset || 0, this.barW || 0); p.yBottom = c(g) ? i.translate(g, 0, 1, 0, 1) : null; a && (m = this.modifyValue(m, p)); p.plotY = typeof m === "number" && m !== Infinity ? i.translate(m, 0, 1, 0, 1) : R; p.clientX = l ? n.translate(v, 0, 0, 0, 1) : p.plotX; p.negative = p.y < (h || 0); p.category = r && r[p.x] !== R ? r[p.x] : p.x } this.getSegments() }, animate: function (t) { var n = this.chart, r = n.renderer, i; i = this.options.animation; var o = this.clipBox || n.clipBox, u = n.inverted, a; if (i && !s(i)) i = on[this.type].animation; a = ["_sharedClip", i.duration, i.easing, o.height].join(","); t ? (t = n[a], i = n[a + "m"], t || (n[a] = t = r.clipRect(e(o, { width: 0 })), n[a + "m"] = i = r.clipRect(-99, u ? -n.plotLeft : -n.plotTop, 99, u ? n.chartWidth : n.chartHeight)), this.group.clip(t), this.markerGroup.clip(i), this.sharedClipKey = a) : ((t = n[a]) && t.animate({ width: n.plotSizeX }, i), n[a + "m"] && n[a + "m"].animate({ width: n.plotSizeX + 99 }, i), this.animate = null) }, afterAnimate: function () { var e = this.chart, t = this.sharedClipKey, n = this.group, r = this.clipBox; if (n && this.options.clip !== !1) { if (!t || !r) n.clip(r ? e.renderer.clipRect(r) : e.clipRect); this.markerGroup.clip() } tn(this, "afterAnimate"); setTimeout(function () { t && e[t] && (r || (e[t] = e[t].destroy()), e[t + "m"] && (e[t + "m"] = e[t + "m"].destroy())) }, 100) }, drawPoints: function () { var t, n = this.points, r = this.chart, i, s, o, u, a, f, l, c; i = this.options.marker; var h = this.pointAttr[""], p, v = this.markerGroup, m = d(i.enabled, this.activePointCount < .5 * this.xAxis.len / i.radius); if (i.enabled !== !1 || this._hasPointMarkers) for (o = n.length; o--;) if (u = n[o], i = V(u.plotX), s = u.plotY, c = u.graphic, f = u.marker || {}, t = m && f.enabled === R || f.enabled, p = r.isInsidePlot(X(i), s, r.inverted), t && s !== R && !isNaN(s) && u.y !== null) if (t = u.pointAttr[u.selected ? "select" : ""] || h, a = t.r, f = d(f.symbol, this.symbol), l = f.indexOf("url") === 0, c) c[p ? "show" : "hide"](!0).animate(e({ x: i - a, y: s - a }, c.symbolName ? { width: 2 * a, height: 2 * a } : {})); else { if (p && (a > 0 || l)) u.graphic = r.renderer.symbol(f, i - a, s - a, 2 * a, 2 * a).attr(t).add(v) } else if (c) u.graphic = c.destroy() }, convertAttribs: function (e, t, n, r) { var i = this.pointAttrToOptions, s, o, u = {}, e = e || {}, t = t || {}, n = n || {}, r = r || {}; for (s in i) o = i[s], u[s] = d(e[o], t[s], n[s], r[s]); return u }, getAttribs: function () { var t = this, n = t.options, r = on[t.type].marker ? n.marker : n, i = r.states, s = i.hover, o, u = t.color; o = { stroke: u, fill: u }; var a = t.points || [], f, l = [], h, p = t.pointAttrToOptions; h = t.hasPointSpecificOptions; var d = n.negativeColor, v = r.lineColor, m = r.fillColor; f = n.turboThreshold; var g; n.marker ? (s.radius = s.radius || r.radius + 2, s.lineWidth = s.lineWidth || r.lineWidth + 1) : s.color = s.color || ln(s.color || u).brighten(s.brightness).get(); l[""] = t.convertAttribs(r, o); Kt(["hover", "select"], function (e) { l[e] = t.convertAttribs(i[e], l[""]) }); t.pointAttr = l; u = a.length; if (!f || u < f || h) for (; u--;) { f = a[u]; if ((r = f.options && f.options.marker || f.options) && r.enabled === !1) r.radius = 0; if (f.negative && d) f.color = f.fillColor = d; h = n.colorByPoint || f.color; if (f.options) for (g in p) c(r[p[g]]) && (h = !0); if (h) { r = r || {}; h = []; i = r.states || {}; o = i.hover = i.hover || {}; if (!n.marker) o.color = o.color || !f.options.color && s.color || ln(f.color).brighten(o.brightness || s.brightness).get(); o = { color: f.color }; if (!m) o.fillColor = f.color; if (!v) o.lineColor = f.color; h[""] = t.convertAttribs(e(o, r), l[""]); h.hover = t.convertAttribs(i.hover, l.hover, h[""]); h.select = t.convertAttribs(i.select, l.select, h[""]) } else h = l; f.pointAttr = h } }, destroy: function () { var e = this, t = e.chart, n = /AppleWebKit\/533/.test(tt), r, i, s = e.data || [], o, u, a; tn(e, "destroy"); en(e); Kt(e.axisTypes || [], function (t) { if (a = e[t]) l(a.series, e), a.isDirty = a.forceRedraw = !0 }); e.legendItem && e.chart.legend.destroyItem(e); for (i = s.length; i--;) (o = s[i]) && o.destroy && o.destroy(); e.points = null; clearTimeout(e.animationTimeout); Kt("area,graph,dataLabelsGroup,group,markerGroup,tracker,graphNeg,areaNeg,posClip,negClip".split(","), function (t) { e[t] && (r = n && t === "group" ? "hide" : "destroy", e[t][r]()) }); if (t.hoverSeries === e) t.hoverSeries = null; l(t.series, e); for (u in e) delete e[u] }, getSegmentPath: function (e) { var t = this, n = [], r = t.options.step; Kt(e, function (i, s) { var o = i.plotX, u = i.plotY, a; t.getPointSpline ? n.push.apply(n, t.getPointSpline(e, i, s)) : (n.push(s ? "L" : "M"), r && s && (a = e[s - 1], r === "right" ? n.push(a.plotX, u) : r === "center" ? n.push((a.plotX + o) / 2, a.plotY, (a.plotX + o) / 2, u) : n.push(o, a.plotY)), n.push(i.plotX, i.plotY)) }); return n }, getGraphPath: function () { var e = this, t = [], n, r = []; Kt(e.segments, function (i) { n = e.getSegmentPath(i); i.length > 1 ? t = t.concat(n) : r.push(i[0]) }); e.singlePoints = r; return e.graphPath = t }, drawGraph: function () { var e = this, t = this.options, n = [["graph", t.lineColor || this.color]], r = t.lineWidth, i = t.dashStyle, s = t.linecap !== "square", o = this.getGraphPath(), u = t.negativeColor; u && n.push(["graphNeg", u]); Kt(n, function (n, u) { var a = n[0], f = e[a]; if (f) sn(f), f.animate({ d: o }); else if (r && o.length) f = { stroke: n[1], "stroke-width": r, fill: Ct, zIndex: 1 }, i ? f.dashstyle = i : s && (f["stroke-linecap"] = f["stroke-linejoin"] = "round"), e[a] = e.chart.renderer.path(o).attr(f).add(e.group).shadow(!u && t.shadow) }) }, clipNeg: function () { var e = this.options, t = this.chart, n = t.renderer, r = e.negativeColor || e.negativeFillColor, i, s = this.graph, o = this.area, u = this.posClip, a = this.negClip; i = t.chartWidth; var f = t.chartHeight, l = J(i, f), c = this.yAxis; if (r && (s || o)) { r = X(c.toPixels(e.threshold || 0, !0)); r < 0 && (l -= r); e = { x: 0, y: 0, width: l, height: r }; l = { x: 0, y: r, width: l, height: l }; if (t.inverted) e.height = l.y = t.plotWidth - r, n.isVML && (e = { x: t.plotWidth - r - t.plotLeft, y: 0, width: i, height: f }, l = { x: r + t.plotLeft - i, y: 0, width: t.plotLeft + r, height: i }); c.reversed ? (t = l, i = e) : (t = e, i = l); u ? (u.animate(t), a.animate(i)) : (this.posClip = u = n.clipRect(t), this.negClip = a = n.clipRect(i), s && this.graphNeg && (s.clip(u), this.graphNeg.clip(a)), o && (o.clip(u), this.areaNeg.clip(a))) } }, invertGroups: function () { function e() { var e = { width: t.yAxis.len, height: t.xAxis.len }; Kt(["group", "markerGroup"], function (n) { t[n] && t[n].attr(e).invert() }) } var t = this, n = t.chart; if (t.xAxis) Zt(n, "resize", e), Zt(t, "destroy", function () { en(n, "resize", e) }), e(), t.invertGroups = e }, plotGroup: function (e, t, n, r, i) { var s = this[e], o = !s; o && (this[e] = s = this.chart.renderer.g(t).attr({ visibility: n, zIndex: r || .1 }).add(i)); s[o ? "attr" : "animate"](this.getPlotBox()); return s }, getPlotBox: function () { var e = this.chart, t = this.xAxis, n = this.yAxis; if (e.inverted) t = n, n = this.xAxis; return { translateX: t ? t.left : e.plotLeft, translateY: n ? n.top : e.plotTop, scaleX: 1, scaleY: 1 } }, render: function () { var e = this, t = e.chart, n, r = e.options, i = (n = r.animation) && !!e.animate && t.renderer.isSVG && d(n.duration, 500) || 0, s = e.visible ? "visible" : "hidden", o = r.zIndex, u = e.hasRendered, a = t.seriesGroup; n = e.plotGroup("group", "series", s, o, a); e.markerGroup = e.plotGroup("markerGroup", "markers", s, o, a); i && e.animate(!0); e.getAttribs(); n.inverted = e.isCartesian ? t.inverted : !1; e.drawGraph && (e.drawGraph(), e.clipNeg()); e.drawDataLabels && e.drawDataLabels(); e.visible && e.drawPoints(); e.drawTracker && e.options.enableMouseTracking !== !1 && e.drawTracker(); t.inverted && e.invertGroups(); r.clip !== !1 && !e.sharedClipKey && !u && n.clip(t.clipRect); i && e.animate(); if (!u) i ? e.animationTimeout = setTimeout(function () { e.afterAnimate() }, i) : e.afterAnimate(); e.isDirty = e.isDirtyData = !1; e.hasRendered = !0 }, redraw: function () { var e = this.chart, t = this.isDirtyData, n = this.group, r = this.xAxis, i = this.yAxis; n && (e.inverted && n.attr({ width: e.plotWidth, height: e.plotHeight }), n.animate({ translateX: d(r && r.left, e.plotLeft), translateY: d(i && i.top, e.plotTop) })); this.translate(); this.setTooltipPoints && this.setTooltipPoints(!0); this.render(); t && tn(this, "updatedData") } }; F.prototype = { destroy: function () { L(this, this.axis) }, render: function (e) { var t = this.options, n = t.format, n = n ? E(n, this) : t.formatter.call(this); this.label ? this.label.attr({ text: n, visibility: "hidden" }) : this.label = this.axis.chart.renderer.text(n, null, null, t.useHTML).css(t.style).attr({ align: this.textAlign, rotation: t.rotation, visibility: "hidden" }).add(e) }, setOffset: function (e, t) { var n = this.axis, r = n.chart, i = r.inverted, s = this.isNegative, o = n.translate(n.usePercentage ? 100 : this.total, 0, 0, 0, 1), n = n.translate(0), n = Q(o - n), u = r.xAxis[0].translate(this.x) + e, a = r.plotHeight, s = { x: i ? s ? o : o - n : u, y: i ? a - u - t : s ? a - o - n : a - o, width: i ? n : t, height: i ? t : n }; if (i = this.label) i.align(this.alignOptions, null, s), s = i.alignAttr, i[this.options.crop === !1 || r.isInsidePlot(s.x, s.y) ? "show" : "hide"](!0) } }; B.prototype.buildStacks = function () { var e = this.series, t = d(this.options.reversedStacks, !0), n = e.length; if (!this.isXAxis) { for (this.usePercentage = !1; n--;) e[t ? n : e.length - n - 1].setStackedPoints(); if (this.usePercentage) for (n = 0; n < e.length; n++) e[n].setPercentStacks() } }; B.prototype.renderStackTotals = function () { var e = this.chart, t = e.renderer, n = this.stacks, r, i, s = this.stackTotalGroup; if (!s) this.stackTotalGroup = s = t.g("stack-labels").attr({ visibility: "visible", zIndex: 6 }).add(); s.translate(e.plotLeft, e.plotTop); for (r in n) for (i in e = n[r], e) e[i].render(s) }; Tn.prototype.setStackedPoints = function () { if (this.options.stacking && !(this.visible !== !0 && this.chart.options.chart.ignoreHiddenSeries !== !1)) { var e = this.processedXData, t = this.processedYData, n = [], r = t.length, i = this.options, s = i.threshold, o = i.stack, i = i.stacking, u = this.stackKey, a = "-" + u, f = this.negStacks, l = this.yAxis, c = l.stacks, h = l.oldStacks, p, d, v, m, g, y; for (m = 0; m < r; m++) { g = e[m]; y = t[m]; v = this.index + "," + m; d = (p = f && y < s) ? a : u; c[d] || (c[d] = {}); if (!c[d][g]) h[d] && h[d][g] ? (c[d][g] = h[d][g], c[d][g].total = null) : c[d][g] = new F(l, l.options.stackLabels, p, g, o); d = c[d][g]; d.points[v] = [d.cum || 0]; i === "percent" ? (p = p ? u : a, f && c[p] && c[p][g] ? (p = c[p][g], d.total = p.total = J(p.total, d.total) + Q(y) || 0) : d.total = M(d.total + (Q(y) || 0))) : d.total = M(d.total + (y || 0)); d.cum = (d.cum || 0) + (y || 0); d.points[v].push(d.cum); n[m] = d.cum } if (i === "percent") l.usePercentage = !0; this.stackedYData = n; l.oldStacks = {} } }; Tn.prototype.setPercentStacks = function () { var e = this, t = e.stackKey, n = e.yAxis.stacks, r = e.processedXData; Kt([t, "-" + t], function (t) { var i; for (var s = r.length, o, u; s--;) if (o = r[s], i = (u = n[t] && n[t][o]) && u.points[e.index + "," + s], o = i) u = u.total ? 100 / u.total : 0, o[0] = M(o[0] * u), o[1] = M(o[1] * u), e.stackedYData[s] = o[1] }) }; e(j.prototype, { addSeries: function (e, t, n) { var r, i = this; e && (t = d(t, !0), tn(i, "addSeries", { options: e }, function () { r = i.initSeries(e); i.isDirtyLegend = !0; i.linkSeries(); t && i.redraw(n) })); return r }, addAxis: function (e, n, r, i) { var s = n ? "xAxis" : "yAxis", o = this.options; new B(this, t(e, { index: this[s].length, isX: n })); o[s] = p(o[s] || {}); o[s].push(e); d(r, !0) && this.redraw(i) }, showLoading: function (t) { var n = this.options, r = this.loadingDiv, i = n.loading; if (!r) this.loadingDiv = r = m(Nt, { className: "highcharts-loading" }, e(i.style, { zIndex: 10, display: Ct }), this.container), this.loadingSpan = m("span", null, i.labelStyle, r); this.loadingSpan.innerHTML = t || n.lang.loading; if (!this.loadingShown) v(r, { opacity: 0, display: "", left: this.plotLeft + "px", top: this.plotTop + "px", width: this.plotWidth + "px", height: this.plotHeight + "px" }), rn(r, { opacity: i.style.opacity }, { duration: i.showDuration || 0 }), this.loadingShown = !0 }, hideLoading: function () { var e = this.options, t = this.loadingDiv; t && rn(t, { opacity: 0 }, { duration: e.loading.hideDuration || 100, complete: function () { v(t, { display: Ct }) } }); this.loadingShown = !1 } }); e(xn.prototype, { update: function (e, t, n) { var r = this, i = r.series, o = r.graphic, u, a = i.data, f = i.chart, l = i.options, t = d(t, !0); r.firePointEvent("update", { options: e }, function () { r.applyOptions(e); if (s(e)) { i.getAttribs(); if (o) e && e.marker && e.marker.symbol ? r.graphic = o.destroy() : o.attr(r.pointAttr[r.state || ""]); if (e && e.dataLabels && r.dataLabel) r.dataLabel = r.dataLabel.destroy() } u = Jt(r, a); i.updateParallelArrays(r, u); l.data[u] = r.options; i.isDirty = i.isDirtyData = !0; if (!i.fixedBox && i.hasCartesianSeries) f.isDirtyBox = !0; l.legendType === "point" && f.legend.destroyItem(r); t && f.redraw(n) }) }, remove: function (e, t) { var n = this, r = n.series, i = r.points, s = r.chart, o, u = r.data; _(t, s); e = d(e, !0); n.firePointEvent("remove", null, function () { o = Jt(n, u); u.length === i.length && i.splice(o, 1); u.splice(o, 1); r.options.data.splice(o, 1); r.updateParallelArrays(n, "splice", o, 1); n.destroy(); r.isDirty = !0; r.isDirtyData = !0; e && s.redraw() }) } }); e(Tn.prototype, { addPoint: function (e, t, n, r) { var i = this.options, s = this.data, o = this.graph, u = this.area, a = this.chart, f = this.xAxis && this.xAxis.names, l = o && o.shift || 0, c = i.data, h, p = this.xData; _(r, a); n && Kt([o, u, this.graphNeg, this.areaNeg], function (e) { if (e) e.shift = l + 1 }); if (u) u.isArea = !0; t = d(t, !0); r = { series: this }; this.pointClass.prototype.applyOptions.apply(r, [e]); o = r.x; u = p.length; if (this.requireSorting && o < p[u - 1]) for (h = !0; u && p[u - 1] > o;) u--; this.updateParallelArrays(r, "splice", u, 0, 0); this.updateParallelArrays(r, u); if (f) f[o] = r.name; c.splice(u, 0, e); h && (this.data.splice(u, 0, null), this.processData()); i.legendType === "point" && this.generatePoints(); n && (s[0] && s[0].remove ? s[0].remove(!1) : (s.shift(), this.updateParallelArrays(r, "shift"), c.shift())); this.isDirtyData = this.isDirty = !0; t && (this.getAttribs(), a.redraw()) }, remove: function (e, t) { var n = this, r = n.chart, e = d(e, !0); if (!n.isRemoving) n.isRemoving = !0, tn(n, "remove", null, function () { n.destroy(); r.isDirtyLegend = r.isDirtyBox = !0; r.linkSeries(); e && r.redraw(t) }); n.isRemoving = !1 }, update: function (n, r) { var i = this.chart, s = this.type, o = Ut[s].prototype, u, n = t(this.userOptions, { animation: !1, index: this.index, pointStart: this.xData[0] }, { data: this.options.data }, n); this.remove(!1); for (u in o) o.hasOwnProperty(u) && (this[u] = R); e(this, Ut[n.type || s].prototype); this.init(i, n); d(r, !0) && i.redraw(!1) } }); e(B.prototype, { update: function (n, r) { var i = this.chart, n = i.options[this.coll][this.options.index] = t(this.userOptions, n); this.destroy(!0); this._addedPlotLB = R; this.init(i, e(n, { events: R })); i.isDirtyBox = !0; d(r, !0) && i.redraw() }, remove: function (e) { for (var t = this.chart, n = this.coll, r = this.series, i = r.length; i--;) r[i] && r[i].remove(!1); l(t.axes, this); l(t[n], this); t.options[n].splice(this.options.index, 1); Kt(t[n], function (e, t) { e.options.index = t }); this.destroy(); t.isDirtyBox = !0; d(e, !0) && t.redraw() }, setTitle: function (e, t) { this.update({ title: e }, t) }, setCategories: function (e, t) { this.update({ categories: e }, t) } }); var Nn = g(Tn); Ut.line = Nn; on.area = t(Wt, { threshold: 0 }); var Cn = g(Tn, { type: "area", getSegments: function () { var e = [], t = [], n = [], r = this.xAxis, i = this.yAxis, s = i.stacks[this.stackKey], o = {}, u, a, f = this.points, l = this.options.connectNulls, c, h, p; if (this.options.stacking && !this.cropped) { for (h = 0; h < f.length; h++) o[f[h].x] = f[h]; for (p in s) s[p].total !== null && n.push(+p); n.sort(function (e, t) { return e - t }); Kt(n, function (e) { if (!l || o[e] && o[e].y !== null) o[e] ? t.push(o[e]) : (u = r.translate(e), c = s[e].percent ? s[e].total ? s[e].cum * 100 / s[e].total : 0 : s[e].cum, a = i.toPixels(c, !0), t.push({ y: null, plotX: u, clientX: u, plotY: a, yBottom: a, onMouseOver: St })) }); t.length && e.push(t) } else Tn.prototype.getSegments.call(this), e = this.segments; this.segments = e }, getSegmentPath: function (e) { var t = Tn.prototype.getSegmentPath.call(this, e), n = [].concat(t), r, i = this.options; r = t.length; var s = this.yAxis.getThreshold(i.threshold), o; r === 3 && n.push("L", t[1], t[2]); if (i.stacking && !this.closedStacks) for (r = e.length - 1; r >= 0; r--) o = d(e[r].yBottom, s), r < e.length - 1 && i.step && n.push(e[r + 1].plotX, o), n.push(e[r].plotX, o); else this.closeSegment(n, e, s); this.areaPath = this.areaPath.concat(n); return t }, closeSegment: function (e, t, n) { e.push("L", t[t.length - 1].plotX, n, "L", t[0].plotX, n) }, drawGraph: function () { this.areaPath = []; Tn.prototype.drawGraph.apply(this); var e = this, t = this.areaPath, n = this.options, r = n.negativeColor, i = n.negativeFillColor, s = [["area", this.color, n.fillColor]]; (r || i) && s.push(["areaNeg", r, i]); Kt(s, function (r) { var i = r[0], s = e[i]; s ? s.animate({ d: t }) : e[i] = e.chart.renderer.path(t).attr({ fill: d(r[2], ln(r[1]).setOpacity(d(n.fillOpacity, .75)).get()), zIndex: 0 }).add(e.group) }) }, drawLegendSymbol: Xt.drawRectangle }); Ut.area = Cn; on.spline = t(Wt); Nn = g(Tn, { type: "spline", getPointSpline: function (e, t, n) { var r = t.plotX, i = t.plotY, s = e[n - 1], o = e[n + 1], u, a, f, l; if (s && o) { e = s.plotY; f = o.plotX; var o = o.plotY, c; u = (1.5 * r + s.plotX) / 2.5; a = (1.5 * i + e) / 2.5; f = (1.5 * r + f) / 2.5; l = (1.5 * i + o) / 2.5; c = (l - a) * (f - r) / (f - u) + i - l; a += c; l += c; a > e && a > i ? (a = J(e, i), l = 2 * i - a) : a < e && a < i && (a = K(e, i), l = 2 * i - a); l > o && l > i ? (l = J(o, i), a = 2 * i - l) : l < o && l < i && (l = K(o, i), a = 2 * i - l); t.rightContX = f; t.rightContY = l } n ? (t = ["C", s.rightContX || s.plotX, s.rightContY || s.plotY, u || r, a || i, r, i], s.rightContX = s.rightContY = null) : t = ["M", r, i]; return t } }); Ut.spline = Nn; on.areaspline = t(on.area); Cn = Cn.prototype; Nn = g(Nn, { type: "areaspline", closedStacks: !0, getSegmentPath: Cn.getSegmentPath, closeSegment: Cn.closeSegment, drawGraph: Cn.drawGraph, drawLegendSymbol: Xt.drawRectangle }); Ut.areaspline = Nn; on.column = t(Wt, { borderColor: "#FFFFFF", borderRadius: 0, groupPadding: .2, marker: null, pointPadding: .1, minPointLength: 0, cropThreshold: 50, pointRange: null, states: { hover: { brightness: .1, shadow: !1, halo: !1 }, select: { color: "#C0C0C0", borderColor: "#000000", shadow: !1 } }, dataLabels: { align: null, verticalAlign: null, y: null }, stickyTracking: !1, tooltip: { distance: 6 }, threshold: 0 }); Nn = g(Tn, { type: "column", pointAttrToOptions: { stroke: "borderColor", fill: "color", r: "borderRadius" }, cropShoulder: 0, trackerGroups: ["group", "dataLabelsGroup"], negStacks: !0, init: function () { Tn.prototype.init.apply(this, arguments); var e = this, t = e.chart; t.hasRendered && Kt(t.series, function (t) { if (t.type === e.type) t.isDirty = !0 }) }, getColumnMetrics: function () { var e = this, t = e.options, n = e.xAxis, r = e.yAxis, i = n.reversed, s, o = {}, u, a = 0; t.grouping === !1 ? a = 1 : Kt(e.chart.series, function (t) { var n = t.options, i = t.yAxis; if (t.type === e.type && t.visible && r.len === i.len && r.pos === i.pos) n.stacking ? (s = t.stackKey, o[s] === R && (o[s] = a++), u = o[s]) : n.grouping !== !1 && (u = a++), t.columnIndex = u }); var n = K(Q(n.transA) * (n.ordinalSlope || t.pointRange || n.closestPointRange || n.tickInterval || 1), n.len), f = n * t.groupPadding, l = (n - 2 * f) / a, h = t.pointWidth, t = c(h) ? (l - h) / 2 : l * t.pointPadding, h = d(h, l - 2 * t); return e.columnMetrics = { width: h, offset: t + (f + ((i ? a - (e.columnIndex || 0) : e.columnIndex) || 0) * l - n / 2) * (i ? -1 : 1) } }, translate: function () { var e = this, t = e.chart, n = e.options, r = e.borderWidth = d(n.borderWidth, e.activePointCount > .5 * e.xAxis.len ? 0 : 1), i = e.yAxis, s = e.translatedThreshold = i.getThreshold(n.threshold), o = d(n.minPointLength, 5), n = e.getColumnMetrics(), u = n.width, a = e.barW = $(J(u, 1 + 2 * r)), f = e.pointXOffset = n.offset, l = -(r % 2 ? .5 : 0), c = r % 2 ? .5 : 1; t.renderer.isVML && t.inverted && (c += 1); Tn.prototype.translate.apply(e); Kt(e.points, function (n) { var r = d(n.yBottom, s), h = K(J(-999 - r, n.plotY), i.len + 999 + r), p = n.plotX + f, v = a, m = K(h, r), g; g = J(h, r) - m; Q(g) < o && o && (g = o, m = X(Q(m - s) > o ? r - o : s - (i.translate(n.y, 0, 1, 0, 1) <= s ? o : 0))); n.barX = p; n.pointWidth = u; n.tooltipPos = t.inverted ? [i.len - h, e.xAxis.len - p - v / 2] : [p + v / 2, h]; r = Q(p) < .5; v = X(p + v) + l; p = X(p) + l; v -= p; h = Q(m) < .5; g = X(m + g) + c; m = X(m) + c; g -= m; r && (p += 1, v -= 1); h && (m -= 1, g += 1); n.shapeType = "rect"; n.shapeArgs = { x: p, y: m, width: v, height: g } }) }, getSymbol: St, drawLegendSymbol: Xt.drawRectangle, drawGraph: St, drawPoints: function () { var e = this, n = this.chart, r = e.options, i = n.renderer, s = r.animationLimit || 250, o, u, a; Kt(e.points, function (f) { var l = f.plotY, h = f.graphic; if (l !== R && !isNaN(l) && f.y !== null) o = f.shapeArgs, a = c(e.borderWidth) ? { "stroke-width": e.borderWidth } : {}, u = f.pointAttr[f.selected ? "select" : ""] || e.pointAttr[""], h ? (sn(h), h.attr(a)[n.pointCount < s ? "animate" : "attr"](t(o))) : f.graphic = i[f.shapeType](o).attr(u).attr(a).add(e.group).shadow(r.shadow, null, r.stacking && !r.borderRadius); else if (h) f.graphic = h.destroy() }) }, animate: function (e) { var t = this.yAxis, n = this.options, r = this.chart.inverted, i = {}; if (ft) e ? (i.scaleY = .001, e = K(t.pos + t.len, J(t.pos, t.toPixels(n.threshold))), r ? i.translateX = e - t.len : i.translateY = e, this.group.attr(i)) : (i.scaleY = 1, i[r ? "translateX" : "translateY"] = t.pos, this.group.animate(i, this.options.animation), this.animate = null) }, remove: function () { var e = this, t = e.chart; t.hasRendered && Kt(t.series, function (t) { if (t.type === e.type) t.isDirty = !0 }); Tn.prototype.remove.apply(e, arguments) } }); Ut.column = Nn; on.bar = t(on.column); Cn = g(Nn, { type: "bar", inverted: !0 }); Ut.bar = Cn; on.scatter = t(Wt, { lineWidth: 0, tooltip: { headerFormat: '<span style="color:{series.color}">●</span> <span style="font-size: 10px;"> {series.name}</span><br/>', pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>" }, stickyTracking: !1 }); Cn = g(Tn, { type: "scatter", sorted: !1, requireSorting: !1, noSharedTooltip: !0, trackerGroups: ["markerGroup"], takeOrdinalPosition: !1, singularTooltips: !0, drawGraph: function () { this.options.lineWidth && Tn.prototype.drawGraph.call(this) } }); Ut.scatter = Cn; on.pie = t(Wt, { borderColor: "#FFFFFF", borderWidth: 1, center: [null, null], clip: !1, colorByPoint: !0, dataLabels: { distance: 30, enabled: !0, formatter: function () { return this.point.name } }, ignoreHiddenPoint: !0, legendType: "point", marker: null, size: null, showInLegend: !1, slicedOffset: 10, states: { hover: { brightness: .1, shadow: !1 } }, stickyTracking: !1, tooltip: { followPointer: !0 } }); Wt = { type: "pie", isCartesian: !1, pointClass: g(xn, { init: function () { xn.prototype.init.apply(this, arguments); var t = this, n; if (t.y < 0) t.y = null; e(t, { visible: t.visible !== !1, name: d(t.name, "Slice") }); n = function (e) { t.slice(e.type === "select") }; Zt(t, "select", n); Zt(t, "unselect", n); return t }, setVisible: function (e) { var t = this, n = t.series, r = n.chart; t.visible = t.options.visible = e = e === R ? !t.visible : e; n.options.data[Jt(t, n.data)] = t.options; Kt(["graphic", "dataLabel", "connector", "shadowGroup"], function (n) { if (t[n]) t[n][e ? "show" : "hide"](!0) }); t.legendItem && r.legend.colorizeItem(t, e); if (!n.isDirty && n.options.ignoreHiddenPoint) n.isDirty = !0, r.redraw() }, slice: function (e, t, n) { var r = this.series; _(n, r.chart); d(t, !0); this.sliced = this.options.sliced = e = c(e) ? e : !this.sliced; r.options.data[Jt(this, r.data)] = this.options; e = e ? this.slicedTranslation : { translateX: 0, translateY: 0 }; this.graphic.animate(e); this.shadowGroup && this.shadowGroup.animate(e) }, haloPath: function (e) { var t = this.shapeArgs, n = this.series.chart; return this.series.chart.renderer.symbols.arc(n.plotLeft + t.x, n.plotTop + t.y, t.r + e, t.r + e, { innerR: this.shapeArgs.r, start: t.start, end: t.end }) } }), requireSorting: !1, noSharedTooltip: !0, trackerGroups: ["group", "dataLabelsGroup"], axisTypes: [], pointAttrToOptions: { stroke: "borderColor", "stroke-width": "borderWidth", fill: "color" }, singularTooltips: !0, getColor: St, animate: function (e) { var t = this, n = t.points, r = t.startAngleRad; if (!e) Kt(n, function (e) { var n = e.graphic, e = e.shapeArgs; n && (n.attr({ r: t.center[3] / 2, start: r, end: r }), n.animate({ r: e.r, start: e.start, end: e.end }, t.options.animation)) }), t.animate = null }, setData: function (e, t, n, r) { Tn.prototype.setData.call(this, e, !1, n, r); this.processData(); this.generatePoints(); d(t, !0) && this.chart.redraw(n) }, generatePoints: function () { var e, t = 0, n, r, i, s = this.options.ignoreHiddenPoint; Tn.prototype.generatePoints.call(this); n = this.points; r = n.length; for (e = 0; e < r; e++) i = n[e], t += s && !i.visible ? 0 : i.y; this.total = t; for (e = 0; e < r; e++) i = n[e], i.percentage = t > 0 ? i.y / t * 100 : 0, i.total = t }, translate: function (e) { this.generatePoints(); var t = 0, n = this.options, r = n.slicedOffset, i = r + n.borderWidth, s, o, u, a = n.startAngle || 0, f = this.startAngleRad = Z / 180 * (a - 90), a = (this.endAngleRad = Z / 180 * (d(n.endAngle, a + 360) - 90)) - f, l = this.points, c = n.dataLabels.distance, n = n.ignoreHiddenPoint, h, p = l.length, v; if (!e) this.center = e = this.getCenter(); this.getX = function (t, n) { u = W.asin(K((t - e[1]) / (e[2] / 2 + c), 1)); return e[0] + (n ? -1 : 1) * G(u) * (e[2] / 2 + c) }; for (h = 0; h < p; h++) { v = l[h]; s = f + t * a; if (!n || v.visible) t += v.percentage / 100; o = f + t * a; v.shapeType = "arc"; v.shapeArgs = { x: e[0], y: e[1], r: e[2] / 2, innerR: e[3] / 2, start: X(s * 1e3) / 1e3, end: X(o * 1e3) / 1e3 }; u = (o + s) / 2; u > 1.5 * Z ? u -= 2 * Z : u < -Z / 2 && (u += 2 * Z); v.slicedTranslation = { translateX: X(G(u) * r), translateY: X(Y(u) * r) }; s = G(u) * e[2] / 2; o = Y(u) * e[2] / 2; v.tooltipPos = [e[0] + s * .7, e[1] + o * .7]; v.half = u < -Z / 2 || u > Z / 2 ? 1 : 0; v.angle = u; i = K(i, c / 2); v.labelPos = [e[0] + s + G(u) * c, e[1] + o + Y(u) * c, e[0] + s + G(u) * i, e[1] + o + Y(u) * i, e[0] + s, e[1] + o, c < 0 ? "center" : v.half ? "right" : "left", u] } }, drawGraph: null, drawPoints: function () { var t = this, n = t.chart.renderer, r, i, s = t.options.shadow, o, u; if (s && !t.shadowGroup) t.shadowGroup = n.g("shadow").add(t.group); Kt(t.points, function (a) { i = a.graphic; u = a.shapeArgs; o = a.shadowGroup; if (s && !o) o = a.shadowGroup = n.g("shadow").add(t.shadowGroup); r = a.sliced ? a.slicedTranslation : { translateX: 0, translateY: 0 }; o && o.attr(r); i ? i.animate(e(u, r)) : a.graphic = i = n[a.shapeType](u).setRadialReference(t.center).attr(a.pointAttr[a.selected ? "select" : ""]).attr({ "stroke-linejoin": "round" }).attr(r).add(t.group).shadow(s, o); a.visible !== void 0 && a.setVisible(a.visible) }) }, sortByAngle: function (e, t) { e.sort(function (e, n) { return e.angle !== void 0 && (n.angle - e.angle) * t }) }, drawLegendSymbol: Xt.drawRectangle, getCenter: pn.getCenter, getSymbol: St }; Wt = g(Tn, Wt); Ut.pie = Wt; Tn.prototype.drawDataLabels = function () { var n = this, r = n.options, i = r.cursor, s = r.dataLabels, o = n.points, u, a, f, l; if (s.enabled || n._hasPointLabels) n.dlProcessOptions && n.dlProcessOptions(s), l = n.plotGroup("dataLabelsGroup", "data-labels", "hidden", s.zIndex || 6), !n.hasRendered && d(s.defer, !0) && (l.attr({ opacity: 0 }), Zt(n, "afterAnimate", function () { n.dataLabelsGroup.show()[r.animation ? "animate" : "attr"]({ opacity: 1 }, { duration: 200 }) })), a = s, Kt(o, function (r) { var o, h = r.dataLabel, p, v, m = r.connector, g = !0; u = r.options && r.options.dataLabels; o = d(u && u.enabled, a.enabled); if (h && !o) r.dataLabel = h.destroy(); else if (o) { s = t(a, u); o = s.rotation; p = r.getLabelConfig(); f = s.format ? E(s.format, p) : s.formatter.call(p, s); s.style.color = d(s.color, s.style.color, n.color, "black"); if (h) if (c(f)) h.attr({ text: f }), g = !1; else { if (r.dataLabel = h = h.destroy(), m) r.connector = m.destroy() } else if (c(f)) { h = { fill: s.backgroundColor, stroke: s.borderColor, "stroke-width": s.borderWidth, r: s.borderRadius || 0, rotation: o, padding: s.padding, zIndex: 1 }; for (v in h) h[v] === R && delete h[v]; h = r.dataLabel = n.chart.renderer[o ? "text" : "label"](f, 0, -999, null, null, null, s.useHTML).attr(h).css(e(s.style, i && { cursor: i })).add(l).shadow(s.shadow) } h && n.alignDataLabel(r, h, s, null, g) } }) }; Tn.prototype.alignDataLabel = function (t, n, r, i, s) { var o = this.chart, u = o.inverted, a = d(t.plotX, -999), f = d(t.plotY, -999), l = n.getBBox(); if (t = this.visible && (t.series.forceDL || o.isInsidePlot(a, X(f), u) || i && o.isInsidePlot(a, u ? i.x + 1 : i.y + i.height - 1, u))) i = e({ x: u ? o.plotWidth - f : a, y: X(u ? o.plotHeight - a : f), width: 0, height: 0 }, i), e(r, { width: l.width, height: l.height }), r.rotation ? (u = { align: r.align, x: i.x + r.x + i.width / 2, y: i.y + r.y + i.height / 2 }, n[s ? "attr" : "animate"](u)) : (n.align(r, null, i), u = n.alignAttr, d(r.overflow, "justify") === "justify" ? this.justifyDataLabel(n, r, u, l, i, s) : d(r.crop, !0) && (t = o.isInsidePlot(u.x, u.y) && o.isInsidePlot(u.x + l.width, u.y + l.height))); if (!t) n.attr({ y: -999 }), n.placed = !1 }; Tn.prototype.justifyDataLabel = function (e, t, n, r, i, s) { var o = this.chart, u = t.align, a = t.verticalAlign, f, l; f = n.x; if (f < 0) u === "right" ? t.align = "left" : t.x = -f, l = !0; f = n.x + r.width; if (f > o.plotWidth) u === "left" ? t.align = "right" : t.x = o.plotWidth - f, l = !0; f = n.y; if (f < 0) a === "bottom" ? t.verticalAlign = "top" : t.y = -f, l = !0; f = n.y + r.height; if (f > o.plotHeight) a === "top" ? t.verticalAlign = "bottom" : t.y = o.plotHeight - f, l = !0; if (l) e.placed = !s, e.align(t, null, i) }; if (Ut.pie) Ut.pie.prototype.drawDataLabels = function () { var e = this, t = e.data, n, r = e.chart, i = e.options.dataLabels, s = d(i.connectorPadding, 10), o = d(i.connectorWidth, 1), u = r.plotWidth, r = r.plotHeight, a, f, l = d(i.softConnector, !0), c = i.distance, h = e.center, p = h[2] / 2, v = h[1], m = c > 0, g, y, b, w, E = [[], []], S, x, T, N, C, L = [0, 0, 0, 0], A = function (e, t) { return t.y - e.y }; if (e.visible && (i.enabled || e._hasPointLabels)) { Tn.prototype.drawDataLabels.apply(e); Kt(t, function (e) { e.dataLabel && e.visible && E[e.half].push(e) }); for (N = 0; !w && t[N];) w = t[N] && t[N].dataLabel && (t[N].dataLabel.getBBox().height || 21), N++; for (N = 2; N--;) { var t = [], O = [], M = E[N], _ = M.length, D; e.sortByAngle(M, N - .5); if (c > 0) { for (C = v - p - c; C <= v + p + c; C += w) t.push(C); y = t.length; if (_ > y) { n = [].concat(M); n.sort(A); for (C = _; C--;) n[C].rank = C; for (C = _; C--;) M[C].rank >= y && M.splice(C, 1); _ = M.length } for (C = 0; C < _; C++) { n = M[C]; b = n.labelPos; n = 9999; var P, H; for (H = 0; H < y; H++) P = Q(t[H] - b[1]), P < n && (n = P, D = H); if (D < C && t[C] !== null) D = C; else for (y < _ - C + D && t[C] !== null && (D = y - _ + C) ; t[D] === null;) D++; O.push({ i: D, y: t[D] }); t[D] = null } O.sort(A) } for (C = 0; C < _; C++) { n = M[C]; b = n.labelPos; g = n.dataLabel; T = n.visible === !1 ? "hidden" : "visible"; n = b[1]; if (c > 0) { if (y = O.pop(), D = y.i, x = y.y, n > x && t[D + 1] !== null || n < x && t[D - 1] !== null) x = n } else x = n; S = i.justify ? h[0] + (N ? -1 : 1) * (p + c) : e.getX(D === 0 || D === t.length - 1 ? n : x, N); g._attr = { visibility: T, align: b[6] }; g._pos = { x: S + i.x + ({ left: s, right: -s }[b[6]] || 0), y: x + i.y - 10 }; g.connX = S; g.connY = x; if (this.options.size === null) y = g.width, S - y < s ? L[3] = J(X(y - S + s), L[3]) : S + y > u - s && (L[1] = J(X(S + y - u + s), L[1])), x - w / 2 < 0 ? L[0] = J(X(-x + w / 2), L[0]) : x + w / 2 > r && (L[2] = J(X(x + w / 2 - r), L[2])) } } if (k(L) === 0 || this.verifyDataLabelOverflow(L)) this.placeDataLabels(), m && o && Kt(this.points, function (t) { a = t.connector; b = t.labelPos; if ((g = t.dataLabel) && g._pos) T = g._attr.visibility, S = g.connX, x = g.connY, f = l ? ["M", S + (b[6] === "left" ? 5 : -5), x, "C", S, x, 2 * b[2] - b[4], 2 * b[3] - b[5], b[2], b[3], "L", b[4], b[5]] : ["M", S + (b[6] === "left" ? 5 : -5), x, "L", b[2], b[3], "L", b[4], b[5]], a ? (a.animate({ d: f }), a.attr("visibility", T)) : t.connector = a = e.chart.renderer.path(f).attr({ "stroke-width": o, stroke: i.connectorColor || t.color || "#606060", visibility: T }).add(e.dataLabelsGroup); else if (a) t.connector = a.destroy() }) } }, Ut.pie.prototype.placeDataLabels = function () { Kt(this.points, function (e) { var e = e.dataLabel, t; if (e) (t = e._pos) ? (e.attr(e._attr), e[e.moved ? "animate" : "attr"](t), e.moved = !0) : e && e.attr({ y: -999 }) }) }, Ut.pie.prototype.alignDataLabel = St, Ut.pie.prototype.verifyDataLabelOverflow = function (e) { var t = this.center, n = this.options, r = n.center, i = n = n.minSize || 80, s; r[0] !== null ? i = J(t[2] - J(e[1], e[3]), n) : (i = J(t[2] - e[1] - e[3], n), t[0] += (e[3] - e[1]) / 2); r[1] !== null ? i = J(K(i, t[2] - J(e[0], e[2])), n) : (i = J(K(i, t[2] - e[0] - e[2]), n), t[1] += (e[0] - e[2]) / 2); i < t[2] ? (t[2] = i, this.translate(t), Kt(this.points, function (e) { if (e.dataLabel) e.dataLabel._pos = null }), this.drawDataLabels && this.drawDataLabels()) : s = !0; return s }; if (Ut.column) Ut.column.prototype.alignDataLabel = function (e, n, r, i, s) { var o = this.chart, u = o.inverted, a = e.dlBox || e.shapeArgs, f = e.below || e.plotY > d(this.translatedThreshold, o.plotSizeY), l = d(r.inside, !!this.options.stacking); if (a && (i = t(a), u && (i = { x: o.plotWidth - i.y - i.height, y: o.plotHeight - i.x - i.width, width: i.height, height: i.width }), !l)) u ? (i.x += f ? 0 : i.width, i.width = 0) : (i.y += f ? i.height : 0, i.height = 0); r.align = d(r.align, !u || l ? "center" : f ? "right" : "left"); r.verticalAlign = d(r.verticalAlign, u || l ? "middle" : f ? "top" : "bottom"); Tn.prototype.alignDataLabel.call(this, e, n, r, i, s) }; var kn = zt.TrackerMixin = { drawTrackerPoint: function () { var e = this, t = e.chart, n = t.pointer, r = e.options.cursor, i = r && { cursor: r }, s = function (n) { var r = n.target, i; if (t.hoverSeries !== e) e.onMouseOver(); for (; r && !i;) i = r.point, r = r.parentNode; if (i !== R && i !== t.hoverPoint) i.onMouseOver(n) }; Kt(e.points, function (e) { if (e.graphic) e.graphic.element.point = e; if (e.dataLabel) e.dataLabel.element.point = e }); if (!e._hasTracking) Kt(e.trackerGroups, function (t) { if (e[t] && (e[t].addClass("highcharts-tracker").on("mouseover", s).on("mouseout", function (e) { n.onTrackerMouseOut(e) }).css(i), pt)) e[t].on("touchstart", s) }), e._hasTracking = !0 }, drawTrackerGraph: function () { var e = this, t = e.options, n = t.trackByArea, r = [].concat(n ? e.areaPath : e.graphPath), i = r.length, s = e.chart, o = s.pointer, u = s.renderer, a = s.options.tooltip.snap, f = e.tracker, l = t.cursor, c = l && { cursor: l }, l = e.singlePoints, h, p = function () { if (s.hoverSeries !== e) e.onMouseOver() }, d = "rgba(192,192,192," + (ft ? 1e-4 : .002) + ")"; if (i && !n) for (h = i + 1; h--;) r[h] === "M" && r.splice(h + 1, 0, r[h + 1] - a, r[h + 2], "L"), (h && r[h] === "M" || h === i) && r.splice(h, 0, "L", r[h - 2] + a, r[h - 1]); for (h = 0; h < l.length; h++) i = l[h], r.push("M", i.plotX - a, i.plotY, "L", i.plotX + a, i.plotY); f ? f.attr({ d: r }) : (e.tracker = u.path(r).attr({ "stroke-linejoin": "round", visibility: e.visible ? "visible" : "hidden", stroke: d, fill: n ? d : Ct, "stroke-width": t.lineWidth + (n ? 0 : 2 * a), zIndex: 2 }).add(e.group), Kt([e.tracker, e.markerGroup], function (e) { e.addClass("highcharts-tracker").on("mouseover", p).on("mouseout", function (e) { o.onTrackerMouseOut(e) }).css(c); if (pt) e.on("touchstart", p) })) } }; if (Ut.column) Nn.prototype.drawTracker = kn.drawTrackerPoint; if (Ut.pie) Ut.pie.prototype.drawTracker = kn.drawTrackerPoint; if (Ut.scatter) Cn.prototype.drawTracker = kn.drawTrackerPoint; e(Sn.prototype, { setItemEvents: function (e, t, n, r, i) { var s = this; (n ? t : e.legendGroup).on("mouseover", function () { e.setState("hover"); t.css(s.options.itemHoverStyle) }).on("mouseout", function () { t.css(e.visible ? r : i); e.setState() }).on("click", function (t) { var n = function () { e.setVisible() }, t = { browserEvent: t }; e.firePointEvent ? e.firePointEvent("legendItemClick", t, n) : tn(e, "legendItemClick", t, n) }) }, createCheckboxForItem: function (e) { e.checkbox = m("input", { type: "checkbox", checked: e.selected, defaultChecked: e.selected }, this.options.itemCheckboxStyle, this.chart.container); Zt(e.checkbox, "click", function (t) { tn(e, "checkboxClick", { checked: t.target.checked }, function () { e.select() }) }) } }); gt.legend.itemStyle.cursor = "pointer"; e(j.prototype, { showResetZoom: function () { var e = this, t = gt.lang, n = e.options.chart.resetZoomButton, r = n.theme, i = r.states, s = n.relativeTo === "chart" ? null : "plotBox"; this.resetZoomButton = e.renderer.button(t.resetZoom, null, null, function () { e.zoomOut() }, r, i && i.hover).attr({ align: n.position.align, title: t.resetZoomTitle }).add().align(n.position, !1, s) }, zoomOut: function () { var e = this; tn(e, "selection", { resetSelection: !0 }, function () { e.zoom() }) }, zoom: function (e) { var t, n = this.pointer, r = !1, i; !e || e.resetSelection ? Kt(this.axes, function (e) { t = e.zoom() }) : Kt(e.xAxis.concat(e.yAxis), function (e) { var i = e.axis, s = i.isXAxis; if (n[s ? "zoomX" : "zoomY"] || n[s ? "pinchX" : "pinchY"]) t = i.zoom(e.min, e.max), i.displayBtn && (r = !0) }); i = this.resetZoomButton; if (r && !i) this.showResetZoom(); else if (!r && s(i)) this.resetZoomButton = i.destroy(); t && this.redraw(d(this.options.chart.animation, e && e.animation, this.pointCount < 100)) }, pan: function (e, t) { var n = this, r = n.hoverPoints, i; r && Kt(r, function (e) { e.setState() }); Kt(t === "xy" ? [1, 0] : [1], function (t) { var r = e[t ? "chartX" : "chartY"], s = n[t ? "xAxis" : "yAxis"][0], o = n[t ? "mouseDownX" : "mouseDownY"], u = (s.pointRange || 0) / 2, a = s.getExtremes(), f = s.toValue(o - r, !0) + u, o = s.toValue(o + n[t ? "plotWidth" : "plotHeight"] - r, !0) - u; s.series.length && f > K(a.dataMin, a.min) && o < J(a.dataMax, a.max) && (s.setExtremes(f, o, !1, !1, { trigger: "pan" }), i = !0); n[t ? "mouseDownX" : "mouseDownY"] = r }); i && n.redraw(!1); v(n.container, { cursor: "move" }) } }); e(xn.prototype, { select: function (e, t) { var n = this, r = n.series, i = r.chart, e = d(e, !n.selected); n.firePointEvent(e ? "select" : "unselect", { accumulate: t }, function () { n.selected = n.options.selected = e; r.options.data[Jt(n, r.data)] = n.options; n.setState(e && "select"); t || Kt(i.getSelectedPoints(), function (e) { if (e.selected && e !== n) e.selected = e.options.selected = !1, r.options.data[Jt(e, r.data)] = e.options, e.setState(""), e.firePointEvent("unselect") }) }) }, onMouseOver: function (e) { var t = this.series, n = t.chart, r = n.tooltip, i = n.hoverPoint; if (i && i !== this) i.onMouseOut(); this.firePointEvent("mouseOver"); r && (!r.shared || t.noSharedTooltip) && r.refresh(this, e); this.setState("hover"); n.hoverPoint = this }, onMouseOut: function () { var e = this.series.chart, t = e.hoverPoints; if (!t || Jt(this, t) === -1) this.firePointEvent("mouseOut"), this.setState(), e.hoverPoint = null }, importEvents: function () { if (!this.hasImportedEvents) { var e = t(this.series.options.point, this.options).events, n; this.events = e; for (n in e) Zt(this, n, e[n]); this.hasImportedEvents = !0 } }, setState: function (n, r) { var i = this.plotX, s = this.plotY, o = this.series, u = o.options.states, a = on[o.type].marker && o.options.marker, f = a && !a.enabled, l = a && a.states[n], c = l && l.enabled === !1, h = o.stateMarkerGraphic, p = this.marker || {}, d = o.chart, v = o.halo, m, n = n || ""; m = this.pointAttr[n] || o.pointAttr[n]; if (!(n === this.state && !r || this.selected && n !== "select" || u[n] && u[n].enabled === !1 || n && (c || f && l.enabled === !1) || n && p.states && p.states[n] && p.states[n].enabled === !1)) { if (this.graphic) a = a && this.graphic.symbolName && m.r, this.graphic.attr(t(m, a ? { x: i - a, y: s - a, width: 2 * a, height: 2 * a } : {})), h && h.hide(); else { if (n && l) if (a = l.radius, p = p.symbol || o.symbol, h && h.currentSymbol !== p && (h = h.destroy()), h) h[r ? "animate" : "attr"]({ x: i - a, y: s - a }); else if (p) o.stateMarkerGraphic = h = d.renderer.symbol(p, i - a, s - a, 2 * a, 2 * a).attr(m).add(o.markerGroup), h.currentSymbol = p; if (h) h[n && d.isInsidePlot(i, s, d.inverted) ? "show" : "hide"]() } if ((i = u[n] && u[n].halo) && i.size) { if (!v) o.halo = v = d.renderer.path().add(o.seriesGroup); v.attr(e({ fill: ln(this.color || o.color).setOpacity(i.opacity).get() }, i.attributes))[r ? "animate" : "attr"]({ d: this.haloPath(i.size) }) } else v && v.attr({ d: [] }); this.state = n } }, haloPath: function (e) { var t = this.series, n = t.chart, r = t.getPlotBox(), i = n.inverted; return n.renderer.symbols.circle(r.translateX + (i ? t.yAxis.len - this.plotY : this.plotX) - e, r.translateY + (i ? t.xAxis.len - this.plotX : this.plotY) - e, e * 2, e * 2) } }); e(Tn.prototype, { onMouseOver: function () { var e = this.chart, t = e.hoverSeries; if (t && t !== this) t.onMouseOut(); this.options.events.mouseOver && tn(this, "mouseOver"); this.setState("hover"); e.hoverSeries = this }, onMouseOut: function () { var e = this.options, t = this.chart, n = t.tooltip, r = t.hoverPoint; if (r) r.onMouseOut(); this && e.events.mouseOut && tn(this, "mouseOut"); n && !e.stickyTracking && (!n.shared || this.noSharedTooltip) && n.hide(); this.setState(); t.hoverSeries = null }, setState: function (e) { var t = this.options, n = this.graph, r = this.graphNeg, i = t.states, t = t.lineWidth, e = e || ""; if (this.state !== e) this.state = e, i[e] && i[e].enabled === !1 || (e && (t = i[e].lineWidth || t + 1), n && !n.dashstyle && (e = { "stroke-width": t }, n.attr(e), r && r.attr(e))) }, setVisible: function (e, t) { var n = this, r = n.chart, i = n.legendItem, s, o = r.options.chart.ignoreHiddenSeries, u = n.visible; s = (n.visible = e = n.userOptions.visible = e === R ? !u : e) ? "show" : "hide"; Kt(["group", "dataLabelsGroup", "markerGroup", "tracker"], function (e) { if (n[e]) n[e][s]() }); if (r.hoverSeries === n) n.onMouseOut(); i && r.legend.colorizeItem(n, e); n.isDirty = !0; n.options.stacking && Kt(r.series, function (e) { if (e.options.stacking && e.visible) e.isDirty = !0 }); Kt(n.linkedSeries, function (t) { t.setVisible(e, !1) }); if (o) r.isDirtyBox = !0; t !== !1 && r.redraw(); tn(n, s) }, setTooltipPoints: function (e) { var t = [], n, r, i = this.xAxis, s = i && i.getExtremes(), o = i ? i.tooltipLen || i.len : this.chart.plotSizeX, u, a, f = []; if (!(this.options.enableMouseTracking === !1 || this.singularTooltips)) { if (e) this.tooltipPoints = null; Kt(this.segments || this.points, function (e) { t = t.concat(e) }); i && i.reversed && (t = t.reverse()); this.orderTooltipPoints && this.orderTooltipPoints(t); e = t.length; for (a = 0; a < e; a++) if (i = t[a], n = i.x, n >= s.min && n <= s.max) { u = t[a + 1]; n = r === R ? 0 : r + 1; for (r = t[a + 1] ? K(J(0, V((i.clientX + (u ? u.wrappedClientX || u.clientX : o)) / 2)), o) : o; n >= 0 && n <= r;) f[n++] = i } this.tooltipPoints = f } }, show: function () { this.setVisible(!0) }, hide: function () { this.setVisible(!1) }, select: function (e) { this.selected = e = e === R ? !this.selected : e; if (this.checkbox) this.checkbox.checked = e; tn(this, e ? "select" : "unselect") }, drawTracker: kn.drawTrackerGraph }); w(Tn.prototype, "init", function (e) { var t; e.apply(this, Array.prototype.slice.call(arguments, 1)); (t = this.xAxis) && t.options.ordinal && Zt(this, "updatedData", function () { delete t.ordinalIndex }) }); w(B.prototype, "getTimeTicks", function (e, t, n, r, i, s, o, u) { var a = 0, f = 0, l, h = {}, p, d, v, m = [], g = -Number.MAX_VALUE, y = this.options.tickPixelInterval; if (!this.options.ordinal || !s || s.length < 3 || n === R) return e.call(this, t, n, r, i); for (d = s.length; f < d; f++) { v = f && s[f - 1] > r; s[f] < n && (a = f); if (f === d - 1 || s[f + 1] - s[f] > o * 5 || v) { if (s[f] > g) { for (l = e.call(this, t, s[a], s[f], i) ; l.length && l[0] <= g;) l.shift(); l.length && (g = l[l.length - 1]); m = m.concat(l) } a = f + 1 } if (v) break } e = l.info; if (u && e.unitRange <= Et.hour) { f = m.length - 1; for (a = 1; a < f; a++) (new Date(m[a] - Ot))[Pt]() !== (new Date(m[a - 1] - Ot))[Pt]() && (h[m[a]] = "day", p = !0); p && (h[m[0]] = "day"); e.higherRanks = h } m.info = e; if (u && c(y)) { var u = e = m.length, f = [], b; for (p = []; u--;) a = this.translate(m[u]), b && (p[u] = b - a), f[u] = b = a; p.sort(); p = p[V(p.length / 2)]; p < y * .6 && (p = null); u = m[e - 1] > r ? e - 1 : e; for (b = void 0; u--;) a = f[u], r = b - a, b && r < y * .8 && (p === null || r < p * .8) ? (h[m[u]] && !h[m[u + 1]] ? (r = u + 1, b = a) : r = u, m.splice(r, 1)) : b = a } return m }); e(B.prototype, { beforeSetTickPositions: function () { var e, t = [], n = !1, r, i = this.getExtremes(), s = i.min, i = i.max, o; if (this.options.ordinal) { Kt(this.series, function (n, r) { if (n.visible !== !1 && n.takeOrdinalPosition !== !1 && (t = t.concat(n.processedXData), e = t.length, t.sort(function (e, t) { return e - t }), e)) for (r = e - 1; r--;) t[r] === t[r + 1] && t.splice(r, 1) }); e = t.length; if (e > 2) { r = t[1] - t[0]; for (o = e - 1; o-- && !n;) t[o + 1] - t[o] !== r && (n = !0); if (!this.options.keepOrdinalPadding && (t[0] - s > r || i - t[t.length - 1] > r)) n = !0 } n ? (this.ordinalPositions = t, n = this.val2lin(J(s, t[0]), !0), r = this.val2lin(K(i, t[t.length - 1]), !0), this.ordinalSlope = i = (i - s) / (r - n), this.ordinalOffset = s - n * i) : this.ordinalPositions = this.ordinalSlope = this.ordinalOffset = R } this.groupIntervalFactor = null }, val2lin: function (e, t) { var n = this.ordinalPositions; if (n) { var r = n.length, i, s; for (i = r; i--;) if (n[i] === e) { s = i; break } for (i = r - 1; i--;) if (e > n[i] || i === 0) { n = (e - n[i]) / (n[i + 1] - n[i]); s = i + n; break } return t ? s : this.ordinalSlope * (s || 0) + this.ordinalOffset } else return e }, lin2val: function (e, t) { var n = this.ordinalPositions; if (n) { var r = this.ordinalSlope, i = this.ordinalOffset, s = n.length - 1, o, u; if (t) e < 0 ? e = n[0] : e > s ? e = n[s] : (s = V(e), u = e - s); else for (; s--;) if (o = r * s + i, e >= o) { r = r * (s + 1) + i; u = (e - o) / (r - o); break } return u !== R && n[s] !== R ? n[s] + (u ? u * (n[s + 1] - n[s]) : 0) : e } else return e }, getExtendedPositions: function () { var e = this.chart, t = this.series[0].currentDataGrouping, n = this.ordinalIndex, r = t ? t.count + t.unitName : "raw", i = this.getExtremes(), s, o; if (!n) n = this.ordinalIndex = {}; if (!n[r]) s = { series: [], getExtremes: function () { return { min: i.dataMin, max: i.dataMax } }, options: { ordinal: !0 }, val2lin: B.prototype.val2lin }, Kt(this.series, function (n) { o = { xAxis: s, xData: n.xData, chart: e, destroyGroupedData: St }; o.options = { dataGrouping: t ? { enabled: !0, forced: !0, approximation: "open", units: [[t.unitName, [t.count]]] } : { enabled: !1 } }; n.processData.apply(o); s.series.push(o) }), this.beforeSetTickPositions.apply(s), n[r] = s.ordinalPositions; return n[r] }, getGroupIntervalFactor: function (e, t, n) { var r = 0, n = n.processedXData, i = n.length, s = [], o = this.groupIntervalFactor; if (!o) { for (; r < i - 1; r++) s[r] = n[r + 1] - n[r]; s.sort(function (e, t) { return e - t }); r = s[V(i / 2)]; e = J(e, n[0]); t = K(t, n[i - 1]); this.groupIntervalFactor = o = i * r / (t - e) } return o }, postProcessTickInterval: function (e) { var t = this.ordinalSlope; return t ? e / (t / this.closestPointRange) : e } }); w(j.prototype, "pan", function (e, t) { var n = this.xAxis[0], r = t.chartX, i = !1; if (n.options.ordinal && n.series.length) { var s = this.mouseDownX, o = n.getExtremes(), u = o.dataMax, a = o.min, f = o.max, l = this.hoverPoints, c = n.closestPointRange, s = (s - r) / (n.translationSlope * (n.ordinalSlope || c)), h = { ordinalPositions: n.getExtendedPositions() }, c = n.lin2val, p = n.val2lin, d; if (h.ordinalPositions) { if (Q(s) > 1) l && Kt(l, function (e) { e.setState() }), s < 0 ? (l = h, d = n.ordinalPositions ? n : h) : (l = n.ordinalPositions ? n : h, d = h), h = d.ordinalPositions, u > h[h.length - 1] && h.push(u), this.fixedRange = f - a, s = n.toFixedRange(null, null, c.apply(l, [p.apply(l, [a, !0]) + s, !0]), c.apply(d, [p.apply(d, [f, !0]) + s, !0])), s.min >= K(o.dataMin, a) && s.max <= J(u, f) && n.setExtremes(s.min, s.max, !0, !1, { trigger: "pan" }), this.mouseDownX = r, v(this.container, { cursor: "move" }) } else i = !0 } else i = !0; i && e.apply(this, Array.prototype.slice.call(arguments, 1)) }); w(Tn.prototype, "getSegments", function (e) { var t, n = this.options.gapSize, r = this.xAxis; e.apply(this, Array.prototype.slice.call(arguments, 1)); if (n) t = this.segments, Kt(t, function (e, i) { for (var s = e.length - 1; s--;) e[s + 1].x - e[s].x > r.closestPointRange * n && t.splice(i + 1, 0, e.splice(s + 1, e.length - s)) }) }); var Ln = Tn.prototype, Wt = vn.prototype, An = Ln.processData, On = Ln.generatePoints, Mn = Ln.destroy, _n = Wt.tooltipHeaderFormatter, Dn = { approximation: "average", groupPixelWidth: 2, dateTimeLabelFormats: n("millisecond", ["%A, %b %e, %H:%M:%S.%L", "%A, %b %e, %H:%M:%S.%L", "-%H:%M:%S.%L"], "second", ["%A, %b %e, %H:%M:%S", "%A, %b %e, %H:%M:%S", "-%H:%M:%S"], "minute", ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"], "hour", ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"], "day", ["%A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"], "week", ["Week from %A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"], "month", ["%B %Y", "%B", "-%B %Y"], "year", ["%Y", "%Y", "-%Y"]) }, Pn = { line: {}, spline: {}, area: {}, areaspline: {}, column: { approximation: "sum", groupPixelWidth: 10 }, arearange: { approximation: "range" }, areasplinerange: { approximation: "range" }, columnrange: { approximation: "range", groupPixelWidth: 10 }, candlestick: { approximation: "ohlc", groupPixelWidth: 10 }, ohlc: { approximation: "ohlc", groupPixelWidth: 5 } }, Hn = [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1]], ["week", [1]], ["month", [1, 3, 6]], ["year", null]], Bn = { sum: function (e) { var t = e.length, n; if (!t && e.hasNulls) n = null; else if (t) for (n = 0; t--;) n += e[t]; return n }, average: function (e) { var t = e.length, e = Bn.sum(e); typeof e === "number" && t && (e /= t); return e }, open: function (e) { return e.length ? e[0] : e.hasNulls ? null : R }, high: function (e) { return e.length ? k(e) : e.hasNulls ? null : R }, low: function (e) { return e.length ? C(e) : e.hasNulls ? null : R }, close: function (e) { return e.length ? e[e.length - 1] : e.hasNulls ? null : R }, ohlc: function (e, t, n, r) { e = Bn.open(e); t = Bn.high(t); n = Bn.low(n); r = Bn.close(r); if (typeof e === "number" || typeof t === "number" || typeof n === "number" || typeof r === "number") return [e, t, n, r] }, range: function (e, t) { e = Bn.low(e); t = Bn.high(t); if (typeof e === "number" || typeof t === "number") return [e, t] } }; Ln.groupData = function (e, t, n, r) { var i = this.data, s = this.options.data, o = [], u = [], a = e.length, f, l, c = !!t, h = [[], [], [], []], r = typeof r === "function" ? r : Bn[r], p = this.pointArrayMap, d = p && p.length, v; for (v = 0; v <= a; v++) if (e[v] >= n[0]) break; for (; v <= a; v++) { for (; n[1] !== R && e[v] >= n[1] || v === a;) if (f = n.shift(), l = r.apply(0, h), l !== R && (o.push(f), u.push(l)), h[0] = [], h[1] = [], h[2] = [], h[3] = [], v === a) break; if (v === a) break; if (p) { f = this.cropStart + v; f = i && i[f] || this.pointClass.prototype.applyOptions.apply({ series: this }, [s[f]]); var m; for (l = 0; l < d; l++) if (m = f[p[l]], typeof m === "number") h[l].push(m); else if (m === null) h[l].hasNulls = !0 } else if (f = c ? t[v] : null, typeof f === "number") h[0].push(f); else if (f === null) h[0].hasNulls = !0 } return [o, u] }; Ln.processData = function () { var e = this.chart, t = this.options, n = t.dataGrouping, r = n && d(n.enabled, e.options._stock), i; this.forceCrop = r; this.groupPixelWidth = null; this.hasProcessed = !0; if (An.apply(this, arguments) !== !1 && r) { this.destroyGroupedData(); var s = this.processedXData, o = this.processedYData, u = e.plotSizeX, e = this.xAxis, a = e.options.ordinal, f = this.groupPixelWidth = e.getGroupPixelWidth && e.getGroupPixelWidth(), r = this.pointRange; if (f) { i = !0; this.points = null; var l = e.getExtremes(), r = l.min, l = l.max, a = a && e.getGroupIntervalFactor(r, l, this) || 1, u = f * (l - r) / u * a, f = e.getTimeTicks(e.normalizeTimeTickInterval(u, n.units || Hn), r, l, null, s, this.closestPointRange), o = Ln.groupData.apply(this, [s, o, f, n.approximation]), s = o[0], o = o[1]; if (n.smoothed) { n = s.length - 1; for (s[n] = l; n-- && n > 0;) s[n] += u / 2; s[0] = r } this.currentDataGrouping = f.info; if (t.pointRange === null) this.pointRange = f.info.totalRange; this.closestPointRange = f.info.totalRange; if (c(s[0]) && s[0] < e.dataMin) e.dataMin = s[0]; this.processedXData = s; this.processedYData = o } else this.currentDataGrouping = null, this.pointRange = r; this.hasGroupedData = i } }; Ln.destroyGroupedData = function () { var e = this.groupedData; Kt(e || [], function (t, n) { t && (e[n] = t.destroy ? t.destroy() : null) }); this.groupedData = null }; Ln.generatePoints = function () { On.apply(this); this.destroyGroupedData(); this.groupedData = this.hasGroupedData ? this.points : null }; Wt.tooltipHeaderFormatter = function (e) { var t = e.series, n = t.tooltipOptions, r = t.options.dataGrouping, i = n.xDateFormat, s, o = t.xAxis, a; if (o && o.options.type === "datetime" && r && u(e.key)) { t = t.currentDataGrouping; r = r.dateTimeLabelFormats; if (t) o = r[t.unitName], t.count === 1 ? i = o[0] : (i = o[1], s = o[2]); else if (!i && r) for (a in Et) if (Et[a] >= o.closestPointRange || Et[a] <= Et.day && e.key % Et[a] > 0) { i = r[a][0]; break } i = yt(i, e.key); s && (i += yt(s, e.key + t.totalRange - 1)); e = n.headerFormat.replace("{point.key}", i) } else e = _n.call(this, e); return e }; Ln.destroy = function () { for (var e = this.groupedData || [], t = e.length; t--;) e[t] && e[t].destroy(); Mn.apply(this) }; w(Ln, "setOptions", function (e, n) { var r = e.call(this, n), i = this.type, s = this.chart.options.plotOptions, o = on[i].dataGrouping; if (Pn[i]) o || (o = t(Dn, Pn[i])), r.dataGrouping = t(o, s.series && s.series.dataGrouping, s[i].dataGrouping, n.dataGrouping); if (this.chart.options._stock) this.requireSorting = !0; return r }); w(B.prototype, "setScale", function (e) { e.call(this); Kt(this.series, function (e) { e.hasProcessed = !1 }) }); B.prototype.getGroupPixelWidth = function () { var e = this.series, t = e.length, n, r = 0, i = !1, s; for (n = t; n--;) (s = e[n].options.dataGrouping) && (r = J(r, s.groupPixelWidth)); for (n = t; n--;) if ((s = e[n].options.dataGrouping) && e[n].hasProcessed) if (t = (e[n].processedXData || e[n].data).length, e[n].groupPixelWidth || t > this.chart.plotSizeX / r || t && s.forced) i = !0; return i ? r : 0 }; on.ohlc = t(on.column, { lineWidth: 1, tooltip: { pointFormat: '<span style="color:{series.color}">●</span> <b> {series.name}</b><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>' }, states: { hover: { lineWidth: 3 } }, threshold: null }); Wt = g(Ut.column, { type: "ohlc", pointArrayMap: ["open", "high", "low", "close"], toYData: function (e) { return [e.open, e.high, e.low, e.close] }, pointValKey: "high", pointAttrToOptions: { stroke: "color", "stroke-width": "lineWidth" }, upColorProp: "stroke", getAttribs: function () { Ut.column.prototype.getAttribs.apply(this, arguments); var e = this.options, n = e.states, e = e.upColor || this.color, r = t(this.pointAttr), i = this.upColorProp; r[""][i] = e; r.hover[i] = n.hover.upColor || e; r.select[i] = n.select.upColor || e; Kt(this.points, function (e) { if (e.open < e.close) e.pointAttr = r }) }, translate: function () { var e = this.yAxis; Ut.column.prototype.translate.apply(this); Kt(this.points, function (t) { if (t.open !== null) t.plotOpen = e.translate(t.open, 0, 1, 0, 1); if (t.close !== null) t.plotClose = e.translate(t.close, 0, 1, 0, 1) }) }, drawPoints: function () { var e = this, t = e.chart, n, r, i, s, o, u, a, f; Kt(e.points, function (l) { if (l.plotY !== R) a = l.graphic, n = l.pointAttr[l.selected ? "selected" : ""] || e.pointAttr[""], s = n["stroke-width"] % 2 / 2, f = X(l.plotX) - s, o = X(l.shapeArgs.width / 2), u = ["M", f, X(l.yBottom), "L", f, X(l.plotY)], l.open !== null && (r = X(l.plotOpen) + s, u.push("M", f, r, "L", f - o, r)), l.close !== null && (i = X(l.plotClose) + s, u.push("M", f, i, "L", f + o, i)), a ? a.animate({ d: u }) : l.graphic = t.renderer.path(u).attr(n).add(e.group) }) }, animate: null }); Ut.ohlc = Wt; on.candlestick = t(on.column, { lineColor: "black", lineWidth: 1, states: { hover: { lineWidth: 2 } }, tooltip: on.ohlc.tooltip, threshold: null, upColor: "white" }); Wt = g(Wt, { type: "candlestick", pointAttrToOptions: { fill: "color", stroke: "lineColor", "stroke-width": "lineWidth" }, upColorProp: "fill", getAttribs: function () { Ut.ohlc.prototype.getAttribs.apply(this, arguments); var e = this.options, t = e.states, n = e.upLineColor || e.lineColor, r = t.hover.upLineColor || n, i = t.select.upLineColor || n; Kt(this.points, function (e) { if (e.open < e.close) e.pointAttr[""].stroke = n, e.pointAttr.hover.stroke = r, e.pointAttr.select.stroke = i }) }, drawPoints: function () { var e = this, t = e.chart, n, r = e.pointAttr[""], i, s, o, u, a, f, l, c, h, p, d; Kt(e.points, function (v) { h = v.graphic; if (v.plotY !== R) n = v.pointAttr[v.selected ? "selected" : ""] || r, l = n["stroke-width"] % 2 / 2, c = X(v.plotX) - l, i = v.plotOpen, s = v.plotClose, o = W.min(i, s), u = W.max(i, s), d = X(v.shapeArgs.width / 2), a = X(o) !== X(v.plotY), f = u !== v.yBottom, o = X(o) + l, u = X(u) + l, p = ["M", c - d, u, "L", c - d, o, "L", c + d, o, "L", c + d, u, "Z", "M", c, o, "L", c, a ? X(v.plotY) : o, "M", c, u, "L", c, f ? X(v.yBottom) : u, "Z"], h ? h.animate({ d: p }) : v.graphic = t.renderer.path(p).attr(n).add(e.group).shadow(e.options.shadow) }) } }); Ut.candlestick = Wt; var jn = cn.prototype.symbols; on.flags = t(on.column, { dataGrouping: null, fillColor: "white", lineWidth: 1, pointRange: 0, shape: "flag", stackDistance: 12, states: { hover: { lineColor: "black", fillColor: "#FCFFC5" } }, style: { fontSize: "11px", fontWeight: "bold", textAlign: "center" }, tooltip: { pointFormat: "{point.text}<br/>" }, threshold: null, y: -30 }); Ut.flags = g(Ut.column, { type: "flags", sorted: !1, noSharedTooltip: !0, takeOrdinalPosition: !1, trackerGroups: ["markerGroup"], forceCrop: !0, init: Tn.prototype.init, pointAttrToOptions: { fill: "fillColor", stroke: "color", "stroke-width": "lineWidth", r: "radius" }, translate: function () { Ut.column.prototype.translate.apply(this); var e = this.chart, t = this.points, n = t.length - 1, r, i, s = this.options.onSeries, s = (r = s && e.get(s)) && r.options.step, o = r && r.points, u = o && o.length, a = this.xAxis, f = a.getExtremes(), l, c, h; if (r && r.visible && u) { r = r.currentDataGrouping; c = o[u - 1].x + (r ? r.totalRange : 0); for (t.sort(function (e, t) { return e.x - t.x }) ; u-- && t[n];) if (r = t[n], l = o[u], l.x <= r.x && l.plotY !== R) { if (r.x <= c) r.plotY = l.plotY, l.x < r.x && !s && (h = o[u + 1]) && h.plotY !== R && (r.plotY += (r.x - l.x) / (h.x - l.x) * (h.plotY - l.plotY)); n--; u++; if (n < 0) break } } Kt(t, function (n, r) { if (n.plotY === R) n.x >= f.min && n.x <= f.max ? n.plotY = e.chartHeight - a.bottom - (a.opposite ? a.height : 0) + a.offset - e.plotTop : n.shapeArgs = {}; if ((i = t[r - 1]) && i.plotX === n.plotX) { if (i.stackIndex === R) i.stackIndex = 0; n.stackIndex = i.stackIndex + 1 } }) }, drawPoints: function () { var e, n = this.pointAttr[""], r = this.points, i = this.chart.renderer, s, o, u = this.options, a = u.y, f, l, c, h, p = u.lineWidth % 2 / 2, d, v; for (l = r.length; l--;) if (c = r[l], e = c.plotX > this.xAxis.len, s = c.plotX + (e ? p : -p), h = c.stackIndex, f = c.options.shape || u.shape, o = c.plotY, o !== R && (o = c.plotY + a + p - (h !== R && h * u.stackDistance)), d = h ? R : c.plotX + p, v = h ? R : c.plotY, h = c.graphic, o !== R && s >= 0 && !e) e = c.pointAttr[c.selected ? "select" : ""] || n, h ? h.attr({ x: s, y: o, r: e.r, anchorX: d, anchorY: v }) : c.graphic = i.label(c.options.title || u.title || "A", s, o, f, d, v, u.useHTML).css(t(u.style, c.style)).attr(e).attr({ align: f === "flag" ? "left" : "center", width: u.width, height: u.height }).add(this.markerGroup).shadow(u.shadow), c.tooltipPos = [s, o]; else if (h) c.graphic = h.destroy() }, drawTracker: function () { var e = this.points; kn.drawTrackerPoint.apply(this); Kt(e, function (t) { var n = t.graphic; n && Zt(n.element, "mouseover", function () { if (t.stackIndex > 0 && !t.raised) t._y = n.y, n.attr({ y: t._y - 8 }), t.raised = !0; Kt(e, function (e) { if (e !== t && e.raised && e.graphic) e.graphic.attr({ y: e._y }), e.raised = !1 }) }) }) }, animate: St }); jn.flag = function (e, t, n, r, i) { var s = i && i.anchorX || e, i = i && i.anchorY || t; return ["M", s, i, "L", e, t + r, e, t, e + n, t, e + n, t + r, e, t + r, "M", s, i, "Z"] }; Kt(["circle", "square"], function (e) { jn[e + "pin"] = function (t, n, r, i, s) { var o = s && s.anchorX, s = s && s.anchorY, t = jn[e](t, n, r, i); o && s && t.push("M", o, n > s ? n : n + i, "L", o, s); return t } }); ht === zt.VMLRenderer && Kt(["flag", "circlepin", "squarepin"], function (e) { hn.prototype.symbols[e] = jn[e] }); Wt = [].concat(Hn); Wt[4] = ["day", [1, 2, 3, 4]]; Wt[5] = ["week", [1, 2, 3]]; e(gt, { navigator: { handles: { backgroundColor: "#ebe7e8", borderColor: "#b2b1b6" }, height: 40, margin: 25, maskFill: "rgba(128,179,236,0.3)", maskInside: !0, outlineColor: "#b2b1b6", outlineWidth: 1, series: { type: Ut.areaspline === R ? "line" : "areaspline", color: "#4572A7", compare: null, fillOpacity: .05, dataGrouping: { approximation: "average", enabled: !0, groupPixelWidth: 2, smoothed: !0, units: Wt }, dataLabels: { enabled: !1, zIndex: 2 }, id: "highcharts-navigator-series", lineColor: "#4572A7", lineWidth: 1, marker: { enabled: !1 }, pointRange: 0, shadow: !1, threshold: null }, xAxis: { tickWidth: 0, lineWidth: 0, gridLineColor: "#EEE", gridLineWidth: 1, tickPixelInterval: 200, labels: { align: "left", style: { color: "#888" }, x: 3, y: -4 }, crosshair: !1 }, yAxis: { gridLineWidth: 0, startOnTick: !1, endOnTick: !1, minPadding: .1, maxPadding: .1, labels: { enabled: !1 }, crosshair: !1, title: { text: null }, tickWidth: 0 } }, scrollbar: { height: ut ? 20 : 14, barBackgroundColor: "#bfc8d1", barBorderRadius: 0, barBorderWidth: 1, barBorderColor: "#bfc8d1", buttonArrowColor: "#666", buttonBackgroundColor: "#ebe7e8", buttonBorderColor: "#bbb", buttonBorderRadius: 0, buttonBorderWidth: 1, minWidth: 6, rifleColor: "#666", trackBackgroundColor: "#eeeeee", trackBorderColor: "#eeeeee", trackBorderWidth: 1, liveRedraw: ft && !ut } }); I.prototype = { drawHandle: function (e, t) { var n = this.chart, r = n.renderer, i = this.elementsToDestroy, s = this.handles, o = this.navigatorOptions.handles, o = { fill: o.backgroundColor, stroke: o.borderColor, "stroke-width": 1 }, u; this.rendered || (s[t] = r.g("navigator-handle-" + ["left", "right"][t]).css({ cursor: "e-resize" }).attr({ zIndex: 4 - t }).add(), u = r.rect(-4.5, 0, 9, 16, 0, 1).attr(o).add(s[t]), i.push(u), u = r.path(["M", -1.5, 4, "L", -1.5, 12, "M", .5, 4, "L", .5, 12]).attr(o).add(s[t]), i.push(u)); s[t][n.isResizing ? "animate" : "attr"]({ translateX: this.scrollerLeft + this.scrollbarHeight + parseInt(e, 10), translateY: this.top + this.height / 2 - 8 }) }, drawScrollbarButton: function (e) { var t = this.chart.renderer, n = this.elementsToDestroy, r = this.scrollbarButtons, i = this.scrollbarHeight, s = this.scrollbarOptions, o; this.rendered || (r[e] = t.g().add(this.scrollbarGroup), o = t.rect(-.5, -.5, i + 1, i + 1, s.buttonBorderRadius, s.buttonBorderWidth).attr({ stroke: s.buttonBorderColor, "stroke-width": s.buttonBorderWidth, fill: s.buttonBackgroundColor }).add(r[e]), n.push(o), o = t.path(["M", i / 2 + (e ? -1 : 1), i / 2 - 3, "L", i / 2 + (e ? -1 : 1), i / 2 + 3, i / 2 + (e ? 2 : -2), i / 2]).attr({ fill: s.buttonArrowColor }).add(r[e]), n.push(o)); e && r[e].attr({ translateX: this.scrollerWidth - i }) }, render: function (e, t, n, r) { var i = this.chart, s = i.renderer, o, u, a, f, l = this.scrollbarGroup, c = this.navigatorGroup, h = this.scrollbar, c = this.xAxis, p = this.scrollbarTrack, v = this.scrollbarHeight, m = this.scrollbarEnabled, g = this.navigatorOptions, y = this.scrollbarOptions, b = y.minWidth, w = this.height, E = this.top, S = this.navigatorEnabled, x = g.outlineWidth, T = x / 2, N = 0, C = this.outlineHeight, k = y.barBorderRadius, L = y.barBorderWidth, A = E + T, O; if (!isNaN(e)) { this.navigatorLeft = o = d(c.left, i.plotLeft + v); this.navigatorWidth = u = d(c.len, i.plotWidth - 2 * v); this.scrollerLeft = a = o - v; this.scrollerWidth = f = f = u + 2 * v; c.getExtremes && (O = this.getUnionExtremes(!0)) && (O.dataMin !== c.min || O.dataMax !== c.max) && c.setExtremes(O.dataMin, O.dataMax, !0, !1); n = d(n, c.translate(e)); r = d(r, c.translate(t)); if (isNaN(n) || Q(n) === Infinity) n = 0, r = f; if (!(c.translate(r, !0) - c.translate(n, !0) < i.xAxis[0].minRange)) { this.zoomedMax = K(J(n, r), u); this.zoomedMin = J(this.fixedWidth ? this.zoomedMax - this.fixedWidth : K(n, r), 0); this.range = this.zoomedMax - this.zoomedMin; n = X(this.zoomedMax); t = X(this.zoomedMin); e = n - t; if (!this.rendered) { if (S) { this.navigatorGroup = c = s.g("navigator").attr({ zIndex: 3 }).add(); this.leftShade = s.rect().attr({ fill: g.maskFill }).add(c); if (!g.maskInside) this.rightShade = s.rect().attr({ fill: g.maskFill }).add(c); this.outline = s.path().attr({ "stroke-width": x, stroke: g.outlineColor }).add(c) } if (m) this.scrollbarGroup = l = s.g("scrollbar").add(), h = y.trackBorderWidth, this.scrollbarTrack = p = s.rect().attr({ x: 0, y: -h % 2 / 2, fill: y.trackBackgroundColor, stroke: y.trackBorderColor, "stroke-width": h, r: y.trackBorderRadius || 0, height: v }).add(l), this.scrollbar = h = s.rect().attr({ y: -L % 2 / 2, height: v, fill: y.barBackgroundColor, stroke: y.barBorderColor, "stroke-width": L, r: k }).add(l), this.scrollbarRifles = s.path().attr({ stroke: y.rifleColor, "stroke-width": 1 }).add(l) } i = i.isResizing ? "animate" : "attr"; if (S) { this.leftShade[i](g.maskInside ? { x: o + t, y: E, width: n - t, height: w } : { x: o, y: E, width: t, height: w }); if (this.rightShade) this.rightShade[i]({ x: o + n, y: E, width: u - n, height: w }); this.outline[i]({ d: ["M", a, A, "L", o + t + T, A, o + t + T, A + C, "L", o + n - T, A + C, "L", o + n - T, A, a + f, A].concat(g.maskInside ? ["M", o + t + T, A, "L", o + n - T, A] : []) }); this.drawHandle(t + T, 0); this.drawHandle(n + T, 1) } if (m && l) this.drawScrollbarButton(0), this.drawScrollbarButton(1), l[i]({ translateX: a, translateY: X(A + w) }), p[i]({ width: f }), o = v + t, u = e - L, u < b && (N = (b - u) / 2, u = b, o -= N), this.scrollbarPad = N, h[i]({ x: V(o) + L % 2 / 2, width: u }), b = v + t + e / 2 - .5, this.scrollbarRifles.attr({ visibility: e > 12 ? "visible" : "hidden" })[i]({ d: ["M", b - 3, v / 4, "L", b - 3, 2 * v / 3, "M", b, v / 4, "L", b, 2 * v / 3, "M", b + 3, v / 4, "L", b + 3, 2 * v / 3] }); this.scrollbarPad = N; this.rendered = !0 } } }, addEvents: function () { var e = this.chart.container, t = this.mouseDownHandler, n = this.mouseMoveHandler, r = this.mouseUpHandler, i; i = [[e, "mousedown", t], [e, "mousemove", n], [document, "mouseup", r]]; pt && i.push([e, "touchstart", t], [e, "touchmove", n], [document, "touchend", r]); Kt(i, function (e) { Zt.apply(null, e) }); this._events = i }, removeEvents: function () { Kt(this._events, function (e) { en.apply(null, e) }); this._events = R; this.navigatorEnabled && this.baseSeries && en(this.baseSeries, "updatedData", this.updatedDataHandler) }, init: function () { var e = this, n = e.chart, r, i, s = e.scrollbarHeight, o = e.navigatorOptions, u = e.height, a = e.top, f, l, c = document.body.style, h, p = e.baseSeries; e.mouseDownHandler = function (t) { var t = n.pointer.normalize(t), i = e.zoomedMin, s = e.zoomedMax, o = e.top, a = e.scrollbarHeight, l = e.scrollerLeft, p = e.scrollerWidth, d = e.navigatorLeft, v = e.navigatorWidth, m = e.scrollbarPad, g = e.range, y = t.chartX, b = t.chartY, t = n.xAxis[0], w, E = ut ? 10 : 7; if (b > o && b < o + u + a) if ((o = !e.scrollbarEnabled || b < o + u) && W.abs(y - i - d) < E) e.grabbedLeft = !0, e.otherHandlePos = s, e.fixedExtreme = t.max, n.fixedRange = null; else if (o && W.abs(y - s - d) < E) e.grabbedRight = !0, e.otherHandlePos = i, e.fixedExtreme = t.min, n.fixedRange = null; else if (y > d + i - m && y < d + s + m) { e.grabbedCenter = y; e.fixedWidth = g; if (n.renderer.isSVG) h = c.cursor, c.cursor = "ew-resize"; f = y - i } else if (y > l && y < l + p) { s = o ? y - d - g / 2 : y < d ? i - g * .2 : y > l + p - a ? i + g * .2 : y < d + i ? i - g : s; if (s < 0) s = 0; else if (s + g >= v) s = v - g, w = r.dataMax; if (s !== i) e.fixedWidth = g, i = r.toFixedRange(s, s + g, null, w), t.setExtremes(i.min, i.max, !0, !1, { trigger: "navigator" }) } }; e.mouseMoveHandler = function (t) { var r = e.scrollbarHeight, i = e.navigatorLeft, s = e.navigatorWidth, o = e.scrollerLeft, u = e.scrollerWidth, a = e.range, c; if (t.pageX !== 0) t = n.pointer.normalize(t), c = t.chartX, c < i ? c = i : c > o + u - r && (c = o + u - r), e.grabbedLeft ? (l = !0, e.render(0, 0, c - i, e.otherHandlePos)) : e.grabbedRight ? (l = !0, e.render(0, 0, e.otherHandlePos, c - i)) : e.grabbedCenter && (l = !0, c < f ? c = f : c > s + f - a && (c = s + f - a), e.render(0, 0, c - f, c - f + a)), l && e.scrollbarOptions.liveRedraw && setTimeout(function () { e.mouseUpHandler(t) }, 0) }; e.mouseUpHandler = function (t) { var i, s; if (l) { if (e.zoomedMin === e.otherHandlePos) i = e.fixedExtreme; else if (e.zoomedMax === e.otherHandlePos) s = e.fixedExtreme; i = r.toFixedRange(e.zoomedMin, e.zoomedMax, i, s); n.xAxis[0].setExtremes(i.min, i.max, !0, !1, { trigger: "navigator", triggerOp: "navigator-drag", DOMEvent: t }) } if (t.type !== "mousemove") e.grabbedLeft = e.grabbedRight = e.grabbedCenter = e.fixedWidth = e.fixedExtreme = e.otherHandlePos = l = f = null, c.cursor = h || "" }; var v = n.xAxis.length, m = n.yAxis.length; n.extraBottomMargin = e.outlineHeight + o.margin; e.navigatorEnabled ? (e.xAxis = r = new B(n, t({ ordinal: p && p.xAxis.options.ordinal }, o.xAxis, { id: "navigator-x-axis", isX: !0, type: "datetime", index: v, height: u, offset: 0, offsetLeft: s, offsetRight: -s, keepOrdinalPadding: !0, startOnTick: !1, endOnTick: !1, minPadding: 0, maxPadding: 0, zoomEnabled: !1 })), e.yAxis = i = new B(n, t(o.yAxis, { id: "navigator-y-axis", alignTicks: !1, height: u, offset: 0, index: m, zoomEnabled: !1 })), p || o.series.data ? e.addBaseSeries() : n.series.length === 0 && w(n, "redraw", function (t, r) { if (n.series.length > 0 && !e.series) e.setBaseSeries(), n.redraw = t; t.call(n, r) })) : e.xAxis = r = { translate: function (e, t) { var r = n.xAxis[0].getExtremes(), i = n.plotWidth - 2 * s, o = r.dataMin, r = r.dataMax - o; return t ? e * r / i + o : i * (e - o) / r }, toFixedRange: B.prototype.toFixedRange }; w(n, "getMargins", function (t) { var n = this.legend, s = n.options; t.call(this); e.top = a = e.navigatorOptions.top || this.chartHeight - e.height - e.scrollbarHeight - this.spacing[2] - (s.verticalAlign === "bottom" && s.enabled && !s.floating ? n.legendHeight + d(s.margin, 10) : 0); if (r && i) r.options.top = i.options.top = a, r.setAxisSize(), i.setAxisSize() }); e.addEvents() }, getUnionExtremes: function (e) { var t = this.chart.xAxis[0], n = this.xAxis, r = n.options; if (!e || t.dataMin !== null) return { dataMin: d(r && r.min, (c(t.dataMin) && c(n.dataMin) ? K : d)(t.dataMin, n.dataMin)), dataMax: d(r && r.max, (c(t.dataMax) && c(n.dataMax) ? J : d)(t.dataMax, n.dataMax)) } }, setBaseSeries: function (e) { var t = this.chart, e = e || t.options.navigator.baseSeries; this.series && this.series.remove(); this.baseSeries = t.series[e] || typeof e === "string" && t.get(e) || t.series[0]; this.xAxis && this.addBaseSeries() }, addBaseSeries: function () { var n = this.baseSeries, r = n ? n.options : {}, i = r.data, s = this.navigatorOptions.series, o; o = s.data; this.hasNavigatorData = !!o; r = t(r, s, { enableMouseTracking: !1, group: "nav", padXAxis: !1, xAxis: "navigator-x-axis", yAxis: "navigator-y-axis", name: "Navigator", showInLegend: !1, isInternal: !0, visible: !0 }); r.data = o || i; this.series = this.chart.initSeries(r); if (n && this.navigatorOptions.adaptToUpdatedData !== !1) Zt(n, "updatedData", this.updatedDataHandler), n.userOptions.events = e(n.userOptions.event, { updatedData: this.updatedDataHandler }) }, updatedDataHandler: function () { var e = this.chart.scroller, t = e.baseSeries, n = t.xAxis, r = n.getExtremes(), i = r.min, s = r.max, o = r.dataMin, r = r.dataMax, u = s - i, a, f, l, c, h, p = e.series; a = p.xData; var d = !!n.setExtremes; f = s >= a[a.length - 1] - (this.closestPointRange || 0); a = i <= o; if (!e.hasNavigatorData) p.options.pointStart = t.xData[0], p.setData(t.options.data, !1), h = !0; a && (c = o, l = c + u); f && (l = r, a || (c = J(l - u, p.xData[0]))); d && (a || f) ? isNaN(c) || n.setExtremes(c, l, !0, !1, { trigger: "updatedData" }) : (h && this.chart.redraw(!1), e.render(J(i, o), K(s, r))) }, destroy: function () { this.removeEvents(); Kt([this.xAxis, this.yAxis, this.leftShade, this.rightShade, this.outline, this.scrollbarTrack, this.scrollbarRifles, this.scrollbarGroup, this.scrollbar], function (e) { e && e.destroy && e.destroy() }); this.xAxis = this.yAxis = this.leftShade = this.rightShade = this.outline = this.scrollbarTrack = this.scrollbarRifles = this.scrollbarGroup = this.scrollbar = null; Kt([this.scrollbarButtons, this.handles, this.elementsToDestroy], function (e) { L(e) }) } }; zt.Scroller = I; w(B.prototype, "zoom", function (e, t, n) { var r = this.chart, i = r.options, s = i.chart.zoomType, o = i.navigator, i = i.rangeSelector, u; if (this.isXAxis && (o && o.enabled || i && i.enabled)) if (s === "x") r.resetZoomButton = "blocked"; else if (s === "y") u = !1; else if (s === "xy") r = this.previousZoom, c(t) ? this.previousZoom = [this.min, this.max] : r && (t = r[0], n = r[1], delete this.previousZoom); return u !== R ? u : e.call(this, t, n) }); w(j.prototype, "init", function (e, t, n) { Zt(this, "beforeRender", function () { var e = this.options; if (e.navigator.enabled || e.scrollbar.enabled) this.scroller = new I(this) }); e.call(this, t, n) }); w(Tn.prototype, "addPoint", function (e, t, n, r, i) { var u = this.options.turboThreshold; u && this.xData.length > u && s(t) && !o(t) && this.chart.scroller && O(20, !0); e.call(this, t, n, r, i) }); e(gt, { rangeSelector: { buttonTheme: { width: 28, height: 18, fill: "#f7f7f7", padding: 2, r: 0, "stroke-width": 0, style: { color: "#444", cursor: "pointer", fontWeight: "normal" }, zIndex: 7, states: { hover: { fill: "#e7e7e7" }, select: { fill: "#e7f0f9", style: { color: "black", fontWeight: "bold" } } } }, inputPosition: { align: "right" }, labelStyle: { color: "#666" } } }); gt.lang = t(gt.lang, { rangeSelectorZoom: "Zoom", rangeSelectorFrom: "From", rangeSelectorTo: "To" }); q.prototype = {
        clickButton: function (e, n) { var r = this, i = r.selected, s = r.chart, o = r.buttons, u = r.buttonOptions[e], a = s.xAxis[0], f = s.scroller && s.scroller.getUnionExtremes() || a || {}, l = f.dataMin, c = f.dataMax, h, p = a && X(K(a.max, d(c, a.max))), v = new Date(p), m = u.type, g = u.count, f = u._range, y; if (!(l === null || c === null || e === r.selected)) { if (m === "month" || m === "year") h = { month: "Month", year: "FullYear" }[m], v["set" + h](v["get" + h]() - g), h = v.getTime(), l = d(l, Number.MIN_VALUE), isNaN(h) || h < l ? (h = l, p = K(h + f, c)) : f = p - h; else if (f) h = J(p - f, l), p = K(h + f, c); else if (m === "ytd") if (a) { if (c === R) l = Number.MAX_VALUE, c = Number.MIN_VALUE, Kt(s.series, function (e) { e = e.xData; l = K(e[0], l); c = J(e[e.length - 1], c) }), n = !1; p = new Date(c); y = p.getFullYear(); h = y = J(l || 0, Date.UTC(y, 0, 1)); p = p.getTime(); p = K(c || p, p) } else { Zt(s, "beforeRender", function () { r.clickButton(e) }); return } else m === "all" && a && (h = l, p = c); o[i] && o[i].setState(0); o[e] && o[e].setState(2); s.fixedRange = f; a ? a.setExtremes(h, p, d(n, 1), 0, { trigger: "rangeSelectorButton", rangeSelectorButton: u }) : (i = s.options.xAxis, i[0] = t(i[0], { range: f, min: y })); r.setSelected(e) } }, setSelected: function (e) { this.selected = this.options.selected = e }, defaultButtons: [{ type: "month", count: 1, text: "1m" }, { type: "month", count: 3, text: "3m" }, { type: "month", count: 6, text: "6m" }, { type: "ytd", text: "YTD" }, { type: "year", count: 1, text: "1y" }, { type: "all", text: "All" }], init: function (e) {
            var t = this, n = e.options.rangeSelector, r = n.buttons || [].concat(t.defaultButtons), i = n.selected, s = t.blurInputs = function () {
                //var e=t.minInput,n=t.maxInput;e&&e.blur();n&&n.blur()
            }; t.chart = e; t.options = n; t.buttons = []; e.extraTopMargin = 35; t.buttonOptions = r; Zt(e.container, "mousedown", s); Zt(e, "resize", s); Kt(r, t.computeButtonRange); i !== R && r[i] && this.clickButton(i, !1); Zt(e, "load", function () { Zt(e.xAxis[0], "afterSetExtremes", function () { t.updateButtonStates(!0) }) })
        }, updateButtonStates: function (e) { var t = this, n = this.chart, r = n.xAxis[0], i = n.scroller && n.scroller.getUnionExtremes() || r, s = i.dataMin, o = i.dataMax, u = t.selected, a = t.buttons; e && n.fixedRange !== X(r.max - r.min) && (a[u] && a[u].setState(0), t.setSelected(null)); Kt(t.buttonOptions, function (e, n) { var i = e._range, f = i > o - s, l = i < r.minRange, c = e.type === "all" && r.max - r.min >= o - s && a[n].state !== 2, h = e.type === "ytd" && yt("%Y", s) === yt("%Y", o); i === X(r.max - r.min) && n !== u ? (t.setSelected(n), a[n].setState(2)) : f || l || c || h ? a[n].setState(3) : a[n].state === 3 && a[n].setState(0) }) }, computeButtonRange: function (e) { var t = e.type, n = e.count || 1, r = { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5 }; if (r[t]) e._range = r[t] * n; else if (t === "month" || t === "year") e._range = { month: 30, year: 365 }[t] * 864e5 * n }, setInputValue: function (e, t) { var n = this.chart.options.rangeSelector; if (c(t)) this[e + "Input"].HCTime = t; this[e + "Input"].value = yt(n.inputEditDateFormat || "%Y-%m-%d", this[e + "Input"].HCTime); this[e + "DateBox"].attr({ text: yt(n.inputDateFormat || "%b %e, %Y", this[e + "Input"].HCTime) }) }, drawInput: function (n) { var i = this, s = i.chart, o = s.renderer.style, u = s.renderer, a = s.options.rangeSelector, f = i.div, l = n === "min", c, h, p, d = this.inputGroup; this[n + "Label"] = h = u.label(gt.lang[l ? "rangeSelectorFrom" : "rangeSelectorTo"], this.inputGroup.offset).attr({ padding: 2 }).css(t(o, a.labelStyle)).add(d); d.offset += h.width + 5; this[n + "DateBox"] = p = u.label("", d.offset).attr({ padding: 2, width: a.inputBoxWidth || 90, height: a.inputBoxHeight || 17, stroke: a.inputBoxBorderColor || "silver", "stroke-width": 1 }).css(t({ textAlign: "center", color: "#444" }, o, a.inputStyle)).on("click", function () { i[n + "Input"].focus() }).add(d); d.offset += p.width + (l ? 10 : 0); this[n + "Input"] = c = m("input", { name: n, className: "highcharts-range-selector", type: "text" }, e({ position: "absolute", border: 0, width: "1px", height: "1px", padding: 0, textAlign: "center", fontSize: o.fontSize, fontFamily: o.fontFamily, top: s.plotTop + "px" }, a.inputStyle), f); c.onfocus = function () { v(this, { left: d.translateX + p.x + "px", top: d.translateY + "px", width: p.width - 2 + "px", height: p.height - 2 + "px", border: "2px solid silver" }) }; c.onblur = function () { v(this, { border: 0, width: "1px", height: "1px" }); i.setInputValue(n) }; c.onchange = function () { var e = c.value, t = (a.inputDateParser || Date.parse)(e), n = s.xAxis[0], o = n.dataMin, u = n.dataMax; isNaN(t) && (t = e.split("-"), t = Date.UTC(r(t[0]), r(t[1]) - 1, r(t[2]))); isNaN(t) || (gt.global.useUTC || (t += (new Date).getTimezoneOffset() * 6e4), l ? t > i.maxInput.HCTime ? t = R : t < o && (t = o) : t < i.minInput.HCTime ? t = R : t > u && (t = u), t !== R && s.xAxis[0].setExtremes(l ? t : n.min, l ? n.max : t, R, R, { trigger: "rangeSelectorInput" })) } }, render: function (t, n) { var r = this, i = r.chart, s = i.renderer, o = i.container, u = i.options, a = u.exporting && u.navigation && u.navigation.buttonOptions, f = u.rangeSelector, l = r.buttons, u = gt.lang, c = r.div, c = r.inputGroup, h = f.buttonTheme, p = f.inputEnabled !== !1, v = h && h.states, g = i.plotLeft, y; if (!r.rendered && (r.zoomText = s.text(u.rangeSelectorZoom, g, i.plotTop - 20).css(f.labelStyle).add(), y = g + r.zoomText.getBBox().width + 5, Kt(r.buttonOptions, function (e, t) { l[t] = s.button(e.text, y, i.plotTop - 35, function () { r.clickButton(t); r.isActive = !0 }, h, v && v.hover, v && v.select).css({ textAlign: "center" }).add(); y += l[t].width + d(f.buttonSpacing, 5); r.selected === t && l[t].setState(2) }), r.updateButtonStates(), p)) r.div = c = m("div", null, { position: "relative", height: 0, zIndex: 1 }), o.parentNode.insertBefore(c, o), r.inputGroup = c = s.g("input-group").add(), c.offset = 0, r.drawInput("min"), r.drawInput("max"); p && (o = i.plotTop - 45, c.align(e({ y: o, width: c.offset, x: a && o < (a.y || 0) + a.height - i.spacing[0] ? -40 : 0 }, f.inputPosition), !0, i.spacingBox), r.setInputValue("min", t), r.setInputValue("max", n)); r.rendered = !0 }, destroy: function () { var e = this.minInput, t = this.maxInput, n = this.chart, r = this.blurInputs, i; en(n.container, "mousedown", r); en(n, "resize", r); L(this.buttons); if (e) e.onfocus = e.onblur = e.onchange = null; if (t) t.onfocus = t.onblur = t.onchange = null; for (i in this) this[i] && i !== "chart" && (this[i].destroy ? this[i].destroy() : this[i].nodeType && A(this[i])), this[i] = null }
    }; B.prototype.toFixedRange = function (e, t, n, r) { var i = this.chart && this.chart.fixedRange, e = d(n, this.translate(e, !0)), t = d(r, this.translate(t, !0)), n = i && (t - e) / i; n > .7 && n < 1.3 && (r ? e = t - i : t = e + i); return { min: e, max: t } }; w(j.prototype, "init", function (e, t, n) { Zt(this, "init", function () { if (this.options.rangeSelector.enabled) this.rangeSelector = new q(this) }); e.call(this, t, n) }); zt.RangeSelector = q; j.prototype.callbacks.push(function (e) { function t() { s = e.xAxis[0].getExtremes(); o.render(s.min, s.max) } function n() { s = e.xAxis[0].getExtremes(); isNaN(s.min) || u.render(s.min, s.max) } function r(e) { e.triggerOp !== "navigator-drag" && o.render(e.min, e.max) } function i(e) { u.render(e.min, e.max) } var s, o = e.scroller, u = e.rangeSelector; o && (Zt(e.xAxis[0], "afterSetExtremes", r), w(e, "drawChartBox", function (e) { var n = this.isDirtyBox; e.call(this); n && t() }), t()); u && (Zt(e.xAxis[0], "afterSetExtremes", i), Zt(e, "resize", n), n()); Zt(e, "destroy", function () { o && en(e.xAxis[0], "afterSetExtremes", r); u && (en(e, "resize", n), en(e.xAxis[0], "afterSetExtremes", i)) }) }); zt.StockChart = function (e, n) { var r = e.series, i, s = d(e.navigator && e.navigator.enabled, !0) ? { startOnTick: !1, endOnTick: !1 } : null, o = { marker: { enabled: !1, radius: 2 }, states: { hover: { lineWidth: 2 } } }, u = { shadow: !1, borderWidth: 0 }; e.xAxis = Yt(p(e.xAxis || {}), function (e) { return t({ minPadding: 0, maxPadding: 0, ordinal: !0, title: { text: null }, labels: { overflow: "justify" }, showLastLabel: !0 }, e, { type: "datetime", categories: null }, s) }); e.yAxis = Yt(p(e.yAxis || {}), function (e) { i = d(e.opposite, !0); return t({ labels: { y: -2 }, opposite: i, showLastLabel: !1, title: { text: null } }, e) }); e.series = null; e = t({ chart: { panning: !0, pinchType: "x" }, navigator: { enabled: !0 }, scrollbar: { enabled: !0 }, rangeSelector: { enabled: !0 }, title: { text: null, style: { fontSize: "16px" } }, tooltip: { shared: !0, crosshairs: !0 }, legend: { enabled: !1 }, plotOptions: { line: o, spline: o, area: o, areaspline: o, arearange: o, areasplinerange: o, column: u, columnrange: u, candlestick: u, ohlc: u } }, e, { _stock: !0, chart: { inverted: !1 } }); e.series = r; return new j(e, n) }; w(gn.prototype, "init", function (e, t, n) { var r = n.chart.pinchType || ""; e.call(this, t, n); this.pinchX = this.pinchHor = r.indexOf("x") !== -1; this.pinchY = this.pinchVert = r.indexOf("y") !== -1; this.hasZoom = this.hasZoom || this.pinchHor || this.pinchVert }); w(B.prototype, "autoLabelAlign", function (e) { if (this.chart.options._stock && this.coll === "yAxis" && Jt(this, this.chart.yAxis) === 0) { if (this.options.labels.x === 15) this.options.labels.x = 0; return "right" } return e.call(this) }); B.prototype.getPlotLinePath = function (e, t, n, r, i) { var s = this, o = this.isLinked && !this.series ? this.linkedParent.series : this.series, u = s.chart, a = u.renderer, f = s.left, l = s.top, h, p, v, m, g = [], y, b; y = s.isXAxis ? c(s.options.yAxis) ? [u.yAxis[s.options.yAxis]] : Yt(o, function (e) { return e.yAxis }) : c(s.options.xAxis) ? [u.xAxis[s.options.xAxis]] : Yt(o, function (e) { return e.xAxis }); Kt(s.isXAxis ? u.yAxis : u.xAxis, function (e) { if (c(e.options.id) ? e.options.id.indexOf("navigator") === -1 : 1) { var t = e.isXAxis ? "yAxis" : "xAxis", t = c(e.options[t]) ? u[t][e.options[t]] : u[t][0]; s === t && y.push(e) } }); b = y.length ? [] : [s]; Kt(y, function (e) { Jt(e, b) === -1 && b.push(e) }); i = d(i, s.translate(e, null, null, n)); isNaN(i) || (s.horiz ? Kt(b, function (e) { p = e.top; m = p + e.len; h = v = X(i + s.transB); (h >= f && h <= f + s.width || r) && g.push("M", h, p, "L", v, m) }) : Kt(b, function (e) { h = e.left; v = h + e.width; p = m = X(l + s.height - i); (p >= l && p <= l + s.height || r) && g.push("M", h, p, "L", v, m) })); if (g.length > 0) return a.crispPolyLine(g, t || 1) }; B.prototype.getPlotBandPath = function (e, t) { var n = this.getPlotLinePath(t), r = this.getPlotLinePath(e), i = [], s; if (r && n) for (s = 0; s < r.length; s += 6) i.push("M", r[s + 1], r[s + 2], "L", r[s + 4], r[s + 5], n[s + 4], n[s + 5], n[s + 1], n[s + 2]); else i = null; return i }; cn.prototype.crispPolyLine = function (e, t) { var n; for (n = 0; n < e.length; n += 6) e[n + 1] === e[n + 4] && (e[n + 1] = e[n + 4] = X(e[n + 1]) - t % 2 / 2), e[n + 2] === e[n + 5] && (e[n + 2] = e[n + 5] = X(e[n + 2]) + t % 2 / 2); return e }; if (ht === zt.VMLRenderer) hn.prototype.crispPolyLine = cn.prototype.crispPolyLine; w(B.prototype, "hideCrosshair", function (e, t) { e.call(this, t); c(this.crossLabelArray) && (c(t) ? this.crossLabelArray[t] && this.crossLabelArray[t].hide() : Kt(this.crossLabelArray, function (e) { e.hide() })) }); w(B.prototype, "drawCrosshair", function (t, n, r) { var i, s; t.call(this, n, r); if (c(this.crosshair.label) && this.crosshair.label.enabled && c(r)) { var t = this.chart, o = this.options.crosshair.label, u = this.isXAxis ? "x" : "y", n = this.horiz, a = this.opposite, f = this.left, l = this.top, h = this.crossLabel, p, v, m = o.format, g = ""; if (!h) h = this.crossLabel = t.renderer.label().attr({ align: o.align || (n ? "center" : a ? this.labelAlign === "right" ? "right" : "left" : this.labelAlign === "left" ? "left" : "center"), zIndex: 12, height: n ? 16 : R, fill: o.backgroundColor || this.series[0] && this.series[0].color || "gray", padding: d(o.padding, 2), stroke: o.borderColor || null, "stroke-width": o.borderWidth || 0 }).css(e({ color: "white", fontWeight: "normal", fontSize: "11px", textAlign: "center" }, o.style)).add(); n ? (p = r.plotX + f, v = l + (a ? 0 : this.height)) : (p = a ? this.width + f : 0, v = r.plotY + l); if (v < l || v > l + this.height) this.hideCrosshair(); else { !m && !o.formatter && (this.isDatetimeAxis && (g = "%b %d, %Y"), m = "{value" + (g ? ":" + g : "") + "}"); h.attr({ text: m ? E(m, { value: r[u] }) : o.formatter.call(this, r[u]), x: p, y: v, visibility: "visible" }); r = h.getBBox(); if (n) { if (this.options.tickPosition === "inside" && !a || this.options.tickPosition !== "inside" && a) v = h.y - r.height } else v = h.y - r.height / 2; n ? (i = f - r.x, s = f + this.width - r.x) : (i = this.labelAlign === "left" ? f : 0, s = this.labelAlign === "right" ? f + this.width : t.chartWidth); h.translateX < i && (p += i - h.translateX); h.translateX + r.width >= s && (p -= h.translateX + r.width - s); h.attr({ x: p, y: v, visibility: "visible" }) } } }); var Fn = Ln.init, In = Ln.processData, qn = xn.prototype.tooltipFormatter; Ln.init = function () { Fn.apply(this, arguments); this.setCompare(this.options.compare) }; Ln.setCompare = function (e) { this.modifyValue = e === "value" || e === "percent" ? function (t, n) { var r = this.compareValue; if (t !== R && (t = e === "value" ? t - r : t = 100 * (t / r) - 100, n)) n.change = t; return t } : null; if (this.chart.hasRendered) this.isDirty = !0 }; Ln.processData = function () { var e = 0, t, n, r; In.apply(this, arguments); if (this.xAxis && this.processedYData) { t = this.processedXData; n = this.processedYData; for (r = n.length; e < r; e++) if (typeof n[e] === "number" && t[e] >= this.xAxis.min) { this.compareValue = n[e]; break } } }; w(Ln, "getExtremes", function (e) { e.call(this); if (this.modifyValue) this.dataMax = this.modifyValue(this.dataMax), this.dataMin = this.modifyValue(this.dataMin) }); B.prototype.setCompare = function (e, t) { this.isXAxis || (Kt(this.series, function (t) { t.setCompare(e) }), d(t, !0) && this.chart.redraw()) }; xn.prototype.tooltipFormatter = function (e) { e = e.replace("{point.change}", (this.change > 0 ? "+" : "") + y(this.change, d(this.series.tooltipOptions.changeDecimals, 2))); return qn.apply(this, [e]) }; w(Tn.prototype, "render", function (e) { if (this.isCartesian && this.chart.options._stock) this.clipBox ? this.chart[this.sharedClipKey] && this.chart[this.sharedClipKey].attr({ width: this.xAxis.len, height: this.yAxis.len }) : (this.clipBox = t(this.chart.clipBox), this.clipBox.width = this.xAxis.len, this.clipBox.height = this.yAxis.len); e.call(this) }); e(zt, { Axis: B, Chart: j, Color: ln, Point: xn, Tick: H, Renderer: ht, Series: Tn, SVGElement: P, SVGRenderer: cn, arrayMin: C, arrayMax: k, charts: xt, dateFormat: yt, format: E, pathAnim: wt, getOptions: function () { return gt }, hasBidiBug: lt, isTouchDevice: ut, numberFormat: y, seriesTypes: Ut, setOptions: function (e) { gt = t(!0, gt, e); D(); return gt }, addEvent: Zt, removeEvent: en, createElement: m, discardElement: A, css: v, each: Kt, extend: e, map: Yt, merge: t, pick: d, splat: p, extendClass: g, pInt: r, wrap: w, svg: ft, canvas: ct, vml: !ft && !ct, product: "Highstock", version: "2.0.1" })
})();
//(function () { function e(e, t) { var n; e || (e = {}); for (n in t) e[n] = t[n]; return e } function t() { var e, t = arguments, n, r = {}, i = function (e, t) { var n, r; typeof e !== "object" && (e = {}); for (r in t) t.hasOwnProperty(r) && (n = t[r], e[r] = n && typeof n === "object" && Object.prototype.toString.call(n) !== "[object Array]" && typeof n.nodeType !== "number" ? i(e[r] || {}, n) : t[r]); return e }; t[0] === !0 && (r = t[1], t = Array.prototype.slice.call(t, 2)); n = t.length; for (e = 0; e < n; e++) r = i(r, t[e]); return r } function n() { for (var e = 0, t = arguments, n = t.length, r = {}; e < n; e++) r[t[e++]] = t[e]; return r } function r(e, t) { return parseInt(e, t || 10) } function i(e) { return typeof e === "string" } function s(e) { return typeof e === "object" } function o(e) { return Object.prototype.toString.call(e) === "[object Array]" } function u(e) { return typeof e === "number" } function a(e) { return X.log(e) / X.LN10 } function f(e) { return X.pow(10, e) } function l(e, t) { for (var n = e.length; n--; ) if (e[n] === t) { e.splice(n, 1); break } } function c(e) { return e !== U && e !== null } function h(e, t, n) { var r, o; if (i(t)) c(n) ? e.setAttribute(t, n) : e && e.getAttribute && (o = e.getAttribute(t)); else if (c(t) && s(t)) for (r in t) e.setAttribute(r, t[r]); return o } function p(e) { return o(e) ? e : [e] } function d() { var e = arguments, t, n, r = e.length; for (t = 0; t < r; t++) if (n = e[t], typeof n !== "undefined" && n !== null) return n } function v(t, n) { if (it && n && n.opacity !== U) n.filter = "alpha(opacity=" + n.opacity * 100 + ")"; e(t.style, n) } function m(t, n, r, i, s) { t = z.createElement(t); n && e(t, n); s && v(t, { padding: 0, border: Ct, margin: 0 }); r && v(t, r); i && i.appendChild(t); return t } function g(t, n) { var r = function () { }; r.prototype = new t; e(r.prototype, n); return r } function y(e, t, n, i) { var s = yt.lang, e = +e || 0, o = t === -1 ? (e.toString().split(".")[1] || "").length : isNaN(t = G(t)) ? 2 : t, t = n === void 0 ? s.decimalPoint : n, i = i === void 0 ? s.thousandsSep : i, s = e < 0 ? "-" : "", n = String(r(e = G(e).toFixed(o))), u = n.length > 3 ? n.length % 3 : 0; return s + (u ? n.substr(0, u) + i : "") + n.substr(u).replace(/(\d{3})(?=\d)/g, "$1" + i) + (o ? t + G(e - n).toFixed(o).slice(2) : "") } function b(e, t) { return Array((t || 2) + 1 - String(e).length).join(0) + e } function w(e, t, n) { var r = e[t]; e[t] = function () { var e = Array.prototype.slice.call(arguments); e.unshift(r); return n.apply(this, e) } } function E(e, t) { for (var n = "{", r = !1, i, s, o, u, a, f = []; (n = e.indexOf(n)) !== -1; ) { i = e.slice(0, n); if (r) { s = i.split(":"); o = s.shift().split("."); a = o.length; i = t; for (u = 0; u < a; u++) i = i[o[u]]; if (s.length) s = s.join(":"), o = /\.([0-9])/, u = yt.lang, a = void 0, /f$/.test(s) ? (a = (a = s.match(o)) ? a[1] : -1, i = y(i, a, u.decimalPoint, s.indexOf(",") > -1 ? u.thousandsSep : "")) : i = bt(s, i) } f.push(i); e = e.slice(n + 1); n = (r = !r) ? "}" : "{" } f.push(e); return f.join("") } function S(e) { return X.pow(10, $(X.log(e) / X.LN10)) } function x(e, t, n, r) { var i, n = d(n, 1); i = e / n; t || (t = [1, 2, 2.5, 5, 10], r && r.allowDecimals === !1 && (n === 1 ? t = [1, 2, 5, 10] : n <= .1 && (t = [1 / n]))); for (r = 0; r < t.length; r++) if (e = t[r], i <= (t[r] + (t[r + 1] || t[r])) / 2) break; e *= n; return e } function T() { this.symbol = this.color = 0 } function N(e, t) { var n = e.length, r, i; for (i = 0; i < n; i++) e[i].ss_i = i; e.sort(function (e, n) { r = t(e, n); return r === 0 ? e.ss_i - n.ss_i : r }); for (i = 0; i < n; i++) delete e[i].ss_i } function C(e) { for (var t = e.length, n = e[0]; t--; ) e[t] < n && (n = e[t]); return n } function k(e) { for (var t = e.length, n = e[0]; t--; ) e[t] > n && (n = e[t]); return n } function L(e, t) { for (var n in e) e[n] && e[n] !== t && e[n].destroy && e[n].destroy(), delete e[n] } function A(e) { gt || (gt = m(Nt)); e && gt.appendChild(e); gt.innerHTML = "" } function O(e, t) { var n = "Highcharts error #" + e + ": www.highcharts.com/errors/" + e; if (t) throw n; else W.console && console.log(n) } function M(e) { return parseFloat(e.toPrecision(14)) } function _(e, t) { wt = d(e, t.animation) } function D() { var e = yt.global.useUTC, t = e ? "getUTC" : "get", n = e ? "setUTC" : "set"; Mt = (e && yt.global.timezoneOffset || 0) * 6e4; Ot = e ? Date.UTC : function (e, t, n, r, i, s) { return (new Date(e, t, d(n, 1), d(r, 0), d(i, 0), d(s, 0))).getTime() }; _t = t + "Minutes"; Dt = t + "Hours"; Pt = t + "Day"; Ht = t + "Date"; Bt = t + "Month"; jt = t + "FullYear"; Ft = n + "Minutes"; It = n + "Hours"; qt = n + "Date"; Rt = n + "Month"; Ut = n + "FullYear" } function P() { } function H(e, t, n, r) { this.axis = e; this.pos = t; this.type = n || ""; this.isNew = !0; !n && !r && this.addLabel() } function B(e, t, n, r, i, s) { var o = e.chart.inverted; this.axis = e; this.isNegative = n; this.options = t; this.x = r; this.total = null; this.points = {}; this.stack = i; this.percent = s === "percent"; this.alignOptions = { align: t.align || (o ? n ? "left" : "right" : "center"), verticalAlign: t.verticalAlign || (o ? "middle" : n ? "bottom" : "top"), y: d(t.y, o ? 4 : n ? 14 : -6), x: d(t.x, o ? n ? -6 : 6 : 0) }; this.textAlign = t.textAlign || (o ? n ? "right" : "left" : "center") } function j() { this.init.apply(this, arguments) } function F() { this.init.apply(this, arguments) } function I() { this.init.apply(this, arguments) } function q(e) { var t = e.options, n = t.navigator, r = n.enabled, t = t.scrollbar, i = t.enabled, s = r ? n.height : 0, o = i ? t.height : 0; this.handles = []; this.scrollbarButtons = []; this.elementsToDestroy = []; this.chart = e; this.setBaseSeries(); this.height = s; this.scrollbarHeight = o; this.scrollbarEnabled = i; this.navigatorEnabled = r; this.navigatorOptions = n; this.scrollbarOptions = t; this.outlineHeight = s + o; this.init() } function R(e) { this.init(e) } var U, z = document, W = window, X = Math, V = X.round, $ = X.floor, J = X.ceil, K = X.max, Q = X.min, G = X.abs, Y = X.cos, Z = X.sin, et = X.PI, tt = et * 2 / 360, nt = navigator.userAgent, rt = W.opera, it = /msie/i.test(nt) && !rt, st = z.documentMode === 8, ot = /AppleWebKit/.test(nt), ut = /Firefox/.test(nt), at = /(Mobile|Android|Windows Phone)/.test(nt), ft = "http://www.w3.org/2000/svg", lt = !!z.createElementNS && !!z.createElementNS(ft, "svg").createSVGRect, ct = ut && parseInt(nt.split("Firefox/")[1], 10) < 4, ht = !lt && !it && !!z.createElement("canvas").getContext, pt, dt = z.documentElement.ontouchstart !== U, vt = {}, mt = 0, gt, yt, bt, wt, Et, St, xt = function () { }, Tt = [], Nt = "div", Ct = "none", kt = /^[0-9]+$/, Lt = "rgba(192,192,192," + (lt ? 1e-4 : .002) + ")", At = "stroke-width", Ot, Mt, _t, Dt, Pt, Ht, Bt, jt, Ft, It, qt, Rt, Ut, zt = {}; W.Highcharts = W.Highcharts ? O(16, !0) : {}; bt = function (t, n, r) { if (!c(n) || isNaN(n)) return "Invalid date"; var t = d(t, "%Y-%m-%d %H:%M:%S"), i = new Date(n - Mt), s, o = i[Dt](), u = i[Pt](), a = i[Ht](), f = i[Bt](), l = i[jt](), h = yt.lang, p = h.weekdays, i = e({ a: p[u].substr(0, 3), A: p[u], d: b(a), e: a, b: h.shortMonths[f], B: h.months[f], m: b(f + 1), y: l.toString().substr(2, 2), Y: l, H: b(o), I: b(o % 12 || 12), l: o % 12 || 12, M: b(i[_t]()), p: o < 12 ? "AM" : "PM", P: o < 12 ? "am" : "pm", S: b(i.getSeconds()), L: b(V(n % 1e3), 3) }, Highcharts.dateFormats); for (s in i) for (; t.indexOf("%" + s) !== -1; ) t = t.replace("%" + s, typeof i[s] === "function" ? i[s](n) : i[s]); return r ? t.substr(0, 1).toUpperCase() + t.substr(1) : t }; T.prototype = { wrapColor: function (e) { if (this.color >= e) this.color = 0 }, wrapSymbol: function (e) { if (this.symbol >= e) this.symbol = 0 } }; St = n("millisecond", 1, "second", 1e3, "minute", 6e4, "hour", 36e5, "day", 864e5, "week", 6048e5, "month", 26784e5, "year", 31556952e3); Et = { init: function (e, t, n) { var t = t || "", r = e.shift, i = t.indexOf("C") > -1, s = i ? 7 : 3, o, t = t.split(" "), n = [].concat(n), u, a, f = function (e) { for (o = e.length; o--; ) e[o] === "M" && e.splice(o + 1, 0, e[o + 1], e[o + 2], e[o + 1], e[o + 2]) }; i && (f(t), f(n)); e.isArea && (u = t.splice(t.length - 6, 6), a = n.splice(n.length - 6, 6)); if (r <= n.length / s && t.length === n.length) for (; r--; ) n = [].concat(n).splice(0, s).concat(n); e.shift = 0; if (t.length) for (e = n.length; t.length < e; ) r = [].concat(t).splice(t.length - s, s), i && (r[s - 6] = r[s - 2], r[s - 5] = r[s - 1]), t = t.concat(r); u && (t = t.concat(u), n = n.concat(a)); return [t, n] }, step: function (e, t, n, r) { var i = [], s = e.length; if (n === 1) i = r; else if (s === t.length && n < 1) for (; s--; ) r = parseFloat(e[s]), i[s] = isNaN(r) ? e[s] : n * parseFloat(t[s] - r) + r; else i = t; return i } }; (function (t) { W.HighchartsAdapter = W.HighchartsAdapter || t && { init: function (e) { var n = t.fx, r = n.step, s, o = t.Tween, u = o && o.propHooks; s = t.cssHooks.opacity; t.extend(t.easing, { easeOutQuad: function (e, t, n, r, i) { return -r * (t /= i) * (t - 2) + n } }); t.each(["cur", "_default", "width", "height", "opacity"], function (e, t) { var i = r, s; t === "cur" ? i = n.prototype : t === "_default" && o && (i = u[t], t = "set"); (s = i[t]) && (i[t] = function (n) { var r, n = e ? n : this; if (n.prop !== "align") return r = n.elem, r.attr ? r.attr(n.prop, t === "cur" ? U : n.now) : s.apply(this, arguments) }) }); w(s, "get", function (e, t, n) { return t.attr ? t.opacity || 0 : e.call(this, t, n) }); s = function (t) { var n = t.elem, r; if (!t.started) r = e.init(n, n.d, n.toD), t.start = r[0], t.end = r[1], t.started = !0; n.attr("d", e.step(t.start, t.end, t.pos, n.toD)) }; o ? u.d = { set: s} : r.d = s; this.each = Array.prototype.forEach ? function (e, t) { return Array.prototype.forEach.call(e, t) } : function (e, t) { for (var n = 0, r = e.length; n < r; n++) if (t.call(e[n], e[n], n, e) === !1) return n }; t.fn.highcharts = function () { var e = "Chart", t = arguments, n, r; i(t[0]) && (e = t[0], t = Array.prototype.slice.call(t, 1)); n = t[0]; if (n !== U) n.chart = n.chart || {}, n.chart.renderTo = this[0], new Highcharts[e](n, t[1]), r = this; n === U && (r = Tt[h(this[0], "data-highcharts-chart")]); return r } }, getScript: t.getScript, inArray: t.inArray, adapterRun: function (e, n) { return t(e)[n]() }, grep: t.grep, map: function (e, t) { for (var n = [], r = 0, i = e.length; r < i; r++) n[r] = t.call(e[r], e[r], r, e); return n }, offset: function (e) { return t(e).offset() }, addEvent: function (e, n, r) { t(e).bind(n, r) }, removeEvent: function (e, n, r) { var i = z.removeEventListener ? "removeEventListener" : "detachEvent"; z[i] && e && !e[i] && (e[i] = function () { }); t(e).unbind(n, r) }, fireEvent: function (n, r, i, s) { var o = t.Event(r), u = "detached" + r, a; !it && i && (delete i.layerX, delete i.layerY); e(o, i); n[r] && (n[u] = n[r], n[r] = null); t.each(["preventDefault", "stopPropagation"], function (e, t) { var n = o[t]; o[t] = function () { try { n.call(o) } catch (e) { t === "preventDefault" && (a = !0) } } }); t(n).trigger(o); n[u] && (n[r] = n[u], n[u] = null); s && !o.isDefaultPrevented() && !a && s(o) }, washMouseEvent: function (e) { var t = e.originalEvent || e; if (t.pageX === U) t.pageX = e.pageX, t.pageY = e.pageY; return t }, animate: function (e, n, r) { var i = t(e); if (!e.style) e.style = {}; if (n.d) e.toD = n.d, n.d = 1; i.stop(); n.opacity !== U && e.attr && (n.opacity += "px"); i.animate(n, r) }, stop: function (e) { t(e).stop() } } })(W.jQuery); var Wt = W.HighchartsAdapter, Xt = Wt || {}; Wt && Wt.init.call(Wt, Et); var Vt = Xt.adapterRun, $t = Xt.getScript, Jt = Xt.inArray, Kt = Xt.each, Qt = Xt.grep, Gt = Xt.offset, Yt = Xt.map, Zt = Xt.addEvent, en = Xt.removeEvent, tn = Xt.fireEvent, nn = Xt.washMouseEvent, rn = Xt.animate, sn = Xt.stop, Xt = { enabled: !0, x: 0, y: 15, style: { color: "#666", cursor: "default", fontSize: "11px", lineHeight: "14px"} }; yt = { colors: "#2f7ed8,#0d233a,#8bbc21,#910000,#1aadce,#492970,#f28f43,#77a1e5,#c42525,#a6c96a".split(","), symbols: ["circle", "diamond", "square", "triangle", "triangle-down"], lang: { loading: "Loading...", months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","), shortMonths: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","), weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","), decimalPoint: ".", numericSymbols: "k,M,G,T,P,E".split(","), resetZoom: "Reset zoom", resetZoomTitle: "Reset zoom level 1:1", thousandsSep: "," }, global: { useUTC: !0, canvasToolsURL: "http://code.highcharts.com/stock/1.3.8/modules/canvas-tools.js", VMLRadialGradientURL: "http://code.highcharts.com/stock/1.3.8/gfx/vml-radial-gradient.png" }, chart: { borderColor: "#4572A7", borderRadius: 5, defaultSeriesType: "line", ignoreHiddenSeries: !0, spacing: [10, 10, 15, 10], style: { fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif', fontSize: "12px" }, backgroundColor: "#FFFFFF", plotBorderColor: "#C0C0C0", resetZoomButton: { theme: { zIndex: 20 }, position: { align: "right", x: -10, y: 10}} }, title: { text: "Chart title", align: "center", margin: 15, style: { color: "#274b6d", fontSize: "16px"} }, subtitle: { text: "", align: "center", style: { color: "#4d759e"} }, plotOptions: { line: { allowPointSelect: !1, showCheckbox: !1, animation: { duration: 1e3 }, events: {}, lineWidth: 2, marker: { enabled: !0, lineWidth: 0, radius: 4, lineColor: "#FFFFFF", states: { hover: { enabled: !0 }, select: { fillColor: "#FFFFFF", lineColor: "#000000", lineWidth: 2}} }, point: { events: {} }, dataLabels: t(Xt, { align: "center", enabled: !1, formatter: function () { return this.y === null ? "" : y(this.y, -1) }, verticalAlign: "bottom", y: 0 }), cropThreshold: 300, pointRange: 0, states: { hover: { marker: {} }, select: { marker: {}} }, stickyTracking: !0, turboThreshold: 1e3} }, labels: { style: { position: "absolute", color: "#3E576F"} }, legend: { enabled: !0, align: "center", layout: "horizontal", labelFormatter: function () { return this.name }, borderWidth: 1, borderColor: "#909090", borderRadius: 5, navigation: { activeColor: "#274b6d", inactiveColor: "#CCC" }, shadow: !1, itemStyle: { cursor: "pointer", color: "#274b6d", fontSize: "12px" }, itemHoverStyle: { color: "#000" }, itemHiddenStyle: { color: "#CCC" }, itemCheckboxStyle: { position: "absolute", width: "13px", height: "13px" }, symbolPadding: 5, verticalAlign: "bottom", x: 0, y: 0, title: { style: { fontWeight: "bold"}} }, loading: { labelStyle: { fontWeight: "bold", position: "relative", top: "1em" }, style: { position: "absolute", backgroundColor: "white", opacity: .5, textAlign: "center"} }, tooltip: { enabled: !0, animation: lt, backgroundColor: "rgba(255, 255, 255, .85)", borderWidth: 1, borderRadius: 3, dateTimeLabelFormats: { millisecond: "%A, %b %e, %H:%M:%S.%L", second: "%A, %b %e, %H:%M:%S", minute: "%A, %b %e, %H:%M", hour: "%A, %b %e, %H:%M", day: "%A, %b %e, %Y", week: "Week from %A, %b %e, %Y", month: "%B %Y", year: "%Y" }, headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>', pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y}</b><br/>', shadow: !0, snap: at ? 25 : 10, style: { color: "#333333", cursor: "default", fontSize: "12px", padding: "8px", whiteSpace: "nowrap"} }, credits: { enabled: !0, text: "Highcharts.com", href: "http://www.highcharts.com", position: { align: "right", x: -10, verticalAlign: "bottom", y: -5 }, style: { cursor: "pointer", color: "#909090", fontSize: "9px"}} }; var on = yt.plotOptions, Wt = on.line; D(); var un = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/, an = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/, fn = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/, ln = function (e) { var n = [], i, s; (function (e) { e && e.stops ? s = Yt(e.stops, function (e) { return ln(e[1]) }) : (i = un.exec(e)) ? n = [r(i[1]), r(i[2]), r(i[3]), parseFloat(i[4], 10)] : (i = an.exec(e)) ? n = [r(i[1], 16), r(i[2], 16), r(i[3], 16), 1] : (i = fn.exec(e)) && (n = [r(i[1]), r(i[2]), r(i[3]), 1]) })(e); return { get: function (r) { var i; s ? (i = t(e), i.stops = [].concat(i.stops), Kt(s, function (e, t) { i.stops[t] = [i.stops[t][0], e.get(r)] })) : i = n && !isNaN(n[0]) ? r === "rgb" ? "rgb(" + n[0] + "," + n[1] + "," + n[2] + ")" : r === "a" ? n[3] : "rgba(" + n.join(",") + ")" : e; return i }, brighten: function (e) { if (s) Kt(s, function (t) { t.brighten(e) }); else if (u(e) && e !== 0) { var t; for (t = 0; t < 3; t++) n[t] += r(e * 255), n[t] < 0 && (n[t] = 0), n[t] > 255 && (n[t] = 255) } return this }, rgba: n, setOpacity: function (e) { n[3] = e; return this } } }; P.prototype = { init: function (e, t) { this.element = t === "span" ? m(t) : z.createElementNS(ft, t); this.renderer = e; this.attrSetters = {} }, opacity: 1, animate: function (e, n, r) { n = d(n, wt, !0); sn(this); if (n) { n = t(n); if (r) n.complete = r; rn(this, e, n) } else this.attr(e), r && r() }, attr: function (e, t) { var n, s, o, u, a = this.element, f = a.nodeName.toLowerCase(), l = this.renderer, p, v = this.attrSetters, m = this.shadows, g, y, b = this; i(e) && c(t) && (n = e, e = {}, e[n] = t); if (i(e)) n = e, f === "circle" ? n = { x: "cx", y: "cy"}[n] || n : n === "strokeWidth" && (n = "stroke-width"), b = h(a, n) || this[n] || 0, n !== "d" && n !== "visibility" && n !== "fill" && (b = parseFloat(b)); else { for (n in e) if (p = !1, s = e[n], o = v[n] && v[n].call(this, s, n), o !== !1) { o !== U && (s = o); if (n === "d") s && s.join && (s = s.join(" ")), /(NaN| {2}|^$)/.test(s) && (s = "M 0 0"); else if (n === "x" && f === "text") for (o = 0; o < a.childNodes.length; o++) u = a.childNodes[o], h(u, "x") === h(a, "x") && h(u, "x", s); else if (this.rotation && (n === "x" || n === "y")) y = !0; else if (n === "fill") s = l.color(s, a, n); else if (f === "circle" && (n === "x" || n === "y")) n = { x: "cx", y: "cy"}[n] || n; else if (f === "rect" && n === "r") h(a, { rx: s, ry: s }), p = !0; else if (n === "translateX" || n === "translateY" || n === "rotation" || n === "verticalAlign" || n === "scaleX" || n === "scaleY") p = y = !0; else if (n === "stroke") s = l.color(s, a, n); else if (n === "dashstyle") if (n = "stroke-dasharray", s = s && s.toLowerCase(), s === "solid") s = Ct; else { if (s) { s = s.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(","); for (o = s.length; o--; ) s[o] = r(s[o]) * d(e["stroke-width"], this["stroke-width"]); s = s.join(",") } } else if (n === "width") s = r(s); else if (n === "align") n = "text-anchor", s = { left: "start", center: "middle", right: "end"}[s]; else if (n === "title") o = a.getElementsByTagName("title")[0], o || (o = z.createElementNS(ft, "title"), a.appendChild(o)), o.textContent = s; n === "strokeWidth" && (n = "stroke-width"); if (n === "stroke-width" || n === "stroke") { this[n] = s; if (this.stroke && this["stroke-width"]) h(a, "stroke", this.stroke), h(a, "stroke-width", this["stroke-width"]), this.hasStroke = !0; else if (n === "stroke-width" && s === 0 && this.hasStroke) a.removeAttribute("stroke"), this.hasStroke = !1; p = !0 } this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(n) && (g || (this.symbolAttr(e), g = !0), p = !0); if (m && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(n)) for (o = m.length; o--; ) h(m[o], n, n === "height" ? K(s - (m[o].cutHeight || 0), 0) : s); if ((n === "width" || n === "height") && f === "rect" && s < 0) s = 0; this[n] = s; n === "text" ? (s !== this.textStr && delete this.bBox, this.textStr = s, this.added && l.buildText(this)) : p || h(a, n, s) } y && this.updateTransform() } return b }, addClass: function (e) { var t = this.element, n = h(t, "class") || ""; n.indexOf(e) === -1 && h(t, "class", n + " " + e); return this }, symbolAttr: function (e) { var t = this; Kt("x,y,r,start,end,width,height,innerR,anchorX,anchorY".split(","), function (n) { t[n] = d(e[n], t[n]) }); t.attr({ d: t.renderer.symbols[t.symbolName](t.x, t.y, t.width, t.height, t) }) }, clip: function (e) { return this.attr("clip-path", e ? "url(" + this.renderer.url + "#" + e.id + ")" : Ct) }, crisp: function (e, t, n, r, i) { var s, o = {}, u = {}, a, e = e || this.strokeWidth || this.attr && this.attr("stroke-width") || 0; a = V(e) % 2 / 2; u.x = $(t || this.x || 0) + a; u.y = $(n || this.y || 0) + a; u.width = $((r || this.width || 0) - 2 * a); u.height = $((i || this.height || 0) - 2 * a); u.strokeWidth = e; for (s in u) this[s] !== u[s] && (this[s] = o[s] = u[s]); return o }, css: function (t) { var n = this.element, i = this.textWidth = t && t.width && n.nodeName.toLowerCase() === "text" && r(t.width), s, o = "", u = function (e, t) { return "-" + t.toLowerCase() }; if (t && t.color) t.fill = t.color; this.styles = t = e(this.styles, t); i && delete t.width; if (it && !lt) v(this.element, t); else { for (s in t) o += s.replace(/([A-Z])/g, u) + ":" + t[s] + ";"; h(n, "style", o) } i && this.added && this.renderer.buildText(this); return this }, on: function (e, t) { var n = this, r = n.element; dt && e === "click" ? (r.ontouchstart = function (e) { n.touchEventFired = Date.now(); e.preventDefault(); t.call(r, e) }, r.onclick = function (e) { (nt.indexOf("Android") === -1 || Date.now() - (n.touchEventFired || 0) > 1100) && t.call(r, e) }) : r["on" + e] = t; return this }, setRadialReference: function (e) { this.element.radialReference = e; return this }, translate: function (e, t) { return this.attr({ translateX: e, translateY: t }) }, invert: function () { this.inverted = !0; this.updateTransform(); return this }, updateTransform: function () { var e = this.translateX || 0, t = this.translateY || 0, n = this.scaleX, r = this.scaleY, i = this.inverted, s = this.rotation; i && (e += this.attr("width"), t += this.attr("height")); e = ["translate(" + e + "," + t + ")"]; i ? e.push("rotate(90) scale(-1,1)") : s && e.push("rotate(" + s + " " + (this.x || 0) + " " + (this.y || 0) + ")"); (c(n) || c(r)) && e.push("scale(" + d(n, 1) + " " + d(r, 1) + ")"); e.length && h(this.element, "transform", e.join(" ")) }, toFront: function () { var e = this.element; e.parentNode.appendChild(e); return this }, align: function (e, t, n) { var r, s, o, u, a = {}; s = this.renderer; o = s.alignedObjects; if (e) { if (this.alignOptions = e, this.alignByTranslate = t, !n || i(n)) this.alignTo = r = n || "renderer", l(o, this), o.push(this), n = null } else e = this.alignOptions, t = this.alignByTranslate, r = this.alignTo; n = d(n, s[r], s); r = e.align; s = e.verticalAlign; o = (n.x || 0) + (e.x || 0); u = (n.y || 0) + (e.y || 0); if (r === "right" || r === "center") o += (n.width - (e.width || 0)) / { right: 1, center: 2}[r]; a[t ? "translateX" : "x"] = V(o); if (s === "bottom" || s === "middle") u += (n.height - (e.height || 0)) / ({ bottom: 1, middle: 2}[s] || 1); a[t ? "translateY" : "y"] = V(u); this[this.placed ? "animate" : "attr"](a); this.placed = !0; this.alignAttr = a; return this }, getBBox: function () { var t = this.bBox, n = this.renderer, r, i, s = this.rotation; r = this.element; var o = this.styles, u = s * tt; i = this.textStr; var a; if (i === "" || kt.test(i)) a = i.length + "|" + o.fontSize + "|" + o.fontFamily, t = n.cache[a]; if (!t) { if (r.namespaceURI === ft || n.forExport) { try { t = r.getBBox ? e({}, r.getBBox()) : { width: r.offsetWidth, height: r.offsetHeight} } catch (f) { } if (!t || t.width < 0) t = { width: 0, height: 0} } else t = this.htmlGetBBox(); if (n.isSVG) { r = t.width; i = t.height; if (it && o && o.fontSize === "11px" && i.toPrecision(3) === "22.7") t.height = i = 14; if (s) t.width = G(i * Z(u)) + G(r * Y(u)), t.height = G(i * Y(u)) + G(r * Z(u)) } this.bBox = t; a && (n.cache[a] = t) } return t }, show: function () { return this.attr({ visibility: "visible" }) }, hide: function () { return this.attr({ visibility: "hidden" }) }, fadeOut: function (e) { var t = this; t.animate({ opacity: 0 }, { duration: e || 150, complete: function () { t.hide() } }) }, add: function (e) { var t = this.renderer, n = e || t, i = n.element || t.box, s = i.childNodes, o = this.element, u = h(o, "zIndex"), a; if (e) this.parentGroup = e; this.parentInverted = e && e.inverted; this.textStr !== void 0 && t.buildText(this); if (u) n.handleZ = !0, u = r(u); if (n.handleZ) for (n = 0; n < s.length; n++) if (e = s[n], t = h(e, "zIndex"), e !== o && (r(t) > u || !c(u) && c(t))) { i.insertBefore(o, e); a = !0; break } a || i.appendChild(o); this.added = !0; tn(this, "add"); return this }, safeRemoveChild: function (e) { var t = e.parentNode; t && t.removeChild(e) }, destroy: function () { var e = this, t = e.element || {}, n = e.shadows, r = e.renderer.isSVG && t.nodeName === "SPAN" && e.parentGroup, i, s; t.onclick = t.onmouseout = t.onmouseover = t.onmousemove = t.point = null; sn(e); if (e.clipPath) e.clipPath = e.clipPath.destroy(); if (e.stops) { for (s = 0; s < e.stops.length; s++) e.stops[s] = e.stops[s].destroy(); e.stops = null } e.safeRemoveChild(t); for (n && Kt(n, function (t) { e.safeRemoveChild(t) }); r && r.div.childNodes.length === 0; ) t = r.parentGroup, e.safeRemoveChild(r.div), delete r.div, r = t; e.alignTo && l(e.renderer.alignedObjects, e); for (i in e) delete e[i]; return null }, shadow: function (e, t, n) { var r = [], i, s, o = this.element, u, a, f, l; if (e) { a = d(e.width, 3); f = (e.opacity || .15) / a; l = this.parentInverted ? "(-1,-1)" : "(" + d(e.offsetX, 1) + ", " + d(e.offsetY, 1) + ")"; for (i = 1; i <= a; i++) { s = o.cloneNode(0); u = a * 2 + 1 - 2 * i; h(s, { isShadow: "true", stroke: e.color || "black", "stroke-opacity": f * i, "stroke-width": u, transform: "translate" + l, fill: Ct }); if (n) h(s, "height", K(h(s, "height") - u, 0)), s.cutHeight = u; t ? t.element.appendChild(s) : o.parentNode.insertBefore(s, o); r.push(s) } this.shadows = r } return this } }; var cn = function () { this.init.apply(this, arguments) }; cn.prototype = { Element: P, init: function (e, t, n, r) { var i = location, s, o; s = this.createElement("svg").attr({ version: "1.1" }); o = s.element; e.appendChild(o); e.innerHTML.indexOf("xmlns") === -1 && h(o, "xmlns", ft); this.isSVG = !0; this.box = o; this.boxWrapper = s; this.alignedObjects = []; this.url = (ut || ot) && z.getElementsByTagName("base").length ? i.href.replace(/#.*?$/, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : ""; this.createElement("desc").add().element.appendChild(z.createTextNode("Created with Highstock 1.3.8")); this.defs = this.createElement("defs").add(); this.forExport = r; this.gradients = {}; this.cache = {}; this.setSize(t, n, !1); var u; if (ut && e.getBoundingClientRect) this.subPixelFix = t = function () { v(e, { left: 0, top: 0 }); u = e.getBoundingClientRect(); v(e, { left: J(u.left) - u.left + "px", top: J(u.top) - u.top + "px" }) }, t(), Zt(W, "resize", t) }, isHidden: function () { return !this.boxWrapper.getBBox().width }, destroy: function () { var e = this.defs; this.box = null; this.boxWrapper = this.boxWrapper.destroy(); L(this.gradients || {}); this.gradients = null; if (e) this.defs = e.destroy(); this.subPixelFix && en(W, "resize", this.subPixelFix); return this.alignedObjects = null }, createElement: function (e) { var t = new this.Element; t.init(this, e); return t }, draw: function () { }, buildText: function (e) { for (var t = e.element, n = this, i = n.forExport, s = d(e.textStr, "").toString().replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">').replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(/<br.*?>/g), o = t.childNodes, u = /style="([^"]+)"/, a = /href="(http[^"]+)"/, f = h(t, "x"), l = e.styles, c = e.textWidth, p = l && l.lineHeight, m = o.length; m--; ) t.removeChild(o[m]); c && !e.added && this.box.appendChild(t); s[s.length - 1] === "" && s.pop(); Kt(s, function (s, o) { var d, m = 0, s = s.replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||"); d = s.split("|||"); Kt(d, function (s) { if (s !== "" || d.length === 1) { var g = {}, y = z.createElementNS(ft, "tspan"), b; u.test(s) && (b = s.match(u)[1].replace(/(;| |^)color([ :])/, "$1fill$2"), h(y, "style", b)); a.test(s) && !i && (h(y, "onclick", 'location.href="' + s.match(a)[1] + '"'), v(y, { cursor: "pointer" })); s = (s.replace(/<(.|\n)*?>/g, "") || " ").replace(/&lt;/g, "<").replace(/&gt;/g, ">"); if (s !== " " && (y.appendChild(z.createTextNode(s)), m ? g.dx = 0 : g.x = f, h(y, g), !m && o && (!lt && i && v(y, { display: "block" }), h(y, "dy", p || n.fontMetrics(/px$/.test(y.style.fontSize) ? y.style.fontSize : l.fontSize).h, ot && y.offsetHeight)), t.appendChild(y), m++, c)) for (var s = s.replace(/([^\^])-/g, "$1- ").split(" "), g = s.length > 1 && l.whiteSpace !== "nowrap", w, E, S = e._clipHeight, x = [], T = r(p || 16), N = 1; g && (s.length || x.length); ) delete e.bBox, w = e.getBBox(), E = w.width, !lt && n.forExport && (E = n.measureSpanWidth(y.firstChild.data, e.styles)), w = E > c, !w || s.length === 1 ? (s = x, x = [], s.length && (N++, S && N * T > S ? (s = ["..."], e.attr("title", e.textStr)) : (y = z.createElementNS(ft, "tspan"), h(y, { dy: T, x: f }), b && h(y, "style", b), t.appendChild(y), E > c && (c = E)))) : (y.removeChild(y.firstChild), x.unshift(s.pop())), s.length && y.appendChild(z.createTextNode(s.join(" ").replace(/- /g, "-"))) } }) }) }, button: function (n, r, i, s, o, u, a, f, l) { var c = this.label(n, r, i, l, null, null, null, null, "button"), h = 0, p, d, v, m, g, y, n = { x1: 0, y1: 0, x2: 0, y2: 1 }, o = t({ "stroke-width": 1, stroke: "#CCCCCC", fill: { linearGradient: n, stops: [[0, "#FEFEFE"], [1, "#F6F6F6"]] }, r: 2, padding: 5, style: { color: "black"} }, o); v = o.style; delete o.style; u = t(o, { stroke: "#68A", fill: { linearGradient: n, stops: [[0, "#FFF"], [1, "#ACF"]]} }, u); m = u.style; delete u.style; a = t(o, { stroke: "#68A", fill: { linearGradient: n, stops: [[0, "#9BD"], [1, "#CDF"]]} }, a); g = a.style; delete a.style; f = t(o, { style: { color: "#CCC"} }, f); y = f.style; delete f.style; Zt(c.element, it ? "mouseover" : "mouseenter", function () { h !== 3 && c.attr(u).css(m) }); Zt(c.element, it ? "mouseout" : "mouseleave", function () { h !== 3 && (p = [o, u, a][h], d = [v, m, g][h], c.attr(p).css(d)) }); c.setState = function (e) { (c.state = h = e) ? e === 2 ? c.attr(a).css(g) : e === 3 && c.attr(f).css(y) : c.attr(o).css(v) }; return c.on("click", function () { h !== 3 && s.call(c) }).attr(o).css(e({ cursor: "default" }, v)) }, crispLine: function (e, t) { e[1] === e[4] && (e[1] = e[4] = V(e[1]) - t % 2 / 2); e[2] === e[5] && (e[2] = e[5] = V(e[2]) + t % 2 / 2); return e }, path: function (t) { var n = { fill: Ct }; o(t) ? n.d = t : s(t) && e(n, t); return this.createElement("path").attr(n) }, circle: function (e, t, n) { e = s(e) ? e : { x: e, y: t, r: n }; return this.createElement("circle").attr(e) }, arc: function (e, t, n, r, i, o) { if (s(e)) t = e.y, n = e.r, r = e.innerR, i = e.start, o = e.end, e = e.x; e = this.symbol("arc", e || 0, t || 0, n || 0, n || 0, { innerR: r || 0, start: i || 0, end: o || 0 }); e.r = n; return e }, rect: function (e, t, n, r, i, o) { i = s(e) ? e.r : i; i = this.createElement("rect").attr({ rx: i, ry: i, fill: Ct }); return i.attr(s(e) ? e : i.crisp(o, e, t, K(n, 0), K(r, 0))) }, setSize: function (e, t, n) { var r = this.alignedObjects, i = r.length; this.width = e; this.height = t; for (this.boxWrapper[d(n, !0) ? "animate" : "attr"]({ width: e, height: t }); i--; ) r[i].align() }, g: function (e) { var t = this.createElement("g"); return c(e) ? t.attr({ "class": "highcharts-" + e }) : t }, image: function (t, n, r, i, s) { var o = { preserveAspectRatio: Ct }; arguments.length > 1 && e(o, { x: n, y: r, width: i, height: s }); o = this.createElement("image").attr(o); o.element.setAttributeNS ? o.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", t) : o.element.setAttribute("hc-svg-href", t); return o }, symbol: function (t, n, r, i, s, o) { var u, a = this.symbols[t], a = a && a(V(n), V(r), i, s, o), f = /^url\((.*?)\)$/, l, c; if (a) u = this.path(a), e(u, { symbolName: t, x: n, y: r, width: i, height: s }), o && e(u, o); else if (f.test(t)) c = function (e, t) { e.element && (e.attr({ width: t[0], height: t[1] }), e.alignByTranslate || e.translate(V((i - t[0]) / 2), V((s - t[1]) / 2))) }, l = t.match(f)[1], t = vt[l], u = this.image(l).attr({ x: n, y: r }), u.isImg = !0, t ? c(u, t) : (u.attr({ width: 0, height: 0 }), m("img", { onload: function () { c(u, vt[l] = [this.width, this.height]) }, src: l })); return u }, symbols: { circle: function (e, t, n, r) { var i = .166 * n; return ["M", e + n / 2, t, "C", e + n + i, t, e + n + i, t + r, e + n / 2, t + r, "C", e - i, t + r, e - i, t, e + n / 2, t, "Z"] }, square: function (e, t, n, r) { return ["M", e, t, "L", e + n, t, e + n, t + r, e, t + r, "Z"] }, triangle: function (e, t, n, r) { return ["M", e + n / 2, t, "L", e + n, t + r, e, t + r, "Z"] }, "triangle-down": function (e, t, n, r) { return ["M", e, t, "L", e + n, t, e + n / 2, t + r, "Z"] }, diamond: function (e, t, n, r) { return ["M", e + n / 2, t, "L", e + n, t + r / 2, e + n / 2, t + r, e, t + r / 2, "Z"] }, arc: function (e, t, n, r, i) { var s = i.start, n = i.r || n || r, o = i.end - .001, r = i.innerR, u = i.open, a = Y(s), f = Z(s), l = Y(o), o = Z(o), i = i.end - s < et ? 0 : 1; return ["M", e + n * a, t + n * f, "A", n, n, 0, i, 1, e + n * l, t + n * o, u ? "M" : "L", e + r * l, t + r * o, "A", r, r, 0, i, 0, e + r * a, t + r * f, u ? "" : "Z"] } }, clipRect: function (e, t, n, r) { var i = "highcharts-" + mt++, s = this.createElement("clipPath").attr({ id: i }).add(this.defs), e = this.rect(e, t, n, r, 0).add(s); e.id = i; e.clipPath = s; return e }, color: function (e, n, r) { var i = this, s, u = /^rgba/, a, f, l, p, d, v, m, g = []; e && e.linearGradient ? a = "linearGradient" : e && e.radialGradient && (a = "radialGradient"); if (a) { r = e[a]; f = i.gradients; p = e.stops; n = n.radialReference; o(r) && (e[a] = r = { x1: r[0], y1: r[1], x2: r[2], y2: r[3], gradientUnits: "userSpaceOnUse" }); a === "radialGradient" && n && !c(r.gradientUnits) && (r = t(r, { cx: n[0] - n[2] / 2 + r.cx * n[2], cy: n[1] - n[2] / 2 + r.cy * n[2], r: r.r * n[2], gradientUnits: "userSpaceOnUse" })); for (m in r) m !== "id" && g.push(m, r[m]); for (m in p) g.push(p[m]); g = g.join(","); f[g] ? e = f[g].id : (r.id = e = "highcharts-" + mt++, f[g] = l = i.createElement(a).attr(r).add(i.defs), l.stops = [], Kt(p, function (e) { u.test(e[1]) ? (s = ln(e[1]), d = s.get("rgb"), v = s.get("a")) : (d = e[1], v = 1); e = i.createElement("stop").attr({ offset: e[0], "stop-color": d, "stop-opacity": v }).add(l); l.stops.push(e) })); return "url(" + i.url + "#" + e + ")" } else return u.test(e) ? (s = ln(e), h(n, r + "-opacity", s.get("a")), s.get("rgb")) : (n.removeAttribute(r + "-opacity"), e) }, text: function (e, t, n, r) { var i = yt.chart.style, s = ht || !lt && this.forExport; if (r && !this.forExport) return this.html(e, t, n); t = V(d(t, 0)); n = V(d(n, 0)); e = this.createElement("text").attr({ x: t, y: n, text: e }).css({ fontFamily: i.fontFamily, fontSize: i.fontSize }); s && e.css({ position: "absolute" }); e.x = t; e.y = n; return e }, fontMetrics: function (e) { var e = r(e || 11), e = e < 24 ? e + 4 : V(e * 1.2), t = V(e * .8); return { h: e, b: t} }, label: function (n, r, i, s, o, u, a, f, l) { function h() { var e, n; e = y.element.style; w = (T === void 0 || N === void 0 || g.styles.textAlign) && y.getBBox(); g.width = (T || w.width || 0) + 2 * S + x; g.height = (N || w.height || 0) + 2 * S; O = S + m.fontMetrics(e && e.fontSize).b; if (M) { if (!b) e = V(-E * S), n = f ? -O : 0, g.box = b = s ? m.symbol(s, e, n, g.width, g.height, A) : m.rect(e, n, g.width, g.height, 0, A[At]), b.add(g); b.isImg || b.attr(t({ width: g.width, height: g.height }, A)); A = null } } function p() { var e = g.styles, e = e && e.textAlign, t = x + S * (1 - E), n; n = f ? 0 : O; if (c(T) && (e === "center" || e === "right")) t += { center: .5, right: 1}[e] * (T - w.width); (t !== y.x || n !== y.y) && y.attr({ x: t, y: n }); y.x = t; y.y = n } function d(e, t) { b ? b.attr(e, t) : A[e] = t } function v() { y.add(g); g.attr({ text: n, x: r, y: i }); b && c(o) && g.attr({ anchorX: o, anchorY: u }) } var m = this, g = m.g(l), y = m.text("", 0, 0, a).attr({ zIndex: 1 }), b, w, E = 0, S = 3, x = 0, T, N, C, k, L = 0, A = {}, O, a = g.attrSetters, M; Zt(g, "add", v); a.width = function (e) { T = e; return !1 }; a.height = function (e) { N = e; return !1 }; a.padding = function (e) { c(e) && e !== S && (S = e, p()); return !1 }; a.paddingLeft = function (e) { c(e) && e !== x && (x = e, p()); return !1 }; a.align = function (e) { E = { left: 0, center: .5, right: 1}[e]; return !1 }; a.text = function (e, t) { y.attr(t, e); h(); p(); return !1 }; a[At] = function (e, t) { M = !0; L = e % 2 / 2; d(t, e); return !1 }; a.stroke = a.fill = a.r = function (e, t) { t === "fill" && (M = !0); d(t, e); return !1 }; a.anchorX = function (e, t) { o = e; d(t, e + L - C); return !1 }; a.anchorY = function (e, t) { u = e; d(t, e - k); return !1 }; a.x = function (e) { g.x = e; e -= E * ((T || w.width) + S); C = V(e); g.attr("translateX", C); return !1 }; a.y = function (e) { k = g.y = V(e); g.attr("translateY", k); return !1 }; var _ = g.css; return e(g, { css: function (e) { if (e) { var n = {}, e = t(e); Kt("fontSize,fontWeight,fontFamily,color,lineHeight,width,textDecoration,textShadow".split(","), function (t) { e[t] !== U && (n[t] = e[t], delete e[t]) }); y.css(n) } return _.call(g, e) }, getBBox: function () { return { width: w.width + 2 * S, height: w.height + 2 * S, x: w.x - S, y: w.y - S} }, shadow: function (e) { b && b.shadow(e); return g }, destroy: function () { en(g, "add", v); en(g.element, "mouseenter"); en(g.element, "mouseleave"); y && (y = y.destroy()); b && (b = b.destroy()); P.prototype.destroy.call(g); g = m = h = p = d = v = null } }) } }; pt = cn; e(P.prototype, { htmlCss: function (t) { var n = this.element; if (n = t && n.tagName === "SPAN" && t.width) delete t.width, this.textWidth = n, this.updateTransform(); this.styles = e(this.styles, t); v(this.element, t); return this }, htmlGetBBox: function () { var e = this.element, t = this.bBox; if (!t) { if (e.nodeName === "text") e.style.position = "absolute"; t = this.bBox = { x: e.offsetLeft, y: e.offsetTop, width: e.offsetWidth, height: e.offsetHeight} } return t }, htmlUpdateTransform: function () { if (this.added) { var e = this.renderer, t = this.element, n = this.translateX || 0, i = this.translateY || 0, s = this.x || 0, o = this.y || 0, u = this.textAlign || "left", a = { left: 0, center: .5, right: 1}[u], f = this.shadows; v(t, { marginLeft: n, marginTop: i }); f && Kt(f, function (e) { v(e, { marginLeft: n + 1, marginTop: i + 1 }) }); this.inverted && Kt(t.childNodes, function (n) { e.invertChild(n, t) }); if (t.tagName === "SPAN") { var l = this.rotation, h, p = r(this.textWidth), m = [l, u, t.innerHTML, this.textWidth].join(","); if (m !== this.cTT) { h = e.fontMetrics(t.style.fontSize).b; c(l) && this.setSpanRotation(l, a, h); f = d(this.elemWidth, t.offsetWidth); if (f > p && /[ \-]/.test(t.textContent || t.innerText)) v(t, { width: p + "px", display: "block", whiteSpace: "normal" }), f = p; this.getSpanCorrection(f, h, a, l, u) } v(t, { left: s + (this.xCorr || 0) + "px", top: o + (this.yCorr || 0) + "px" }); if (ot) h = t.offsetHeight; this.cTT = m } } else this.alignOnAdd = !0 }, setSpanRotation: function (e, t, n) { var r = {}, i = it ? "-ms-transform" : ot ? "-webkit-transform" : ut ? "MozTransform" : rt ? "-o-transform" : ""; r[i] = r.transform = "rotate(" + e + "deg)"; r[i + (ut ? "Origin" : "-origin")] = t * 100 + "% " + n + "px"; v(this.element, r) }, getSpanCorrection: function (e, t, n) { this.xCorr = -e * n; this.yCorr = -t } }); e(cn.prototype, { html: function (t, n, r) { var i = yt.chart.style, s = this.createElement("span"), o = s.attrSetters, u = s.element, a = s.renderer; o.text = function (e) { e !== u.innerHTML && delete this.bBox; u.innerHTML = e; return !1 }; o.x = o.y = o.align = o.rotation = function (e, t) { t === "align" && (t = "textAlign"); s[t] = e; s.htmlUpdateTransform(); return !1 }; s.attr({ text: t, x: V(n), y: V(r) }).css({ position: "absolute", whiteSpace: "nowrap", fontFamily: i.fontFamily, fontSize: i.fontSize }); s.css = s.htmlCss; if (a.isSVG) s.add = function (t) { var n, r = a.box.parentNode, i = []; if (this.parentGroup = t) { if (n = t.div, !n) { for (; t; ) i.push(t), t = t.parentGroup; Kt(i.reverse(), function (t) { var i; n = t.div = t.div || m(Nt, { className: h(t.element, "class") }, { position: "absolute", left: (t.translateX || 0) + "px", top: (t.translateY || 0) + "px" }, n || r); i = n.style; e(t.attrSetters, { translateX: function (e) { i.left = e + "px" }, translateY: function (e) { i.top = e + "px" }, visibility: function (e, t) { i[t] = e } }) }) } } else n = r; n.appendChild(u); s.added = !0; s.alignOnAdd && s.htmlUpdateTransform(); return s }; return s } }); var hn, pn; if (!lt && !ht) Highcharts.VMLElement = pn = { init: function (e, t) { var n = ["<", t, ' filled="f" stroked="f"'], r = ["position: ", "absolute", ";"], i = t === Nt; (t === "shape" || i) && r.push("left:0;top:0;width:1px;height:1px;"); r.push("visibility: ", i ? "hidden" : "visible"); n.push(' style="', r.join(""), '"/>'); if (t) n = i || t === "span" || t === "img" ? n.join("") : e.prepVML(n), this.element = m(n); this.renderer = e; this.attrSetters = {} }, add: function (e) { var t = this.renderer, n = this.element, r = t.box, r = e ? e.element || e : r; e && e.inverted && t.invertChild(n, r); r.appendChild(n); this.added = !0; this.alignOnAdd && !this.deferUpdateTransform && this.updateTransform(); tn(this, "add"); return this }, updateTransform: P.prototype.htmlUpdateTransform, setSpanRotation: function () { var e = this.rotation, t = Y(e * tt), n = Z(e * tt); v(this.element, { filter: e ? ["progid:DXImageTransform.Microsoft.Matrix(M11=", t, ", M12=", -n, ", M21=", n, ", M22=", t, ", sizingMethod='auto expand')"].join("") : Ct }) }, getSpanCorrection: function (e, t, n, r, i) { var s = r ? Y(r * tt) : 1, o = r ? Z(r * tt) : 0, u = d(this.elemHeight, this.element.offsetHeight), a; this.xCorr = s < 0 && -e; this.yCorr = o < 0 && -u; a = s * o < 0; this.xCorr += o * t * (a ? 1 - n : n); this.yCorr -= s * t * (r ? a ? n : 1 - n : 1); i && i !== "left" && (this.xCorr -= e * n * (s < 0 ? -1 : 1), r && (this.yCorr -= u * n * (o < 0 ? -1 : 1)), v(this.element, { textAlign: i })) }, pathToVML: function (e) { for (var t = e.length, n = []; t--; ) if (u(e[t])) n[t] = V(e[t] * 10) - 5; else if (e[t] === "Z") n[t] = "x"; else if (n[t] = e[t], e.isArc && (e[t] === "wa" || e[t] === "at")) n[t + 5] === n[t + 7] && (n[t + 7] += e[t + 7] > e[t + 5] ? 1 : -1), n[t + 6] === n[t + 8] && (n[t + 8] += e[t + 8] > e[t + 6] ? 1 : -1); return n.join(" ") || "x" }, attr: function (e, t) { var n, r, s, o = this.element || {}, a = o.style, f = o.nodeName, l = this.renderer, p = this.symbolName, d, v = this.shadows, g, y = this.attrSetters, b = this; i(e) && c(t) && (n = e, e = {}, e[n] = t); if (i(e)) n = e, b = n === "strokeWidth" || n === "stroke-width" ? this.strokeweight : this[n]; else for (n in e) if (r = e[n], g = !1, s = y[n] && y[n].call(this, r, n), s !== !1 && r !== null) { s !== U && (r = s); if (p && /^(x|y|r|start|end|width|height|innerR|anchorX|anchorY)/.test(n)) d || (this.symbolAttr(e), d = !0), g = !0; else if (n === "d") { r = r || []; this.d = r.join(" "); o.path = r = this.pathToVML(r); if (v) for (s = v.length; s--; ) v[s].path = v[s].cutOff ? this.cutOffPath(r, v[s].cutOff) : r; g = !0 } else if (n === "visibility") { if (v) for (s = v.length; s--; ) v[s].style[n] = r; f === "DIV" && (r = r === "hidden" ? "-999em" : 0, st || (a[n] = r ? "visible" : "hidden"), n = "top"); a[n] = r; g = !0 } else if (n === "zIndex") r && (a[n] = r), g = !0; else if (Jt(n, ["x", "y", "width", "height"]) !== -1) this[n] = r, n === "x" || n === "y" ? n = { x: "left", y: "top"}[n] : r = K(0, r), this.updateClipping ? (this[n] = r, this.updateClipping()) : a[n] = r, g = !0; else if (n === "class" && f === "DIV") o.className = r; else if (n === "stroke") r = l.color(r, o, n), n = "strokecolor"; else if (n === "stroke-width" || n === "strokeWidth") o.stroked = r ? !0 : !1, n = "strokeweight", this[n] = r, u(r) && (r += "px"); else if (n === "dashstyle") (o.getElementsByTagName("stroke")[0] || m(l.prepVML(["<stroke/>"]), null, null, o))[n] = r || "solid", this.dashstyle = r, g = !0; else if (n === "fill") if (f === "SPAN") a.color = r; else { if (f !== "IMG") o.filled = r !== Ct ? !0 : !1, r = l.color(r, o, n, this), n = "fillcolor" } else if (n === "opacity") g = !0; else if (f === "shape" && n === "rotation") this[n] = o.style[n] = r, o.style.left = -V(Z(r * tt) + 1) + "px", o.style.top = V(Y(r * tt)) + "px"; else if (n === "translateX" || n === "translateY" || n === "rotation") this[n] = r, this.updateTransform(), g = !0; g || (st ? o[n] = r : h(o, n, r)) } return b }, clip: function (e) { var t = this, n; e ? (n = e.members, l(n, t), n.push(t), t.destroyClip = function () { l(n, t) }, e = e.getCSS(t)) : (t.destroyClip && t.destroyClip(), e = { clip: st ? "inherit" : "rect(auto)" }); return t.css(e) }, css: P.prototype.htmlCss, safeRemoveChild: function (e) { e.parentNode && A(e) }, destroy: function () { this.destroyClip && this.destroyClip(); return P.prototype.destroy.apply(this) }, on: function (e, t) { this.element["on" + e] = function () { var e = W.event; e.target = e.srcElement; t(e) }; return this }, cutOffPath: function (e, t) { var n, e = e.split(/[ ,]/); n = e.length; if (n === 9 || n === 11) e[n - 4] = e[n - 2] = r(e[n - 2]) - 10 * t; return e.join(" ") }, shadow: function (e, t, n) { var i = [], s, o = this.element, u = this.renderer, a, f = o.style, l, c = o.path, h, p, v, g; c && typeof c.value !== "string" && (c = "x"); p = c; if (e) { v = d(e.width, 3); g = (e.opacity || .15) / v; for (s = 1; s <= 3; s++) { h = v * 2 + 1 - 2 * s; n && (p = this.cutOffPath(c.value, h + .5)); l = ['<shape isShadow="true" strokeweight="', h, '" filled="false" path="', p, '" coordsize="10 10" style="', o.style.cssText, '" />']; a = m(u.prepVML(l), null, { left: r(f.left) + d(e.offsetX, 1), top: r(f.top) + d(e.offsetY, 1) }); if (n) a.cutOff = h + 1; l = ['<stroke color="', e.color || "black", '" opacity="', g * s, '"/>']; m(u.prepVML(l), null, null, a); t ? t.element.appendChild(a) : o.parentNode.insertBefore(a, o); i.push(a) } this.shadows = i } return this } }, pn = g(P, pn), pn = { Element: pn, isIE8: nt.indexOf("MSIE 8.0") > -1, init: function (e, t, n) { var r, i; this.alignedObjects = []; r = this.createElement(Nt); i = r.element; i.style.position = "relative"; e.appendChild(r.element); this.isVML = !0; this.box = i; this.boxWrapper = r; this.cache = {}; this.setSize(t, n, !1); if (!z.namespaces.hcv) { z.namespaces.add("hcv", "urn:schemas-microsoft-com:vml"); try { z.createStyleSheet().cssText = "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } " } catch (s) { z.styleSheets[0].cssText += "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } " } } }, isHidden: function () { return !this.box.offsetWidth }, clipRect: function (t, n, r, i) { var o = this.createElement(), u = s(t); return e(o, { members: [], left: (u ? t.x : t) + 1, top: (u ? t.y : n) + 1, width: (u ? t.width : r) - 1, height: (u ? t.height : i) - 1, getCSS: function (t) { var n = t.element, r = n.nodeName, t = t.inverted, i = this.top - (r === "shape" ? n.offsetTop : 0), s = this.left, n = s + this.width, o = i + this.height, i = { clip: "rect(" + V(t ? s : i) + "px," + V(t ? o : n) + "px," + V(t ? n : o) + "px," + V(t ? i : s) + "px)" }; !t && st && r === "DIV" && e(i, { width: n + "px", height: o + "px" }); return i }, updateClipping: function () { Kt(o.members, function (e) { e.css(o.getCSS(e)) }) } }) }, color: function (e, t, n, r) { var i = this, s, o = /^rgba/, u, a, f = Ct; e && e.linearGradient ? a = "gradient" : e && e.radialGradient && (a = "pattern"); if (a) { var l, c, h = e.linearGradient || e.radialGradient, p, d, v, g, y, b = "", e = e.stops, w, E = [], S = function () { u = ['<fill colors="' + E.join(",") + '" opacity="', v, '" o:opacity2="', d, '" type="', a, '" ', b, 'focus="100%" method="any" />']; m(i.prepVML(u), null, null, t) }; p = e[0]; w = e[e.length - 1]; p[0] > 0 && e.unshift([0, p[1]]); w[0] < 1 && e.push([1, w[1]]); Kt(e, function (e, t) { o.test(e[1]) ? (s = ln(e[1]), l = s.get("rgb"), c = s.get("a")) : (l = e[1], c = 1); E.push(e[0] * 100 + "% " + l); t ? (v = c, g = l) : (d = c, y = l) }); if (n === "fill") if (a === "gradient") n = h.x1 || h[0] || 0, e = h.y1 || h[1] || 0, p = h.x2 || h[2] || 0, h = h.y2 || h[3] || 0, b = 'angle="' + (90 - X.atan((h - e) / (p - n)) * 180 / et) + '"', S(); else { var f = h.r, x = f * 2, T = f * 2, N = h.cx, C = h.cy, k = t.radialReference, L, f = function () { k && (L = r.getBBox(), N += (k[0] - L.x) / L.width - .5, C += (k[1] - L.y) / L.height - .5, x *= k[2] / L.width, T *= k[2] / L.height); b = 'src="' + yt.global.VMLRadialGradientURL + '" size="' + x + "," + T + '" origin="0.5,0.5" position="' + N + "," + C + '" color2="' + y + '" '; S() }; r.added ? f() : Zt(r, "add", f); f = g } else f = l } else if (o.test(e) && t.tagName !== "IMG") s = ln(e), u = ["<", n, ' opacity="', s.get("a"), '"/>'], m(this.prepVML(u), null, null, t), f = s.get("rgb"); else { f = t.getElementsByTagName(n); if (f.length) f[0].opacity = 1, f[0].type = "solid"; f = e } return f }, prepVML: function (e) { var t = this.isIE8, e = e.join(""); t ? (e = e.replace("/>", ' xmlns="urn:schemas-microsoft-com:vml" />'), e = e.indexOf('style="') === -1 ? e.replace("/>", ' style="display:inline-block;behavior:url(#default#VML);" />') : e.replace('style="', 'style="display:inline-block;behavior:url(#default#VML);')) : e = e.replace("<", "<hcv:"); return e }, text: cn.prototype.html, path: function (t) { var n = { coordsize: "10 10" }; o(t) ? n.d = t : s(t) && e(n, t); return this.createElement("shape").attr(n) }, circle: function (e, t, n) { var r = this.symbol("circle"); if (s(e)) n = e.r, t = e.y, e = e.x; r.isCircle = !0; r.r = n; return r.attr({ x: e, y: t }) }, g: function (e) { var t; e && (t = { className: "highcharts-" + e, "class": "highcharts-" + e }); return this.createElement(Nt).attr(t) }, image: function (e, t, n, r, i) { var s = this.createElement("img").attr({ src: e }); arguments.length > 1 && s.attr({ x: t, y: n, width: r, height: i }); return s }, rect: function (e, t, n, r, i, o) { var u = this.symbol("rect"); u.r = s(e) ? e.r : i; return u.attr(s(e) ? e : u.crisp(o, e, t, K(n, 0), K(r, 0))) }, invertChild: function (e, t) { var n = t.style; v(e, { flip: "x", left: r(n.width) - 1, top: r(n.height) - 1, rotation: -90 }) }, symbols: { arc: function (e, t, n, r, i) { var s = i.start, o = i.end, u = i.r || n || r, n = i.innerR, r = Y(s), a = Z(s), f = Y(o), l = Z(o); if (o - s === 0) return ["x"]; s = ["wa", e - u, t - u, e + u, t + u, e + u * r, t + u * a, e + u * f, t + u * l]; i.open && !n && s.push("e", "M", e, t); s.push("at", e - n, t - n, e + n, t + n, e + n * f, t + n * l, e + n * r, t + n * a, "x", "e"); s.isArc = !0; return s }, circle: function (e, t, n, r, i) { i && (n = r = 2 * i.r); i && i.isCircle && (e -= n / 2, t -= r / 2); return ["wa", e, t, e + n, t + r, e + n, t + r / 2, e + n, t + r / 2, "e"] }, rect: function (e, t, n, r, i) { var s = e + n, o = t + r, u; !c(i) || !i.r ? s = cn.prototype.symbols.square.apply(0, arguments) : (u = Q(i.r, n, r), s = ["M", e + u, t, "L", s - u, t, "wa", s - 2 * u, t, s, t + 2 * u, s - u, t, s, t + u, "L", s, o - u, "wa", s - 2 * u, o - 2 * u, s, o, s, o - u, s - u, o, "L", e + u, o, "wa", e, o - 2 * u, e + 2 * u, o, e + u, o, e, o - u, "L", e, t + u, "wa", e, t, e + 2 * u, t + 2 * u, e, t + u, e + u, t, "x", "e"]); return s } } }, Highcharts.VMLRenderer = hn = function () { this.init.apply(this, arguments) }, hn.prototype = t(cn.prototype, pn), pt = hn; cn.prototype.measureSpanWidth = function (e, t) { var n = z.createElement("span"), r; r = z.createTextNode(e); n.appendChild(r); v(n, t); this.box.appendChild(n); r = n.offsetWidth; A(n); return r }; var dn; if (ht) Highcharts.CanVGRenderer = pn = function () { ft = "http://www.w3.org/1999/xhtml" }, pn.prototype.symbols = {}, dn = function () { function e() { var e = t.length, n; for (n = 0; n < e; n++) t[n](); t = [] } var t = []; return { push: function (n, r) { t.length === 0 && $t(r, e); t.push(n) } } } (), pt = pn; H.prototype = { addLabel: function () { var t = this.axis, n = t.options, r = t.chart, i = t.horiz, s = t.categories, o = t.names, a = this.pos, l = n.labels, h = t.tickPositions, i = i && s && !l.step && !l.staggerLines && !l.rotation && r.plotWidth / h.length || !i && (r.margin[3] || r.chartWidth * .33), p = a === h[0], v = a === h[h.length - 1], m, o = s ? d(s[a], o[a], a) : a, s = this.label, g = h.info; t.isDatetimeAxis && g && (m = n.dateTimeLabelFormats[g.higherRanks[a] || g.unitName]); this.isFirst = p; this.isLast = v; n = t.labelFormatter.call({ axis: t, chart: r, isFirst: p, isLast: v, dateTimeLabelFormat: m, value: t.isLog ? M(f(o)) : o }); a = i && { width: K(1, V(i - 2 * (l.padding || 10))) + "px" }; a = e(a, l.style); if (c(s)) s && s.attr({ text: n }).css(a); else { m = { align: t.labelAlign }; if (u(l.rotation)) m.rotation = l.rotation; if (i && l.ellipsis) m._clipHeight = t.len / h.length; this.label = c(n) && l.enabled ? r.renderer.text(n, 0, 0, l.useHTML).attr(m).css(a).add(t.labelGroup) : null } }, getLabelSize: function () { var e = this.label, t = this.axis; return e ? e.getBBox()[t.horiz ? "height" : "width"] : 0 }, getLabelSides: function () { var e = this.label.getBBox(), t = this.axis, n = t.horiz, r = t.options.labels, e = n ? e.width : e.height, t = n ? e * { left: 0, center: .5, right: 1}[t.labelAlign] - r.x : e; return [-t, e - t] }, handleOverflow: function (e, t) { var n; var r = !0, i = this.axis, s = this.isFirst, o = this.isLast, u = i.horiz ? t.x : t.y, a = i.reversed, f = i.tickPositions, l = this.getLabelSides(), c = l[0], l = l[1], h = i.pos, p = h + i.len, d = this.label.line || 0, v = i.labelEdge, m = i.justifyLabels && (s || o); v[d] === U || u + c > v[d] ? v[d] = u + l : m || (r = !1); if (m) n = (i = i.ticks[f[e + (s ? 1 : -1)]]) && i.label.xy && i.label.xy.x + i.getLabelSides()[s ? 0 : 1], f = n, s && !a || o && a ? u + c < h && (u = h - c, i && u + l > f && (r = !1)) : u + l > p && (u = p - l, i && u + c < f && (r = !1)), t.x = u; return r }, getPosition: function (e, t, n, r) { var i = this.axis, s = i.chart, o = r && s.oldChartHeight || s.chartHeight; return { x: e ? i.translate(t + n, null, null, r) + i.transB : i.left + i.offset + (i.opposite ? (r && s.oldChartWidth || s.chartWidth) - i.right - i.left : 0), y: e ? o - i.bottom + i.offset - (i.opposite ? i.height : 0) : o - i.translate(t + n, null, null, r) - i.transB} }, getLabelPosition: function (e, t, n, r, i, s, o, u) { var a = this.axis, f = a.transA, l = a.reversed, h = a.staggerLines, p = a.chart.renderer.fontMetrics(i.style.fontSize).b, d = i.rotation, e = e + i.x - (s && r ? s * f * (l ? -1 : 1) : 0), t = t + i.y - (s && !r ? s * f * (l ? 1 : -1) : 0); d && a.side === 2 && (t -= p - p * Y(d * tt)); !c(i.y) && !d && (t += p - n.getBBox().height / 2); if (h) n.line = o / (u || 1) % h, t += n.line * (a.labelOffset / h); return { x: e, y: t} }, getMarkPath: function (e, t, n, r, i, s) { return s.crispLine(["M", e, t, "L", e + (i ? 0 : -n), t + (i ? n : 0)], r) }, render: function (e, t, n) { var r = this.axis, i = r.options, s = r.chart.renderer, o = r.horiz, u = this.type, a = this.label, f = this.pos, l = i.labels, c = this.gridLine, h = u ? u + "Grid" : "grid", p = u ? u + "Tick" : "tick", v = i[h + "LineWidth"], m = i[h + "LineColor"], g = i[h + "LineDashStyle"], y = i[p + "Length"], h = i[p + "Width"] || 0, b = i[p + "Color"], w = i[p + "Position"], p = this.mark, E = l.step, S = !0, x = r.tickmarkOffset, T = this.getPosition(o, f, x, t), N = T.x, T = T.y, C = o && N === r.pos + r.len || !o && T === r.pos ? -1 : 1; this.isActive = !0; if (v) { f = r.getPlotLinePath(f + x, v * C, t, !0); if (c === U) { c = { stroke: m, "stroke-width": v }; if (g) c.dashstyle = g; if (!u) c.zIndex = 1; if (t) c.opacity = 0; this.gridLine = c = v ? s.path(f).attr(c).add(r.gridGroup) : null } if (!t && c && f) c[this.isNew ? "attr" : "animate"]({ d: f, opacity: n }) } if (h && y) w === "inside" && (y = -y), r.opposite && (y = -y), u = this.getMarkPath(N, T, y, h * C, o, s), p ? p.animate({ d: u, opacity: n }) : this.mark = s.path(u).attr({ stroke: b, "stroke-width": h, opacity: n }).add(r.axisGroup); if (a && !isNaN(N)) a.xy = T = this.getLabelPosition(N, T, a, o, l, x, e, E), this.isFirst && !this.isLast && !d(i.showFirstLabel, 1) || this.isLast && !this.isFirst && !d(i.showLastLabel, 1) ? S = !1 : !r.isRadial && !l.step && !l.rotation && !t && n !== 0 && (S = this.handleOverflow(e, T)), E && e % E && (S = !1), S && !isNaN(T.y) ? (T.opacity = n, a[this.isNew ? "attr" : "animate"](T), this.isNew = !1) : a.attr("y", -9999) }, destroy: function () { L(this, this.axis) } }; B.prototype = { destroy: function () { L(this, this.axis) }, render: function (e) { var t = this.options, n = t.format, n = n ? E(n, this) : t.formatter.call(this); this.label ? this.label.attr({ text: n, visibility: "hidden" }) : this.label = this.axis.chart.renderer.text(n, 0, 0, t.useHTML).css(t.style).attr({ align: this.textAlign, rotation: t.rotation, visibility: "hidden" }).add(e) }, setOffset: function (e, t) { var n = this.axis, r = n.chart, i = r.inverted, s = this.isNegative, o = n.translate(this.percent ? 100 : this.total, 0, 0, 0, 1), n = n.translate(0), n = G(o - n), u = r.xAxis[0].translate(this.x) + e, a = r.plotHeight, s = { x: i ? s ? o : o - n : u, y: i ? a - u - t : s ? a - o - n : a - o, width: i ? n : t, height: i ? t : n }; if (i = this.label) i.align(this.alignOptions, null, s), s = i.alignAttr, i.attr({ visibility: this.options.crop === !1 || r.isInsidePlot(s.x, s.y) ? lt ? "inherit" : "visible" : "hidden" }) } }; var vn = function (e, t) { this.axis = e; if (t) this.options = t, this.id = t.id }; vn.prototype = { render: function () { var e = this, n = e.axis, r = n.horiz, i = (n.pointRange || 0) / 2, s = e.options, o = s.label, u = e.label, f = s.width, l = s.to, h = s.from, p = c(h) && c(l), v = s.value, m = s.dashStyle, g = e.svgElem, y = [], b, w = s.color, E = s.zIndex, S = s.events, x = n.chart.renderer; n.isLog && (h = a(h), l = a(l), v = a(v)); if (f) { if (y = n.getPlotLinePath(v, f), i = { stroke: w, "stroke-width": f }, m) i.dashstyle = m } else if (p) { if (h = K(h, n.min - i), l = Q(l, n.max + i), y = n.getPlotBandPath(h, l, s), i = { fill: w }, s.borderWidth) i.stroke = s.borderColor, i["stroke-width"] = s.borderWidth } else return; if (c(E)) i.zIndex = E; if (g) if (y) g.animate({ d: y }, null, g.onGetPath); else { if (g.hide(), g.onGetPath = function () { g.show() }, u) e.label = u = u.destroy() } else if (y && y.length && (e.svgElem = g = x.path(y).attr(i).add(), S)) for (b in s = function (t) { g.on(t, function (n) { S[t].apply(e, [n]) }) }, S) s(b); if (o && c(o.text) && y && y.length && n.width > 0 && n.height > 0) { o = t({ align: r && p && "center", x: r ? !p && 4 : 10, verticalAlign: !r && p && "middle", y: r ? p ? 16 : 10 : p ? 6 : -4, rotation: r && !p && 90 }, o); if (!u) e.label = u = x.text(o.text, 0, 0, o.useHTML).attr({ align: o.textAlign || o.align, rotation: o.rotation, zIndex: E }).css(o.style).add(); n = [y[1], y[4], d(y[6], y[1])]; y = [y[2], y[5], d(y[7], y[2])]; r = C(n); p = C(y); u.align(o, !1, { x: r, y: p, width: k(n) - r, height: k(y) - p }); u.show() } else u && u.hide(); return e }, destroy: function () { l(this.axis.plotLinesAndBands, this); delete this.axis; L(this) } }; j.prototype = { defaultOptions: { dateTimeLabelFormats: { millisecond: "%H:%M:%S.%L", second: "%H:%M:%S", minute: "%H:%M", hour: "%H:%M", day: "%e. %b", week: "%e. %b", month: "%b '%y", year: "%Y" }, endOnTick: !1, gridLineColor: "#C0C0C0", labels: Xt, lineColor: "#C0D0E0", lineWidth: 1, minPadding: .01, maxPadding: .01, minorGridLineColor: "#E0E0E0", minorGridLineWidth: 1, minorTickColor: "#A0A0A0", minorTickLength: 2, minorTickPosition: "outside", startOfWeek: 1, startOnTick: !1, tickColor: "#C0D0E0", tickLength: 5, tickmarkPlacement: "between", tickPixelInterval: 100, tickPosition: "outside", tickWidth: 1, title: { align: "middle", style: { color: "#4d759e", fontWeight: "bold"} }, type: "linear" }, defaultYAxisOptions: { endOnTick: !0, gridLineWidth: 1, tickPixelInterval: 72, showLastLabel: !0, labels: { x: -8, y: 3 }, lineWidth: 0, maxPadding: .05, minPadding: .05, startOnTick: !0, tickWidth: 0, title: { rotation: 270, text: "Values" }, stackLabels: { enabled: !1, formatter: function () { return y(this.total, -1) }, style: Xt.style} }, defaultLeftAxisOptions: { labels: { x: -8, y: null }, title: { rotation: 270} }, defaultRightAxisOptions: { labels: { x: 8, y: null }, title: { rotation: 90} }, defaultBottomAxisOptions: { labels: { x: 0, y: 14 }, title: { rotation: 0} }, defaultTopAxisOptions: { labels: { x: 0, y: -5 }, title: { rotation: 0} }, init: function (e, t) { var n = t.isX; this.horiz = e.inverted ? !n : n; this.coll = (this.isXAxis = n) ? "xAxis" : "yAxis"; this.opposite = t.opposite; this.side = t.side || (this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3); this.setOptions(t); var r = this.options, i = r.type; this.labelFormatter = r.labels.formatter || this.defaultLabelFormatter; this.userOptions = t; this.minPixelPadding = 0; this.chart = e; this.reversed = r.reversed; this.zoomEnabled = r.zoomEnabled !== !1; this.categories = r.categories || i === "category"; this.names = []; this.isLog = i === "logarithmic"; this.isDatetimeAxis = i === "datetime"; this.isLinked = c(r.linkedTo); this.tickmarkOffset = this.categories && r.tickmarkPlacement === "between" ? .5 : 0; this.ticks = {}; this.labelEdge = []; this.minorTicks = {}; this.plotLinesAndBands = []; this.alternateBands = {}; this.len = 0; this.minRange = this.userMinRange = r.minRange || r.maxZoom; this.range = r.range; this.offset = r.offset || 0; this.stacks = {}; this.oldStacks = {}; this.stackExtremes = {}; this.min = this.max = null; this.crosshair = d(r.crosshair, p(e.options.tooltip.crosshairs)[n ? 0 : 1], !1); var s, r = this.options.events; Jt(this, e.axes) === -1 && (e.axes.push(this), e[this.coll].push(this)); this.series = this.series || []; if (e.inverted && n && this.reversed === U) this.reversed = !0; this.removePlotLine = this.removePlotBand = this.removePlotBandOrLine; for (s in r) Zt(this, s, r[s]); if (this.isLog) this.val2lin = a, this.lin2val = f }, setOptions: function (e) { this.options = t(this.defaultOptions, this.isXAxis ? {} : this.defaultYAxisOptions, [this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions][this.side], t(yt[this.coll], e)) }, defaultLabelFormatter: function () { var e = this.axis, t = this.value, n = e.categories, r = this.dateTimeLabelFormat, i = yt.lang.numericSymbols, s = i && i.length, o, u = e.options.labels.format, e = e.isLog ? t : e.tickInterval; if (u) o = E(u, this); else if (n) o = t; else if (r) o = bt(r, t); else if (s && e >= 1e3) for (; s-- && o === U; ) n = Math.pow(1e3, s + 1), e >= n && i[s] !== null && (o = y(t / n, -1) + i[s]); o === U && (o = t >= 1e4 ? y(t, 0) : y(t, -1, U, "")); return o }, getSeriesExtremes: function () { var e = this, t = e.chart; e.hasVisibleSeries = !1; e.dataMin = e.dataMax = null; e.stackExtremes = {}; e.buildStacks(); Kt(e.series, function (n) { if (n.visible || !t.options.chart.ignoreHiddenSeries) { var r; r = n.options.threshold; var i; e.hasVisibleSeries = !0; e.isLog && r <= 0 && (r = null); if (e.isXAxis) { if (r = n.xData, r.length) e.dataMin = Q(d(e.dataMin, r[0]), C(r)), e.dataMax = K(d(e.dataMax, r[0]), k(r)) } else { n.getExtremes(); i = n.dataMax; n = n.dataMin; if (c(n) && c(i)) e.dataMin = Q(d(e.dataMin, n), n), e.dataMax = K(d(e.dataMax, i), i); if (c(r)) if (e.dataMin >= r) e.dataMin = r, e.ignoreMinPadding = !0; else if (e.dataMax < r) e.dataMax = r, e.ignoreMaxPadding = !0 } } }) }, translate: function (e, t, n, r, i, s) { var o = this.len, a = 1, f = 0, l = r ? this.oldTransA : this.transA, r = r ? this.oldMin : this.min, c = this.minPixelPadding, i = (this.options.ordinal || this.isLog && i) && this.lin2val; if (!l) l = this.transA; n && (a *= -1, f = o); this.reversed && (a *= -1, f -= a * o); t ? (e = e * a + f, e -= c, e = e / l + r, i && (e = this.lin2val(e))) : (i && (e = this.val2lin(e)), s === "between" && (s = .5), e = a * (e - r) * l + f + a * c + (u(s) ? l * s * this.pointRange : 0)); return e }, toPixels: function (e, t) { return this.translate(e, !1, !this.horiz, null, !0) + (t ? 0 : this.pos) }, toValue: function (e, t) { return this.translate(e - (t ? 0 : this.pos), !0, !this.horiz, null, !0) }, getPlotLinePath: function (e, t, n, r, i) { var s = this.chart, o = this.left, u = this.top, a, f, l = n && s.oldChartHeight || s.chartHeight, c = n && s.oldChartWidth || s.chartWidth, h; a = this.transB; i = d(i, this.translate(e, null, null, n)); e = n = V(i + a); a = f = V(l - i - a); if (isNaN(i)) h = !0; else if (this.horiz) { if (a = u, f = l - this.bottom, e < o || e > o + this.width) h = !0 } else if (e = o, n = c - this.right, a < u || a > u + this.height) h = !0; return h && !r ? null : s.renderer.crispLine(["M", e, a, "L", n, f], t || 1) }, getLinearTickPositions: function (e, t, n) { for (var r, t = M($(t / e) * e), n = M(J(n / e) * e), i = []; t <= n; ) { i.push(t); t = M(t + e); if (t === r) break; r = t } return i }, getMinorTickPositions: function () { var e = this.options, t = this.tickPositions, n = this.minorTickInterval, r = [], i; if (this.isLog) { i = t.length; for (e = 1; e < i; e++) r = r.concat(this.getLogTickPositions(n, t[e - 1], t[e], !0)) } else if (this.isDatetimeAxis && e.minorTickInterval === "auto") r = r.concat(this.getTimeTicks(this.normalizeTimeTickInterval(n), this.min, this.max, e.startOfWeek)), r[0] < this.min && r.shift(); else for (t = this.min + (t[0] - this.min) % n; t <= this.max; t += n) r.push(t); return r }, adjustForMinRange: function () { var e = this.options, t = this.min, n = this.max, r, i = this.dataMax - this.dataMin >= this.minRange, s, o, u, a, f; if (this.isXAxis && this.minRange === U && !this.isLog) c(e.min) || c(e.max) ? this.minRange = null : (Kt(this.series, function (e) { a = e.xData; for (o = f = e.xIncrement ? 1 : a.length - 1; o > 0; o--) if (u = a[o] - a[o - 1], s === U || u < s) s = u }), this.minRange = Q(s * 5, this.dataMax - this.dataMin)); if (n - t < this.minRange) { var l = this.minRange; r = (l - n + t) / 2; r = [t - r, d(e.min, t - r)]; if (i) r[2] = this.dataMin; t = k(r); n = [t + l, d(e.max, t + l)]; if (i) n[2] = this.dataMax; n = C(n); n - t < l && (r[0] = n - l, r[1] = d(e.min, n - l), t = k(r)) } this.min = t; this.max = n }, setAxisTranslation: function (e) { var t = this.max - this.min, n = 0, r, s = 0, o = 0, u = this.linkedParent, a = !!this.categories, f = this.transA; if (this.isXAxis || a) u ? (s = u.minPointOffset, o = u.pointRangePadding) : Kt(this.series, function (e) { var u = K(e.pointRange, +a), f = e.options.pointPlacement, l = e.closestPointRange; u > t && (u = 0); n = K(n, u); s = K(s, i(f) ? 0 : u / 2); o = K(o, f === "on" ? 0 : u); !e.noSharedTooltip && c(l) && (r = c(r) ? Q(r, l) : l) }), u = this.ordinalSlope && r ? this.ordinalSlope / r : 1, this.minPointOffset = s *= u, this.pointRangePadding = o *= u, this.pointRange = Q(n, t), this.closestPointRange = r; if (e) this.oldTransA = f; this.translationSlope = this.transA = f = this.len / (t + o || 1); this.transB = this.horiz ? this.left : this.bottom; this.minPixelPadding = f * s }, setTickPositions: function (e) { var t = this, n = t.chart, r = t.options, i = t.isLog, s = t.isDatetimeAxis, o = t.isXAxis, u = t.isLinked, f = t.options.tickPositioner, l = r.maxPadding, h = r.minPadding, p = r.tickInterval, v = r.minTickInterval, m = r.tickPixelInterval, g, y = t.categories; u ? (t.linkedParent = n[t.coll][r.linkedTo], n = t.linkedParent.getExtremes(), t.min = d(n.min, n.dataMin), t.max = d(n.max, n.dataMax), r.type !== t.linkedParent.options.type && O(11, 1)) : (t.min = d(t.userMin, r.min, t.dataMin), t.max = d(t.userMax, r.max, t.dataMax)); if (i) !e && Q(t.min, d(t.dataMin, t.min)) <= 0 && O(10, 1), t.min = M(a(t.min)), t.max = M(a(t.max)); if (t.range && c(t.max)) t.userMin = t.min = K(t.min, t.max - t.range), t.userMax = t.max, t.range = null; t.beforePadding && t.beforePadding(); t.adjustForMinRange(); if (!y && !t.usePercentage && !u && c(t.min) && c(t.max) && (n = t.max - t.min)) { if (!c(r.min) && !c(t.userMin) && h && (t.dataMin < 0 || !t.ignoreMinPadding)) t.min -= n * h; if (!c(r.max) && !c(t.userMax) && l && (t.dataMax > 0 || !t.ignoreMaxPadding)) t.max += n * l } t.min === t.max || t.min === void 0 || t.max === void 0 ? t.tickInterval = 1 : u && !p && m === t.linkedParent.options.tickPixelInterval ? t.tickInterval = t.linkedParent.tickInterval : (t.tickInterval = d(p, y ? 1 : (t.max - t.min) * m / K(t.len, m)), !c(p) && t.len < m && !this.isRadial && !y && r.startOnTick && r.endOnTick && (g = !0, t.tickInterval /= 4)); o && !e && Kt(t.series, function (e) { e.processData(t.min !== t.oldMin || t.max !== t.oldMax) }); t.setAxisTranslation(!0); t.beforeSetTickPositions && t.beforeSetTickPositions(); if (t.postProcessTickInterval) t.tickInterval = t.postProcessTickInterval(t.tickInterval); if (t.pointRange) t.tickInterval = K(t.pointRange, t.tickInterval); if (!p && t.tickInterval < v) t.tickInterval = v; if (!s && !i && !p) t.tickInterval = x(t.tickInterval, null, S(t.tickInterval), r); t.minorTickInterval = r.minorTickInterval === "auto" && t.tickInterval ? t.tickInterval / 5 : r.minorTickInterval; t.tickPositions = e = r.tickPositions ? [].concat(r.tickPositions) : f && f.apply(t, [t.min, t.max]); if (!e) !t.ordinalPositions && (t.max - t.min) / t.tickInterval > K(2 * t.len, 200) && O(19, !0), e = s ? t.getTimeTicks(t.normalizeTimeTickInterval(t.tickInterval, r.units), t.min, t.max, r.startOfWeek, t.ordinalPositions, t.closestPointRange, !0) : i ? t.getLogTickPositions(t.tickInterval, t.min, t.max) : t.getLinearTickPositions(t.tickInterval, t.min, t.max), g && e.splice(1, e.length - 2), t.tickPositions = e; if (!u) i = e[0], s = e[e.length - 1], u = t.minPointOffset || 0, r.startOnTick ? t.min = i : t.min - u > i && e.shift(), r.endOnTick ? t.max = s : t.max + u < s && e.pop(), e.length === 1 && (t.min -= .001, t.max += .001) }, setMaxTicks: function () { var e = this.chart, t = e.maxTicks || {}, n = this.tickPositions, r = this._maxTicksKey = [this.coll, this.pos, this.len].join("-"); if (!this.isLinked && !this.isDatetimeAxis && n && n.length > (t[r] || 0) && this.options.alignTicks !== !1) t[r] = n.length; e.maxTicks = t }, adjustTickAmount: function () { var e = this._maxTicksKey, t = this.tickPositions, n = this.chart.maxTicks; if (n && n[e] && !this.isDatetimeAxis && !this.categories && !this.isLinked && this.options.alignTicks !== !1 && this.min !== U) { var r = this.tickAmount, i = t.length; this.tickAmount = e = n[e]; if (i < e) { for (; t.length < e; ) t.push(M(t[t.length - 1] + this.tickInterval)); this.transA *= (i - 1) / (e - 1); this.max = t[t.length - 1] } if (c(r) && e !== r) this.isDirty = !0 } }, setScale: function () { var e = this.stacks, t, n, r, i; this.oldMin = this.min; this.oldMax = this.max; this.oldAxisLength = this.len; this.setAxisSize(); i = this.len !== this.oldAxisLength; Kt(this.series, function (e) { if (e.isDirtyData || e.isDirty || e.xAxis.isDirty) r = !0 }); if (i || r || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax) { if (!this.isXAxis) for (t in e) for (n in e[t]) e[t][n].total = null, e[t][n].cum = 0; this.forceRedraw = !1; this.getSeriesExtremes(); this.setTickPositions(); this.oldUserMin = this.userMin; this.oldUserMax = this.userMax; if (!this.isDirty) this.isDirty = i || this.min !== this.oldMin || this.max !== this.oldMax } else if (!this.isXAxis) { if (this.oldStacks) e = this.stacks = this.oldStacks; for (t in e) for (n in e[t]) e[t][n].cum = e[t][n].total } this.setMaxTicks() }, setExtremes: function (t, n, r, i, s) { var o = this, u = o.chart, r = d(r, !0), s = e(s, { min: t, max: n }); tn(o, "setExtremes", s, function () { o.userMin = t; o.userMax = n; o.eventArgs = s; o.isDirtyExtremes = !0; r && u.redraw(i) }) }, zoom: function (e, t) { this.allowZoomOutside || (c(this.dataMin) && e <= this.dataMin && (e = U), c(this.dataMax) && t >= this.dataMax && (t = U)); this.displayBtn = e !== U || t !== U; this.setExtremes(e, t, !1, U, { trigger: "zoom" }); return !0 }, setAxisSize: function () { var e = this.chart, t = this.options, n = t.offsetLeft || 0, r = t.offsetRight || 0, i = this.horiz, s, o; this.left = o = d(t.left, e.plotLeft + n); this.top = s = d(t.top, e.plotTop); this.width = n = d(t.width, e.plotWidth - n + r); this.height = t = d(t.height, e.plotHeight); this.bottom = e.chartHeight - t - s; this.right = e.chartWidth - n - o; this.len = K(i ? n : t, 0); this.pos = i ? o : s }, getExtremes: function () { var e = this.isLog; return { min: e ? M(f(this.min)) : this.min, max: e ? M(f(this.max)) : this.max, dataMin: this.dataMin, dataMax: this.dataMax, userMin: this.userMin, userMax: this.userMax} }, getThreshold: function (e) { var t = this.isLog, n = t ? f(this.min) : this.min, t = t ? f(this.max) : this.max; n > e || e === null ? e = n : t < e && (e = t); return this.translate(e, 0, 1, 0, 1) }, autoLabelAlign: function (e) { e = (d(e, 0) - this.side * 90 + 720) % 360; return e > 15 && e < 165 ? "right" : e > 195 && e < 345 ? "left" : "center" }, getOffset: function () { var e = this, t = e.chart, n = t.renderer, r = e.options, i = e.tickPositions, s = e.ticks, o = e.horiz, u = e.side, a = t.inverted ? [1, 0, 3, 2][u] : u, f, l = 0, h, p = 0, v = r.title, m = r.labels, g = 0, y = t.axisOffset, b = t.clipOffset, w = [-1, 1, 1, -1][u], E, S = 1, x = d(m.maxStaggerLines, 5), T, N, C, k; e.hasData = f = e.hasVisibleSeries || c(e.min) && c(e.max) && !!i; e.showAxis = t = f || d(r.showEmpty, !0); e.staggerLines = e.horiz && m.staggerLines; if (!e.axisGroup) e.gridGroup = n.g("grid").attr({ zIndex: r.gridZIndex || 1 }).add(), e.axisGroup = n.g("axis").attr({ zIndex: r.zIndex || 2 }).add(), e.labelGroup = n.g("axis-labels").attr({ zIndex: m.zIndex || 7 }).add(); if (f || e.isLinked) { e.labelAlign = d(m.align || e.autoLabelAlign(m.rotation)); Kt(i, function (t) { s[t] ? s[t].addLabel() : s[t] = new H(e, t) }); if (e.horiz && !e.staggerLines && x && !m.rotation) { for (E = e.reversed ? [].concat(i).reverse() : i; S < x; ) { f = []; T = !1; for (m = 0; m < E.length; m++) N = E[m], C = (C = s[N].label && s[N].label.getBBox()) ? C.width : 0, k = m % S, C && (N = e.translate(N), f[k] !== U && N < f[k] && (T = !0), f[k] = N + C); if (T) S++; else break } if (S > 1) e.staggerLines = S } Kt(i, function (t) { if (u === 0 || u === 2 || { 1: "left", 3: "right"}[u] === e.labelAlign) g = K(s[t].getLabelSize(), g) }); if (e.staggerLines) g *= e.staggerLines, e.labelOffset = g } else for (E in s) s[E].destroy(), delete s[E]; if (v && v.text && v.enabled !== !1) { if (!e.axisTitle) e.axisTitle = n.text(v.text, 0, 0, v.useHTML).attr({ zIndex: 7, rotation: v.rotation || 0, align: v.textAlign || { low: "left", middle: "center", high: "right"}[v.align] }).css(v.style).add(e.axisGroup), e.axisTitle.isNew = !0; if (t) l = e.axisTitle.getBBox()[o ? "height" : "width"], p = d(v.margin, o ? 5 : 10), h = v.offset; e.axisTitle[t ? "show" : "hide"]() } e.offset = w * d(r.offset, y[u]); e.axisTitleMargin = d(h, g + p + (u !== 2 && g && w * r.labels[o ? "y" : "x"])); y[u] = K(y[u], e.axisTitleMargin + l + w * e.offset); b[a] = K(b[a], $(r.lineWidth / 2) * 2) }, getLinePath: function (e) { var t = this.chart, n = this.opposite, r = this.offset, i = this.horiz, s = this.left + (n ? this.width : 0) + r, r = t.chartHeight - this.bottom - (n ? this.height : 0) + r; n && (e *= -1); return t.renderer.crispLine(["M", i ? this.left : s, i ? r : this.top, "L", i ? t.chartWidth - this.right : s, i ? r : t.chartHeight - this.bottom], e) }, getTitlePosition: function () { var e = this.horiz, t = this.left, n = this.top, i = this.len, s = this.options.title, o = e ? t : n, u = this.opposite, a = this.offset, f = r(s.style.fontSize || 12), i = { low: o + (e ? 0 : i), middle: o + i / 2, high: o + (e ? i : 0)}[s.align], t = (e ? n + this.height : t) + (e ? 1 : -1) * (u ? -1 : 1) * this.axisTitleMargin + (this.side === 2 ? f : 0); return { x: e ? i : t + (u ? this.width : 0) + a + (s.x || 0), y: e ? t - (u ? this.height : 0) + a : i + (s.y || 0)} }, render: function () { var e = this, t = e.horiz, n = e.reversed, r = e.chart, i = r.renderer, s = e.options, o = e.isLog, u = e.isLinked, a = e.tickPositions, l, h = e.axisTitle, p = e.stacks, d = e.ticks, v = e.minorTicks, m = e.alternateBands, g = s.stackLabels, y = s.alternateGridColor, b = e.tickmarkOffset, w = s.lineWidth, E = r.hasRendered && c(e.oldMin) && !isNaN(e.oldMin), S = e.hasData, x = e.showAxis, T, N = e.justifyLabels = !e.staggerLines && t && s.labels.overflow === "justify", C; e.labelEdge.length = 0; Kt([d, v, m], function (e) { for (var t in e) e[t].isActive = !1 }); if (S || u) if (e.minorTickInterval && !e.categories && Kt(e.getMinorTickPositions(), function (t) { v[t] || (v[t] = new H(e, t, "minor")); E && v[t].isNew && v[t].render(null, !0); v[t].render(null, !1, 1) }), a.length && (l = a.slice(), (t && n || !t && !n) && l.reverse(), N && (l = l.slice(1).concat([l[0]])), Kt(l, function (t, n) { N && (n = n === l.length - 1 ? 0 : n + 1); if (!u || t >= e.min && t <= e.max) d[t] || (d[t] = new H(e, t)), E && d[t].isNew && d[t].render(n, !0, .1), d[t].render(n, !1, 1) }), b && e.min === 0 && (d[-1] || (d[-1] = new H(e, -1, null, !0)), d[-1].render(-1))), y && Kt(a, function (t, n) { if (n % 2 === 0 && t < e.max) m[t] || (m[t] = new vn(e)), T = t + b, C = a[n + 1] !== U ? a[n + 1] + b : e.max, m[t].options = { from: o ? f(T) : T, to: o ? f(C) : C, color: y }, m[t].render(), m[t].isActive = !0 }), !e._addedPlotLB) Kt((s.plotLines || []).concat(s.plotBands || []), function (t) { e.addPlotBandOrLine(t) }), e._addedPlotLB = !0; Kt([d, v, m], function (e) { var t, n, i = [], s = wt ? wt.duration || 500 : 0, o = function () { for (n = i.length; n--; ) e[i[n]] && !e[i[n]].isActive && (e[i[n]].destroy(), delete e[i[n]]) }; for (t in e) if (!e[t].isActive) e[t].render(t, !1, 0), e[t].isActive = !1, i.push(t); e === m || !r.hasRendered || !s ? o() : s && setTimeout(o, s) }); if (w) t = e.getLinePath(w), e.axisLine ? e.axisLine.animate({ d: t }) : e.axisLine = i.path(t).attr({ stroke: s.lineColor, "stroke-width": w, zIndex: 7 }).add(e.axisGroup), e.axisLine[x ? "show" : "hide"](); if (h && x) h[h.isNew ? "attr" : "animate"](e.getTitlePosition()), h.isNew = !1; if (g && g.enabled) { var k, L, s = e.stackTotalGroup; if (!s) e.stackTotalGroup = s = i.g("stack-labels").attr({ visibility: "visible", zIndex: 6 }).add(); s.translate(r.plotLeft, r.plotTop); for (k in p) for (L in i = p[k], i) i[L].render(s) } e.isDirty = !1 }, redraw: function () { var e = this.chart.pointer; e.reset && e.reset(!0); this.render(); Kt(this.plotLinesAndBands, function (e) { e.render() }); Kt(this.series, function (e) { e.isDirty = !0 }) }, buildStacks: function () { var e = this.series, t = e.length; if (!this.isXAxis) { for (; t--; ) e[t].setStackedPoints(); if (this.usePercentage) for (t = 0; t < e.length; t++) e[t].setPercentStacks() } }, destroy: function (e) { var t = this, n = t.stacks, r, i = t.plotLinesAndBands; e || en(t); for (r in n) L(n[r]), n[r] = null; Kt([t.ticks, t.minorTicks, t.alternateBands], function (e) { L(e) }); for (e = i.length; e--; ) i[e].destroy(); Kt("stackTotalGroup,axisLine,axisTitle,axisGroup,cross,gridGroup,labelGroup".split(","), function (e) { t[e] && (t[e] = t[e].destroy()) }); this.cross && this.cross.destroy() }, drawCrosshair: function (e, t) { if (this.crosshair) if ((c(t) || !d(this.crosshair.snap, !0)) === !1) this.hideCrosshair(); else { var n, r = this.crosshair, i = r.animation; d(r.snap, !0) ? c(t) && (n = this.chart.inverted != this.horiz ? t.plotX : this.len - t.plotY) : n = this.horiz ? e.chartX - this.pos : this.len - e.chartY + this.pos; n = this.isRadial ? this.getPlotLinePath(this.isXAxis ? t.x : d(t.stackY, t.y)) : this.getPlotLinePath(null, null, null, null, n); if (n === null) this.hideCrosshair(); else if (this.cross) this.cross.attr({ visibility: "visible" })[i ? "animate" : "attr"]({ d: n }, i); else { i = { "stroke-width": r.width || 1, stroke: r.color || "#C0C0C0", zIndex: r.zIndex || 2 }; if (r.dashStyle) i.dashstyle = r.dashStyle; this.cross = this.chart.renderer.path(n).attr(i).add() } } }, hideCrosshair: function () { this.cross && this.cross.hide() } }; e(j.prototype, { getPlotBandPath: function (e, t) { var n = this.getPlotLinePath(t), r = this.getPlotLinePath(e); r && n ? r.push(n[4], n[5], n[1], n[2]) : r = null; return r }, addPlotBand: function (e) { this.addPlotBandOrLine(e, "plotBands") }, addPlotLine: function (e) { this.addPlotBandOrLine(e, "plotLines") }, addPlotBandOrLine: function (e, t) { var n = (new vn(this, e)).render(), r = this.userOptions; n && (t && (r[t] = r[t] || [], r[t].push(e)), this.plotLinesAndBands.push(n)); return n }, removePlotBandOrLine: function (e) { for (var t = this.plotLinesAndBands, n = this.options, r = this.userOptions, i = t.length; i--; ) t[i].id === e && t[i].destroy(); Kt([n.plotLines || [], r.plotLines || [], n.plotBands || [], r.plotBands || []], function (t) { for (i = t.length; i--; ) t[i].id === e && l(t, t[i]) }) } }); j.prototype.getTimeTicks = function (t, n, r, i) { var s = [], o = {}, u = yt.global.useUTC, a, f = new Date(n - Mt), l = t.unitRange, h = t.count; if (c(n)) { l >= St.second && (f.setMilliseconds(0), f.setSeconds(l >= St.minute ? 0 : h * $(f.getSeconds() / h))); if (l >= St.minute) f[Ft](l >= St.hour ? 0 : h * $(f[_t]() / h)); if (l >= St.hour) f[It](l >= St.day ? 0 : h * $(f[Dt]() / h)); if (l >= St.day) f[qt](l >= St.month ? 1 : h * $(f[Ht]() / h)); l >= St.month && (f[Rt](l >= St.year ? 0 : h * $(f[Bt]() / h)), a = f[jt]()); l >= St.year && (a -= a % h, f[Ut](a)); if (l === St.week) f[qt](f[Ht]() - f[Pt]() + d(i, 1)); n = 1; Mt && (f = new Date(f.getTime() + Mt)); a = f[jt](); for (var i = f.getTime(), p = f[Bt](), v = f[Ht](), m = u ? Mt : (864e5 + f.getTimezoneOffset() * 6e4) % 864e5; i < r; ) s.push(i), l === St.year ? i = Ot(a + n * h, 0) : l === St.month ? i = Ot(a, p + n * h) : !u && (l === St.day || l === St.week) ? i = Ot(a, p, v + n * h * (l === St.day ? 1 : 7)) : i += l * h, n++; s.push(i); Kt(Qt(s, function (e) { return l <= St.hour && e % St.day === m }), function (e) { o[e] = "day" }) } s.info = e(t, { higherRanks: o, totalRange: l * h }); return s }; j.prototype.normalizeTimeTickInterval = function (e, t) { var n = t || [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1, 2]], ["week", [1, 2]], ["month", [1, 2, 3, 4, 6]], ["year", null]], r = n[n.length - 1], i = St[r[0]], s = r[1], o; for (o = 0; o < n.length; o++) if (r = n[o], i = St[r[0]], s = r[1], n[o + 1] && e <= (i * s[s.length - 1] + St[n[o + 1][0]]) / 2) break; i === St.year && e < 5 * i && (s = [1, 2, 5]); n = x(e / i, s, r[0] === "year" ? K(S(e / i), 1) : 1); return { unitRange: i, count: n, unitName: r[0]} }; j.prototype.getLogTickPositions = function (e, t, n, r) { var i = this.options, s = this.len, o = []; if (!r) this._minorAutoInterval = null; if (e >= .5) e = V(e), o = this.getLinearTickPositions(e, t, n); else if (e >= .08) for (var s = $(t), u, l, c, h, p, i = e > .3 ? [1, 2, 4] : e > .15 ? [1, 2, 4, 6, 8] : [1, 2, 3, 4, 5, 6, 7, 8, 9]; s < n + 1 && !p; s++) { l = i.length; for (u = 0; u < l && !p; u++) c = a(f(s) * i[u]), c > t && (!r || h <= n) && o.push(h), h > n && (p = !0), h = c } else if (t = f(t), n = f(n), e = i[r ? "minorTickInterval" : "tickInterval"], e = d(e === "auto" ? null : e, this._minorAutoInterval, (n - t) * (i.tickPixelInterval / (r ? 5 : 1)) / ((r ? s / this.tickPositions.length : s) || 1)), e = x(e, null, S(e)), o = Yt(this.getLinearTickPositions(e, t, n), a), !r) this._minorAutoInterval = e / 5; if (!r) this.tickInterval = e; return o }; F.prototype = { init: function (e, t) { var n = t.borderWidth, i = t.style, s = r(i.padding); this.chart = e; this.options = t; this.crosshairs = []; this.now = { x: 0, y: 0 }; this.isHidden = !0; this.label = e.renderer.label("", 0, 0, t.shape, null, null, t.useHTML, null, "tooltip").attr({ padding: s, fill: t.backgroundColor, "stroke-width": n, r: t.borderRadius, zIndex: 8 }).css(i).css({ padding: 0 }).add().attr({ y: -999 }); ht || this.label.shadow(t.shadow); this.shared = t.shared }, destroy: function () { if (this.label) this.label = this.label.destroy(); clearTimeout(this.hideTimer); clearTimeout(this.tooltipTimeout) }, move: function (t, n, r, i) { var s = this, o = s.now, u = s.options.animation !== !1 && !s.isHidden; e(o, { x: u ? (2 * o.x + t) / 3 : t, y: u ? (o.y + n) / 2 : n, anchorX: u ? (2 * o.anchorX + r) / 3 : r, anchorY: u ? (o.anchorY + i) / 2 : i }); s.label.attr(o); if (u && (G(t - o.x) > 1 || G(n - o.y) > 1)) clearTimeout(this.tooltipTimeout), this.tooltipTimeout = setTimeout(function () { s && s.move(t, n, r, i) }, 32) }, hide: function () { var e = this, t; clearTimeout(this.hideTimer); if (!this.isHidden) t = this.chart.hoverPoints, this.hideTimer = setTimeout(function () { e.label.fadeOut(); e.isHidden = !0 }, d(this.options.hideDelay, 500)), t && Kt(t, function (e) { e.setState() }), this.chart.hoverPoints = null }, getAnchor: function (e, t) { var n, r = this.chart, i = r.inverted, s = r.plotTop, o = 0, u = 0, a, e = p(e); n = e[0].tooltipPos; this.followPointer && t && (t.chartX === U && (t = r.pointer.normalize(t)), n = [t.chartX - r.plotLeft, t.chartY - s]); n || (Kt(e, function (e) { a = e.series.yAxis; o += e.plotX; u += (e.plotLow ? (e.plotLow + e.plotHigh) / 2 : e.plotY) + (!i && a ? a.top - s : 0) }), o /= e.length, u /= e.length, n = [i ? r.plotWidth - u : o, this.shared && !i && e.length > 1 && t ? t.chartY - s : i ? r.plotHeight - o : u]); return Yt(n, V) }, getPosition: function (e, t, n) { var r = this.chart, i = r.plotLeft, s = r.plotTop, o = r.plotWidth, u = r.plotHeight, a = d(this.options.distance, 12), f = n.plotX, n = n.plotY, r = f + i + (r.inverted ? a : -e - a), l = n - t + s + 15, c; r < 7 && (r = i + K(f, 0) + a); r + e > i + o && (r -= r + e - (i + o), l = n - t + s - a, c = !0); l < s + 5 && (l = s + 5, c && n >= l && n <= l + t && (l = n + s + a)); l + t > s + u && (l = K(s, s + u - t - a)); return { x: r, y: l} }, defaultFormatter: function (e) { var t = this.points || p(this), n = t[0].series, r; r = [n.tooltipHeaderFormatter(t[0])]; Kt(t, function (e) { n = e.series; r.push(n.tooltipFormatter && n.tooltipFormatter(e) || e.point.tooltipFormatter(n.tooltipOptions.pointFormat)) }); r.push(e.options.footerFormat || ""); return r.join("") }, refresh: function (e, t) { var n = this.chart, r = this.label, i = this.options, s, o, u = {}, a, f = []; a = i.formatter || this.defaultFormatter; var u = n.hoverPoints, l, c = this.shared; clearTimeout(this.hideTimer); this.followPointer = p(e)[0].series.tooltipOptions.followPointer; o = this.getAnchor(e, t); s = o[0]; o = o[1]; c && (!e.series || !e.series.noSharedTooltip) ? (n.hoverPoints = e, u && Kt(u, function (e) { e.setState() }), Kt(e, function (e) { e.setState("hover"); f.push(e.getLabelConfig()) }), u = { x: e[0].category, y: e[0].y }, u.points = f, e = e[0]) : u = e.getLabelConfig(); a = a.call(u, this); u = e.series; a === !1 ? this.hide() : (this.isHidden && (sn(r), r.attr("opacity", 1).show()), r.attr({ text: a }), l = i.borderColor || e.color || u.color || "#606060", r.attr({ stroke: l }), this.updatePosition({ plotX: s, plotY: o }), this.isHidden = !1); tn(n, "tooltipRefresh", { text: a, x: s + n.plotLeft, y: o + n.plotTop, borderColor: l }) }, updatePosition: function (e) { var t = this.chart, n = this.label, n = (this.options.positioner || this.getPosition).call(this, n.width, n.height, e); this.move(V(n.x), V(n.y), e.plotX + t.plotLeft, e.plotY + t.plotTop) } }; var mn = Highcharts.Pointer = function (e, t) { this.init(e, t) }; mn.prototype = { init: function (e, t) { var n = t.chart, r = n.events, i = ht ? "" : n.zoomType, n = e.inverted, s; this.options = t; this.chart = e; this.zoomX = s = /x/.test(i); this.zoomY = i = /y/.test(i); this.zoomHor = s && !n || i && n; this.zoomVert = i && !n || s && n; this.runChartClick = r && !!r.click; this.pinchDown = []; this.lastValidTouch = {}; if (t.tooltip.enabled) e.tooltip = new F(e, t.tooltip); this.setDOMEvents() }, normalize: function (t, n) { var r, i, t = t || W.event; if (!t.target) t.target = t.srcElement; t = nn(t); i = t.touches ? t.touches.item(0) : t; if (!n) this.chartPosition = n = Gt(this.chart.container); i.pageX === U ? (r = K(t.x, t.clientX - n.left), i = t.y) : (r = i.pageX - n.left, i = i.pageY - n.top); return e(t, { chartX: V(r), chartY: V(i) }) }, getCoordinates: function (e) { var t = { xAxis: [], yAxis: [] }; Kt(this.chart.axes, function (n) { t[n.isXAxis ? "xAxis" : "yAxis"].push({ axis: n, value: n.toValue(e[n.horiz ? "chartX" : "chartY"]) }) }); return t }, getIndex: function (e) { var t = this.chart; return t.inverted ? t.plotHeight + t.plotTop - e.chartY : e.chartX - t.plotLeft }, runPointActions: function (e) { var t = this, n = t.chart, r = n.series, i = n.tooltip, s, o, u = n.hoverPoint, a = n.hoverSeries, f, l, c = n.chartWidth, h = t.getIndex(e); if (i && t.options.tooltip.shared && (!a || !a.noSharedTooltip)) { o = []; f = r.length; for (l = 0; l < f; l++) if (r[l].visible && r[l].options.enableMouseTracking !== !1 && !r[l].noSharedTooltip && r[l].tooltipPoints.length && (s = r[l].tooltipPoints[h]) && s.series) s._dist = G(h - s.clientX), c = Q(c, s._dist), o.push(s); for (f = o.length; f--; ) o[f]._dist > c && o.splice(f, 1); if (o.length && o[0].clientX !== t.hoverX) i.refresh(o, e), t.hoverX = o[0].clientX } if (a && a.tracker) { if ((s = a.tooltipPoints[h]) && s !== u) s.onMouseOver(e) } else i && i.followPointer && !i.isHidden && (r = i.getAnchor([{}], e), i.updatePosition({ plotX: r[0], plotY: r[1] })); if (i && !t._onDocumentMouseMove) t._onDocumentMouseMove = function (e) { t.onDocumentMouseMove(e) }, Zt(z, "mousemove", t._onDocumentMouseMove); Kt(n.axes, function (t) { t.drawCrosshair(e, d(u, s)) }) }, reset: function (e) { var t = this.chart, n = t.hoverSeries, r = t.hoverPoint, i = t.tooltip, s = i && i.shared ? t.hoverPoints : r; (e = e && i && s) && p(s)[0].plotX === U && (e = !1); if (e) i.refresh(s), r && r.setState(r.state, !0); else { if (r) r.onMouseOut(); if (n) n.onMouseOut(); i && i.hide(); if (this._onDocumentMouseMove) en(z, "mousemove", this._onDocumentMouseMove), this._onDocumentMouseMove = null; Kt(t.axes, function (e) { e.hideCrosshair() }); this.hoverX = null } }, scaleGroups: function (e, t) { var n = this.chart, r; Kt(n.series, function (i) { r = e || i.getPlotBox(); i.xAxis && i.xAxis.zoomEnabled && (i.group.attr(r), i.markerGroup && (i.markerGroup.attr(r), i.markerGroup.clip(t ? n.clipRect : null)), i.dataLabelsGroup && i.dataLabelsGroup.attr(r)) }); n.clipRect.attr(t || n.clipBox) }, pinchTranslate: function (e, t, n, r, i, s, o, u) { e && this.pinchTranslateDirection(!0, n, r, i, s, o, u); t && this.pinchTranslateDirection(!1, n, r, i, s, o, u) }, pinchTranslateDirection: function (e, t, n, r, i, s, o, u) { var a = this.chart, f = e ? "x" : "y", l = e ? "X" : "Y", c = "chart" + l, h = e ? "width" : "height", p = a["plot" + (e ? "Left" : "Top")], d, v, m = u || 1, g = a.inverted, y = a.bounds[e ? "h" : "v"], b = t.length === 1, w = t[0][c], E = n[0][c], S = !b && t[1][c], x = !b && n[1][c], T, n = function () { !b && G(w - S) > 20 && (m = u || G(E - x) / G(w - S)); v = (p - E) / m + w; d = a["plot" + (e ? "Width" : "Height")] / m }; n(); t = v; t < y.min ? (t = y.min, T = !0) : t + d > y.max && (t = y.max - d, T = !0); T ? (E -= .8 * (E - o[f][0]), b || (x -= .8 * (x - o[f][1])), n()) : o[f] = [E, x]; g || (s[f] = v - p, s[h] = d); s = g ? 1 / m : m; i[h] = d; i[f] = t; r[g ? e ? "scaleY" : "scaleX" : "scale" + l] = m; r["translate" + l] = s * p + (E - s * w) }, pinch: function (t) { var n = this, r = n.chart, i = n.pinchDown, s = r.tooltip && r.tooltip.options.followTouchMove, o = t.touches, u = o.length, a = n.lastValidTouch, f = n.zoomHor || n.pinchHor, l = n.zoomVert || n.pinchVert, c = f || l, h = n.selectionMarker, p = {}, d = u === 1 && (n.inClass(t.target, "highcharts-tracker") && r.runTrackerClick || r.runChartClick), v = {}; (c || s) && !d && t.preventDefault(); Yt(o, function (e) { return n.normalize(e) }); if (t.type === "touchstart") Kt(o, function (e, t) { i[t] = { chartX: e.chartX, chartY: e.chartY} }), a.x = [i[0].chartX, i[1] && i[1].chartX], a.y = [i[0].chartY, i[1] && i[1].chartY], Kt(r.axes, function (e) { if (e.zoomEnabled) { var t = r.bounds[e.horiz ? "h" : "v"], n = e.minPixelPadding, i = e.toPixels(e.dataMin), s = e.toPixels(e.dataMax), o = Q(i, s), i = K(i, s); t.min = Q(e.pos, o - n); t.max = K(e.pos + e.len, i + n) } }); else if (i.length) { if (!h) n.selectionMarker = h = e({ destroy: xt }, r.plotBox); n.pinchTranslate(f, l, i, o, p, h, v, a); n.hasPinched = c; n.scaleGroups(p, v); !c && s && u === 1 && this.runPointActions(n.normalize(t)) } }, dragStart: function (e) { var t = this.chart; t.mouseIsDown = e.type; t.cancelClick = !1; t.mouseDownX = this.mouseDownX = e.chartX; t.mouseDownY = this.mouseDownY = e.chartY }, drag: function (e) { var t = this.chart, n = t.options.chart, r = e.chartX, i = e.chartY, s = this.zoomHor, o = this.zoomVert, u = t.plotLeft, a = t.plotTop, f = t.plotWidth, l = t.plotHeight, c, h = this.mouseDownX, p = this.mouseDownY; r < u ? r = u : r > u + f && (r = u + f); i < a ? i = a : i > a + l && (i = a + l); this.hasDragged = Math.sqrt(Math.pow(h - r, 2) + Math.pow(p - i, 2)); if (this.hasDragged > 10) { c = t.isInsidePlot(h - u, p - a); if (t.hasCartesianSeries && (this.zoomX || this.zoomY) && c && !this.selectionMarker) this.selectionMarker = t.renderer.rect(u, a, s ? 1 : f, o ? 1 : l, 0).attr({ fill: n.selectionMarkerFill || "rgba(69,114,167,0.25)", zIndex: 7 }).add(); this.selectionMarker && s && (r -= h, this.selectionMarker.attr({ width: G(r), x: (r > 0 ? 0 : r) + h })); this.selectionMarker && o && (r = i - p, this.selectionMarker.attr({ height: G(r), y: (r > 0 ? 0 : r) + p })); c && !this.selectionMarker && n.panning && t.pan(e, n.panning) } }, drop: function (t) { var n = this.chart, r = this.hasPinched; if (this.selectionMarker) { var i = { xAxis: [], yAxis: [], originalEvent: t.originalEvent || t }, s = this.selectionMarker, o = s.x, u = s.y, a; if (this.hasDragged || r) Kt(n.axes, function (e) { if (e.zoomEnabled) { var t = e.horiz, n = e.toValue(t ? o : u), t = e.toValue(t ? o + s.width : u + s.height); !isNaN(n) && !isNaN(t) && (i[e.coll].push({ axis: e, min: Q(n, t), max: K(n, t) }), a = !0) } }), a && tn(n, "selection", i, function (t) { n.zoom(e(t, r ? { animation: !1} : null)) }); this.selectionMarker = this.selectionMarker.destroy(); r && this.scaleGroups() } if (n) v(n.container, { cursor: n._cursor }), n.cancelClick = this.hasDragged > 10, n.mouseIsDown = this.hasDragged = this.hasPinched = !1, this.pinchDown = [] }, onContainerMouseDown: function (e) { e = this.normalize(e); e.preventDefault && e.preventDefault(); this.dragStart(e) }, onDocumentMouseUp: function (e) { this.drop(e) }, onDocumentMouseMove: function (e) { var t = this.chart, n = this.chartPosition, r = t.hoverSeries, e = this.normalize(e, n); n && r && !this.inClass(e.target, "highcharts-tracker") && !t.isInsidePlot(e.chartX - t.plotLeft, e.chartY - t.plotTop) && this.reset() }, onContainerMouseLeave: function () { this.reset(); this.chartPosition = null }, onContainerMouseMove: function (e) { var t = this.chart, e = this.normalize(e); t.mouseIsDown === "mousedown" && this.drag(e); (this.inClass(e.target, "highcharts-tracker") || t.isInsidePlot(e.chartX - t.plotLeft, e.chartY - t.plotTop)) && !t.openMenu && this.runPointActions(e) }, inClass: function (e, t) { for (var n; e; ) { if (n = h(e, "class")) if (n.indexOf(t) !== -1) return !0; else if (n.indexOf("highcharts-container") !== -1) return !1; e = e.parentNode } }, onTrackerMouseOut: function (e) { var t = this.chart.hoverSeries, e = e.relatedTarget || e.toElement, n = e.point && e.point.series; if (t && !t.options.stickyTracking && !this.inClass(e, "highcharts-tooltip") && n !== t) t.onMouseOut() }, onContainerClick: function (t) { var n = this.chart, r = n.hoverPoint, i = n.plotLeft, s = n.plotTop, o = n.inverted, u, a, f, t = this.normalize(t); t.cancelBubble = !0; if (!n.cancelClick) r && this.inClass(t.target, "highcharts-tracker") ? (u = this.chartPosition, a = r.plotX, f = r.plotY, e(r, { pageX: u.left + i + (o ? n.plotWidth - f : a), pageY: u.top + s + (o ? n.plotHeight - a : f) }), tn(r.series, "click", e(t, { point: r })), n.hoverPoint && r.firePointEvent("click", t)) : (e(t, this.getCoordinates(t)), n.isInsidePlot(t.chartX - i, t.chartY - s) && tn(n, "click", t)) }, onContainerTouchStart: function (e) { var t = this.chart; e.touches.length === 1 ? (e = this.normalize(e), t.isInsidePlot(e.chartX - t.plotLeft, e.chartY - t.plotTop) ? (this.runPointActions(e), this.pinch(e)) : this.reset()) : e.touches.length === 2 && this.pinch(e) }, onContainerTouchMove: function (e) { (e.touches.length === 1 || e.touches.length === 2) && this.pinch(e) }, onDocumentTouchEnd: function (e) { this.drop(e) }, setDOMEvents: function () { var e = this, t = e.chart.container, n; this._events = n = [[t, "onmousedown", "onContainerMouseDown"], [t, "onmousemove", "onContainerMouseMove"], [t, "onclick", "onContainerClick"], [t, "mouseleave", "onContainerMouseLeave"], [z, "mouseup", "onDocumentMouseUp"]]; dt && n.push([t, "ontouchstart", "onContainerTouchStart"], [t, "ontouchmove", "onContainerTouchMove"], [z, "touchend", "onDocumentTouchEnd"]); Kt(n, function (t) { e["_" + t[2]] = function (n) { e[t[2]](n) }; t[1].indexOf("on") === 0 ? t[0][t[1]] = e["_" + t[2]] : Zt(t[0], t[1], e["_" + t[2]]) }) }, destroy: function () { var e = this; Kt(e._events, function (t) { t[1].indexOf("on") === 0 ? t[0][t[1]] = null : en(t[0], t[1], e["_" + t[2]]) }); delete e._events; clearInterval(e.tooltipTimeout) } }; var gn = Highcharts.TrackerMixin = { drawTrackerPoint: function () { var e = this, t = e.chart, n = t.pointer, r = e.options.cursor, i = r && { cursor: r }, s = function (n) { var r = n.target, i; if (t.hoverSeries !== e) e.onMouseOver(); for (; r && !i; ) i = r.point, r = r.parentNode; if (i !== U && i !== t.hoverPoint) i.onMouseOver(n) }; Kt(e.points, function (e) { if (e.graphic) e.graphic.element.point = e; if (e.dataLabel) e.dataLabel.element.point = e }); if (!e._hasTracking) Kt(e.trackerGroups, function (t) { if (e[t] && (e[t].addClass("highcharts-tracker").on("mouseover", s).on("mouseout", function (e) { n.onTrackerMouseOut(e) }).css(i), dt)) e[t].on("touchstart", s) }), e._hasTracking = !0 }, drawTrackerGraph: function () { var e = this, t = e.options, n = t.trackByArea, r = [].concat(n ? e.areaPath : e.graphPath), i = r.length, s = e.chart, o = s.pointer, u = s.renderer, a = s.options.tooltip.snap, f = e.tracker, l = t.cursor, c = l && { cursor: l }, l = e.singlePoints, h, p = function () { if (s.hoverSeries !== e) e.onMouseOver() }; if (i && !n) for (h = i + 1; h--; ) r[h] === "M" && r.splice(h + 1, 0, r[h + 1] - a, r[h + 2], "L"), (h && r[h] === "M" || h === i) && r.splice(h, 0, "L", r[h - 2] + a, r[h - 1]); for (h = 0; h < l.length; h++) i = l[h], r.push("M", i.plotX - a, i.plotY, "L", i.plotX + a, i.plotY); f ? f.attr({ d: r }) : (e.tracker = u.path(r).attr({ "stroke-linejoin": "round", visibility: e.visible ? "visible" : "hidden", stroke: Lt, fill: n ? Lt : Ct, "stroke-width": t.lineWidth + (n ? 0 : 2 * a), zIndex: 2 }).add(e.group), Kt([e.tracker, e.markerGroup], function (e) { e.addClass("highcharts-tracker").on("mouseover", p).on("mouseout", function (e) { o.onTrackerMouseOut(e) }).css(c); if (dt) e.on("touchstart", p) })) } }; if (W.PointerEvent || W.MSPointerEvent) { var yn = {}; mn.prototype.getWebkitTouches = function () { var e, t = []; t.item = function (e) { return this[e] }; for (e in yn) yn.hasOwnProperty(e) && t.push({ pageX: yn[e].pageX, pageY: yn[e].pageY, target: yn[e].target }); return t }; w(mn.prototype, "init", function (e, t, n) { t.container.style["-ms-touch-action"] = t.container.style["touch-action"] = "none"; e.call(this, t, n) }); w(mn.prototype, "setDOMEvents", function (e) { var t = this; e.apply(this, Array.prototype.slice.call(arguments, 1)); Kt([[this.chart.container, "PointerDown", "touchstart", "onContainerTouchStart", function (e) { yn[e.pointerId] = { pageX: e.pageX, pageY: e.pageY, target: e.currentTarget} } ], [this.chart.container, "PointerMove", "touchmove", "onContainerTouchMove", function (e) { yn[e.pointerId] = { pageX: e.pageX, pageY: e.pageY }; if (!yn[e.pointerId].target) yn[e.pointerId].target = e.currentTarget } ], [document, "PointerUp", "touchend", "onDocumentTouchEnd", function (e) { delete yn[e.pointerId] } ]], function (e) { Zt(e[0], window.PointerEvent ? e[1].toLowerCase() : "MS" + e[1], function (n) { n = n.originalEvent; if (n.pointerType === "touch" || n.pointerType === n.MSPOINTER_TYPE_TOUCH) e[4](n), t[e[3]]({ type: e[2], target: n.currentTarget, preventDefault: xt, touches: t.getWebkitTouches() }) }) }) }) } var bn = Highcharts.Legend = function (e, t) { this.init(e, t) }; bn.prototype = { init: function (e, n) { var i = this, s = n.itemStyle, o = d(n.padding, 8), u = n.itemMarginTop || 0; this.options = n; if (n.enabled) i.baseline = r(s.fontSize) + 3 + u, i.itemStyle = s, i.itemHiddenStyle = t(s, n.itemHiddenStyle), i.itemMarginTop = u, i.padding = o, i.initialItemX = o, i.initialItemY = o - 5, i.maxItemWidth = 0, i.chart = e, i.itemHeight = 0, i.lastLineHeight = 0, i.symbolWidth = d(n.symbolWidth, 16), i.pages = [], i.render(), Zt(i.chart, "endResize", function () { i.positionCheckboxes() }) }, colorizeItem: function (e, t) { var n = this.options, r = e.legendItem, i = e.legendLine, s = e.legendSymbol, o = this.itemHiddenStyle.color, n = t ? n.itemStyle.color : o, u = t ? e.legendColor || e.color : o, o = e.options && e.options.marker, a = { stroke: u, fill: u }, f; r && r.css({ fill: n, color: n }); i && i.attr({ stroke: u }); if (s) { if (o && s.isMarker) for (f in o = e.convertAttribs(o), o) r = o[f], r !== U && (a[f] = r); s.attr(a) } }, positionItem: function (e) { var t = this.options, n = t.symbolPadding, t = !t.rtl, r = e._legendItemPos, i = r[0], r = r[1], s = e.checkbox; e.legendGroup && e.legendGroup.translate(t ? i : this.legendWidth - i - 2 * n - 4, r); if (s) s.x = i, s.y = r }, destroyItem: function (e) { var t = e.checkbox; Kt(["legendItem", "legendLine", "legendSymbol", "legendGroup"], function (t) { e[t] && (e[t] = e[t].destroy()) }); t && A(e.checkbox) }, destroy: function () { var e = this.group, t = this.box; if (t) this.box = t.destroy(); if (e) this.group = e.destroy() }, positionCheckboxes: function (e) { var t = this.group.alignAttr, n, r = this.clipHeight || this.legendHeight; if (t) n = t.translateY, Kt(this.allItems, function (i) { var s = i.checkbox, o; s && (o = n + s.y + (e || 0) + 3, v(s, { left: t.translateX + i.legendItemWidth + s.x - 20 + "px", top: o + "px", display: o > n - 6 && o < n + r - 6 ? "" : Ct })) }) }, renderTitle: function () { var e = this.padding, t = this.options.title, n = 0; if (t.text) { if (!this.title) this.title = this.chart.renderer.label(t.text, e - 3, e - 4, null, null, null, null, null, "legend-title").attr({ zIndex: 1 }).css(t.style).add(this.group); e = this.title.getBBox(); n = e.height; this.offsetWidth = e.width; this.contentGroup.attr({ translateY: n }) } this.titleHeight = n }, renderItem: function (e) { var n; var r = this, i = r.chart, s = i.renderer, o = r.options, u = o.layout === "horizontal", a = r.symbolWidth, f = o.symbolPadding, l = r.itemStyle, c = r.itemHiddenStyle, h = r.padding, p = u ? d(o.itemDistance, 8) : 0, v = !o.rtl, g = o.width, y = o.itemMarginBottom || 0, b = r.itemMarginTop, w = r.initialItemX, S = e.legendItem, x = e.series && e.series.drawLegendSymbol ? e.series : e, T = x.options, T = T && T.showCheckbox, N = o.useHTML; if (!S && (e.legendGroup = s.g("legend-item").attr({ zIndex: 1 }).add(r.scrollGroup), x.drawLegendSymbol(r, e), e.legendItem = S = s.text(o.labelFormat ? E(o.labelFormat, e) : o.labelFormatter.call(e), v ? a + f : -f, r.baseline, N).css(t(e.visible ? l : c)).attr({ align: v ? "left" : "right", zIndex: 2 }).add(e.legendGroup), (N ? S : e.legendGroup).on("mouseover", function () { e.setState("hover"); S.css(r.options.itemHoverStyle) }).on("mouseout", function () { S.css(e.visible ? l : c); e.setState() }).on("click", function (t) { var n = function () { e.setVisible() }, t = { browserEvent: t }; e.firePointEvent ? e.firePointEvent("legendItemClick", t, n) : tn(e, "legendItemClick", t, n) }), r.colorizeItem(e, e.visible), T)) e.checkbox = m("input", { type: "checkbox", checked: e.selected, defaultChecked: e.selected }, o.itemCheckboxStyle, i.container), Zt(e.checkbox, "click", function (t) { tn(e, "checkboxClick", { checked: t.target.checked }, function () { e.select() }) }); s = S.getBBox(); n = e.legendItemWidth = o.itemWidth || e.legendItemWidth || a + f + s.width + p + (T ? 20 : 0), o = n; r.itemHeight = a = V(e.legendItemHeight || s.height); if (u && r.itemX - w + o > (g || i.chartWidth - 2 * h - w)) r.itemX = w, r.itemY += b + r.lastLineHeight + y, r.lastLineHeight = 0; r.maxItemWidth = K(r.maxItemWidth, o); r.lastItemY = b + r.itemY + y; r.lastLineHeight = K(a, r.lastLineHeight); e._legendItemPos = [r.itemX, r.itemY]; u ? r.itemX += o : (r.itemY += b + a + y, r.lastLineHeight = a); r.offsetWidth = g || K((u ? r.itemX - w - p : o) + h, r.offsetWidth) }, getAllItems: function () { var e = []; Kt(this.chart.series, function (t) { var n = t.options; if (d(n.showInLegend, !c(n.linkedTo) ? U : !1, !0)) e = e.concat(t.legendItems || (n.legendType === "point" ? t.data : t)) }); return e }, render: function () { var t = this, n = t.chart, r = n.renderer, i = t.group, s, o, u, a, f = t.box, l = t.options, c = t.padding, h = l.borderWidth, p = l.backgroundColor; t.itemX = t.initialItemX; t.itemY = t.initialItemY; t.offsetWidth = 0; t.lastItemY = 0; if (!i) t.group = i = r.g("legend").attr({ zIndex: 7 }).add(), t.contentGroup = r.g().attr({ zIndex: 1 }).add(i), t.scrollGroup = r.g().add(t.contentGroup); t.renderTitle(); s = t.getAllItems(); N(s, function (e, t) { return (e.options && e.options.legendIndex || 0) - (t.options && t.options.legendIndex || 0) }); l.reversed && s.reverse(); t.allItems = s; t.display = o = !!s.length; Kt(s, function (e) { t.renderItem(e) }); u = l.width || t.offsetWidth; a = t.lastItemY + t.lastLineHeight + t.titleHeight; a = t.handleOverflow(a); if (h || p) { u += c; a += c; if (f) { if (u > 0 && a > 0) f[f.isNew ? "attr" : "animate"](f.crisp(null, null, null, u, a)), f.isNew = !1 } else t.box = f = r.rect(0, 0, u, a, l.borderRadius, h || 0).attr({ stroke: l.borderColor, "stroke-width": h || 0, fill: p || Ct }).add(i).shadow(l.shadow), f.isNew = !0; f[o ? "show" : "hide"]() } t.legendWidth = u; t.legendHeight = a; Kt(s, function (e) { t.positionItem(e) }); o && i.align(e({ width: u, height: a }, l), !0, "spacingBox"); n.isResizing || this.positionCheckboxes() }, handleOverflow: function (e) { var t = this, n = this.chart, r = n.renderer, i = this.options, s = i.y, s = n.spacingBox.height + (i.verticalAlign === "top" ? -s : s) - this.padding, o = i.maxHeight, u, a = this.clipRect, f = i.navigation, l = d(f.animation, !0), c = f.arrowSize || 12, h = this.nav, p = this.pages, v, m = this.allItems; i.layout === "horizontal" && (s /= 2); o && (s = Q(s, o)); p.length = 0; if (e > s && !i.useHTML) { this.clipHeight = u = s - 20 - this.titleHeight - this.padding; this.currentPage = d(this.currentPage, 1); this.fullHeight = e; Kt(m, function (e, t) { var n = e._legendItemPos[1], r = V(e.legendItem.bBox.height), i = p.length; if (!i || n - p[i - 1] > u) p.push(v || n); t === m.length - 1 && n + r - p[i - 1] > u && p.push(n); n !== v && (v = n) }); if (!a) a = t.clipRect = r.clipRect(0, this.padding, 9999, 0), t.contentGroup.clip(a); a.attr({ height: u }); if (!h) this.nav = h = r.g().attr({ zIndex: 1 }).add(this.group), this.up = r.symbol("triangle", 0, 0, c, c).on("click", function () { t.scroll(-1, l) }).add(h), this.pager = r.text("", 15, 10).css(f.style).add(h), this.down = r.symbol("triangle-down", 0, 0, c, c).on("click", function () { t.scroll(1, l) }).add(h); t.scroll(0); e = s } else if (h) a.attr({ height: n.chartHeight }), h.hide(), this.scrollGroup.attr({ translateY: 1 }), this.clipHeight = 0; return e }, scroll: function (e, t) { var n = this.pages, r = n.length, i = this.currentPage + e, s = this.clipHeight, o = this.options.navigation, u = o.activeColor, o = o.inactiveColor, a = this.pager, f = this.padding; i > r && (i = r); if (i > 0) t !== U && _(t, this.chart), this.nav.attr({ translateX: f, translateY: s + this.padding + 7 + this.titleHeight, visibility: "visible" }), this.up.attr({ fill: i === 1 ? o : u }).css({ cursor: i === 1 ? "default" : "pointer" }), a.attr({ text: i + "/" + r }), this.down.attr({ x: 18 + this.pager.getBBox().width, fill: i === r ? o : u }).css({ cursor: i === r ? "default" : "pointer" }), n = -n[i - 1] + this.initialItemY, this.scrollGroup.animate({ translateY: n }), this.currentPage = i, this.positionCheckboxes(n) } }; Xt = Highcharts.LegendSymbolMixin = { drawRectangle: function (e, t) { var n = e.options.symbolHeight || 12; t.legendSymbol = this.chart.renderer.rect(0, e.baseline - 5 - n / 2, e.symbolWidth, n, d(e.options.symbolRadius, 2)).attr({ zIndex: 3 }).add(t.legendGroup) }, drawLineMarker: function (e) { var t = this.options, n = t.marker, r; r = e.symbolWidth; var i = this.chart.renderer, s = this.legendGroup, e = e.baseline - V(i.fontMetrics(e.options.itemStyle.fontSize).b * .3), o; if (t.lineWidth) { o = { "stroke-width": t.lineWidth }; if (t.dashStyle) o.dashstyle = t.dashStyle; this.legendLine = i.path(["M", 0, e, "L", r, e]).attr(o).add(s) } if (n && n.enabled) t = n.radius, this.legendSymbol = r = i.symbol(this.symbol, r / 2 - t, e - t, 2 * t, 2 * t).add(s), r.isMarker = !0 } }; /Trident\/7\.0/.test(nt) && w(bn.prototype, "positionItem", function (e, t) { var n = this, r = function () { t._legendItemPos && e.call(n, t) }; n.chart.renderer.forExport ? r() : setTimeout(r) }); I.prototype = { init: function (e, n) { var r, i = e.series; e.series = null; r = t(yt, e); r.series = e.series = i; this.userOptions = e; i = r.chart; this.margin = this.splashArray("margin", i); this.spacing = this.splashArray("spacing", i); var s = i.events; this.bounds = { h: {}, v: {} }; this.callback = n; this.isResizing = 0; this.options = r; this.axes = []; this.series = []; this.hasCartesianSeries = i.showAxes; var o = this, u; o.index = Tt.length; Tt.push(o); i.reflow !== !1 && Zt(o, "load", function () { o.initReflow() }); if (s) for (u in s) Zt(o, u, s[u]); o.xAxis = []; o.yAxis = []; o.animation = ht ? !1 : d(i.animation, !0); o.pointCount = 0; o.counters = new T; o.firstRender() }, initSeries: function (e) { var t = this.options.chart; (t = zt[e.type || t.type || t.defaultSeriesType]) || O(17, !0); t = new t; t.init(this, e); return t }, isInsidePlot: function (e, t, n) { var r = n ? t : e, e = n ? e : t; return r >= 0 && r <= this.plotWidth && e >= 0 && e <= this.plotHeight }, adjustTickAmounts: function () { this.options.chart.alignTicks !== !1 && Kt(this.axes, function (e) { e.adjustTickAmount() }); this.maxTicks = null }, redraw: function (t) { var n = this.axes, r = this.series, i = this.pointer, s = this.legend, o = this.isDirtyLegend, u, a, f = this.isDirtyBox, l = r.length, c = l, h = this.renderer, p = h.isHidden(), d = []; _(t, this); p && this.cloneRenderTo(); for (this.layOutTitles(); c--; ) if (t = r[c], t.options.stacking && (u = !0, t.isDirty)) { a = !0; break } if (a) for (c = l; c--; ) if (t = r[c], t.options.stacking) t.isDirty = !0; Kt(r, function (e) { e.isDirty && e.options.legendType === "point" && (o = !0) }); if (o && s.options.enabled) s.render(), this.isDirtyLegend = !1; u && this.getStacks(); if (this.hasCartesianSeries) { if (!this.isResizing) this.maxTicks = null, Kt(n, function (e) { e.setScale() }); this.adjustTickAmounts(); this.getMargins(); Kt(n, function (e) { e.isDirty && (f = !0) }); Kt(n, function (t) { if (t.isDirtyExtremes) t.isDirtyExtremes = !1, d.push(function () { tn(t, "afterSetExtremes", e(t.eventArgs, t.getExtremes())); delete t.eventArgs }); (f || u) && t.redraw() }) } f && this.drawChartBox(); Kt(r, function (e) { e.isDirty && e.visible && (!e.isCartesian || e.xAxis) && e.redraw() }); i && i.reset && i.reset(!0); h.draw(); tn(this, "redraw"); p && this.cloneRenderTo(!0); Kt(d, function (e) { e.call() }) }, get: function (e) { var t = this.axes, n = this.series, r, i; for (r = 0; r < t.length; r++) if (t[r].options.id === e) return t[r]; for (r = 0; r < n.length; r++) if (n[r].options.id === e) return n[r]; for (r = 0; r < n.length; r++) { i = n[r].points || []; for (t = 0; t < i.length; t++) if (i[t].id === e) return i[t] } return null }, getAxes: function () { var e = this, t = this.options, n = t.xAxis = p(t.xAxis || {}), t = t.yAxis = p(t.yAxis || {}); Kt(n, function (e, t) { e.index = t; e.isX = !0 }); Kt(t, function (e, t) { e.index = t }); n = n.concat(t); Kt(n, function (t) { new j(e, t) }); e.adjustTickAmounts() }, getSelectedPoints: function () { var e = []; Kt(this.series, function (t) { e = e.concat(Qt(t.points || [], function (e) { return e.selected })) }); return e }, getSelectedSeries: function () { return Qt(this.series, function (e) { return e.selected }) }, getStacks: function () { var e = this; Kt(e.yAxis, function (e) { if (e.stacks && e.hasVisibleSeries) e.oldStacks = e.stacks }); Kt(e.series, function (t) { if (t.options.stacking && (t.visible === !0 || e.options.chart.ignoreHiddenSeries === !1)) t.stackKey = t.type + d(t.options.stack, "") }) }, showResetZoom: function () { var e = this, t = yt.lang, n = e.options.chart.resetZoomButton, r = n.theme, i = r.states, s = n.relativeTo === "chart" ? null : "plotBox"; this.resetZoomButton = e.renderer.button(t.resetZoom, null, null, function () { e.zoomOut() }, r, i && i.hover).attr({ align: n.position.align, title: t.resetZoomTitle }).add().align(n.position, !1, s) }, zoomOut: function () { var e = this; tn(e, "selection", { resetSelection: !0 }, function () { e.zoom() }) }, zoom: function (e) { var t, n = this.pointer, r = !1, i; !e || e.resetSelection ? Kt(this.axes, function (e) { t = e.zoom() }) : Kt(e.xAxis.concat(e.yAxis), function (e) { var i = e.axis, s = i.isXAxis; if (n[s ? "zoomX" : "zoomY"] || n[s ? "pinchX" : "pinchY"]) t = i.zoom(e.min, e.max), i.displayBtn && (r = !0) }); i = this.resetZoomButton; if (r && !i) this.showResetZoom(); else if (!r && s(i)) this.resetZoomButton = i.destroy(); t && this.redraw(d(this.options.chart.animation, e && e.animation, this.pointCount < 100)) }, pan: function (e, t) { var n = this, r = n.hoverPoints, i; r && Kt(r, function (e) { e.setState() }); Kt(t === "xy" ? [1, 0] : [1], function (t) { var r = e[t ? "chartX" : "chartY"], s = n[t ? "xAxis" : "yAxis"][0], o = n[t ? "mouseDownX" : "mouseDownY"], u = (s.pointRange || 0) / 2, a = s.getExtremes(), f = s.toValue(o - r, !0) + u, o = s.toValue(o + n[t ? "plotWidth" : "plotHeight"] - r, !0) - u; s.series.length && f > Q(a.dataMin, a.min) && o < K(a.dataMax, a.max) && (s.setExtremes(f, o, !1, !1, { trigger: "pan" }), i = !0); n[t ? "mouseDownX" : "mouseDownY"] = r }); i && n.redraw(!1); v(n.container, { cursor: "move" }) }, setTitle: function (e, n) { var r; var i = this, s = i.options, o; o = s.title = t(s.title, e); r = s.subtitle = t(s.subtitle, n), s = r; Kt([["title", e, o], ["subtitle", n, s]], function (e) { var t = e[0], n = i[t], r = e[1], e = e[2]; n && r && (i[t] = n = n.destroy()); e && e.text && !n && (i[t] = i.renderer.text(e.text, 0, 0, e.useHTML).attr({ align: e.align, "class": "highcharts-" + t, zIndex: e.zIndex || 4 }).css(e.style).add()) }); i.layOutTitles() }, layOutTitles: function () { var t = 0, n = this.title, r = this.subtitle, i = this.options, s = i.title, i = i.subtitle, o = this.spacingBox.width - 44; if (n && (n.css({ width: (s.width || o) + "px" }).align(e({ y: 15 }, s), !1, "spacingBox"), !s.floating && !s.verticalAlign)) t = n.getBBox().height, t >= 18 && t <= 25 && (t = 15); r && (r.css({ width: (i.width || o) + "px" }).align(e({ y: t + s.margin }, i), !1, "spacingBox"), !i.floating && !i.verticalAlign && (t = J(t + r.getBBox().height))); this.titleOffset = t }, getChartSize: function () { var e = this.options.chart, t = this.renderToClone || this.renderTo; this.containerWidth = Vt(t, "width"); this.containerHeight = Vt(t, "height"); this.chartWidth = K(0, e.width || this.containerWidth || 600); this.chartHeight = K(0, d(e.height, this.containerHeight > 19 ? this.containerHeight : 400)) }, cloneRenderTo: function (e) { var t = this.renderToClone, n = this.container; e ? t && (this.renderTo.appendChild(n), A(t), delete this.renderToClone) : (n && n.parentNode === this.renderTo && this.renderTo.removeChild(n), this.renderToClone = t = this.renderTo.cloneNode(0), v(t, { position: "absolute", top: "-9999px", display: "block" }), z.body.appendChild(t), n && t.appendChild(n)) }, getContainer: function () { var t, n = this.options.chart, s, o, u; this.renderTo = t = n.renderTo; u = "highcharts-" + mt++; if (i(t)) this.renderTo = t = z.getElementById(t); t || O(13, !0); s = r(h(t, "data-highcharts-chart")); !isNaN(s) && Tt[s] && Tt[s].destroy(); h(t, "data-highcharts-chart", this.index); t.innerHTML = ""; t.offsetWidth || this.cloneRenderTo(); this.getChartSize(); s = this.chartWidth; o = this.chartHeight; this.container = t = m(Nt, { className: "highcharts-container" + (n.className ? " " + n.className : ""), id: u }, e({ position: "relative", overflow: "hidden", width: s + "px", height: o + "px", textAlign: "left", lineHeight: "normal", zIndex: 0, "-webkit-tap-highlight-color": "rgba(0,0,0,0)" }, n.style), this.renderToClone || t); this._cursor = t.style.cursor; this.renderer = n.forExport ? new cn(t, s, o, !0) : new pt(t, s, o); ht && this.renderer.create(this, t, s, o) }, getMargins: function () { var e = this.spacing, t, n = this.legend, r = this.margin, i = this.options.legend, s = d(i.margin, 10), o = i.x, u = i.y, a = i.align, f = i.verticalAlign, l = this.titleOffset; this.resetMargins(); t = this.axisOffset; if (l && !c(r[0])) this.plotTop = K(this.plotTop, l + this.options.title.margin + e[0]); if (n.display && !i.floating) if (a === "right") { if (!c(r[1])) this.marginRight = K(this.marginRight, n.legendWidth - o + s + e[1]) } else if (a === "left") { if (!c(r[3])) this.plotLeft = K(this.plotLeft, n.legendWidth + o + s + e[3]) } else if (f === "top") { if (!c(r[0])) this.plotTop = K(this.plotTop, n.legendHeight + u + s + e[0]) } else if (f === "bottom" && !c(r[2])) this.marginBottom = K(this.marginBottom, n.legendHeight - u + s + e[2]); this.extraBottomMargin && (this.marginBottom += this.extraBottomMargin); this.extraTopMargin && (this.plotTop += this.extraTopMargin); this.hasCartesianSeries && Kt(this.axes, function (e) { e.getOffset() }); c(r[3]) || (this.plotLeft += t[3]); c(r[0]) || (this.plotTop += t[0]); c(r[2]) || (this.marginBottom += t[2]); c(r[1]) || (this.marginRight += t[1]); this.setChartSize() }, reflow: function (e) { var t = this, n = t.options.chart, r = t.renderTo, i = n.width || Vt(r, "width"), s = n.height || Vt(r, "height"), n = e ? e.target : W, r = function () { if (t.container) t.setSize(i, s, !1), t.hasUserSize = null }; if (!t.hasUserSize && i && s && (n === W || n === z)) { if (i !== t.containerWidth || s !== t.containerHeight) clearTimeout(t.reflowTimeout), e ? t.reflowTimeout = setTimeout(r, 100) : r(); t.containerWidth = i; t.containerHeight = s } }, initReflow: function () { var e = this, t = function (t) { e.reflow(t) }; Zt(W, "resize", t); Zt(e, "destroy", function () { en(W, "resize", t) }) }, setSize: function (e, t, n) { var r = this, i, s, o; r.isResizing += 1; o = function () { r && tn(r, "endResize", null, function () { r.isResizing -= 1 }) }; _(n, r); r.oldChartHeight = r.chartHeight; r.oldChartWidth = r.chartWidth; if (c(e)) r.chartWidth = i = K(0, V(e)), r.hasUserSize = !!i; if (c(t)) r.chartHeight = s = K(0, V(t)); (wt ? rn : v)(r.container, { width: i + "px", height: s + "px" }, wt); r.setChartSize(!0); r.renderer.setSize(i, s, n); r.maxTicks = null; Kt(r.axes, function (e) { e.isDirty = !0; e.setScale() }); Kt(r.series, function (e) { e.isDirty = !0 }); r.isDirtyLegend = !0; r.isDirtyBox = !0; r.getMargins(); r.redraw(n); r.oldChartHeight = null; tn(r, "resize"); wt === !1 ? o() : setTimeout(o, wt && wt.duration || 500) }, setChartSize: function (e) { var t = this.inverted, n = this.renderer, r = this.chartWidth, i = this.chartHeight, s = this.options.chart, o = this.spacing, u = this.clipOffset, a, f, l, c; this.plotLeft = a = V(this.plotLeft); this.plotTop = f = V(this.plotTop); this.plotWidth = l = K(0, V(r - a - this.marginRight)); this.plotHeight = c = K(0, V(i - f - this.marginBottom)); this.plotSizeX = t ? c : l; this.plotSizeY = t ? l : c; this.plotBorderWidth = s.plotBorderWidth || 0; this.spacingBox = n.spacingBox = { x: o[3], y: o[0], width: r - o[3] - o[1], height: i - o[0] - o[2] }; this.plotBox = n.plotBox = { x: a, y: f, width: l, height: c }; r = 2 * $(this.plotBorderWidth / 2); t = J(K(r, u[3]) / 2); n = J(K(r, u[0]) / 2); this.clipBox = { x: t, y: n, width: $(this.plotSizeX - K(r, u[1]) / 2 - t), height: $(this.plotSizeY - K(r, u[2]) / 2 - n) }; e || Kt(this.axes, function (e) { e.setAxisSize(); e.setAxisTranslation() }) }, resetMargins: function () { var e = this.spacing, t = this.margin; this.plotTop = d(t[0], e[0]); this.marginRight = d(t[1], e[1]); this.marginBottom = d(t[2], e[2]); this.plotLeft = d(t[3], e[3]); this.axisOffset = [0, 0, 0, 0]; this.clipOffset = [0, 0, 0, 0] }, drawChartBox: function () { var e = this.options.chart, t = this.renderer, n = this.chartWidth, r = this.chartHeight, i = this.chartBackground, s = this.plotBackground, o = this.plotBorder, u = this.plotBGImage, a = e.borderWidth || 0, f = e.backgroundColor, l = e.plotBackgroundColor, c = e.plotBackgroundImage, h = e.plotBorderWidth || 0, p, d = this.plotLeft, v = this.plotTop, m = this.plotWidth, g = this.plotHeight, y = this.plotBox, b = this.clipRect, w = this.clipBox; p = a + (e.shadow ? 8 : 0); if (a || f) if (i) i.animate(i.crisp(null, null, null, n - p, r - p)); else { i = { fill: f || Ct }; if (a) i.stroke = e.borderColor, i["stroke-width"] = a; this.chartBackground = t.rect(p / 2, p / 2, n - p, r - p, e.borderRadius, a).attr(i).add().shadow(e.shadow) } if (l) s ? s.animate(y) : this.plotBackground = t.rect(d, v, m, g, 0).attr({ fill: l }).add().shadow(e.plotShadow); if (c) u ? u.animate(y) : this.plotBGImage = t.image(c, d, v, m, g).add(); b ? b.animate({ width: w.width, height: w.height }) : this.clipRect = t.clipRect(w); if (h) o ? o.animate(o.crisp(null, d, v, m, g)) : this.plotBorder = t.rect(d, v, m, g, 0, -h).attr({ stroke: e.plotBorderColor, "stroke-width": h, zIndex: 1 }).add(); this.isDirtyBox = !1 }, propFromSeries: function () { var e = this, t = e.options.chart, n, r = e.options.series, i, s; Kt(["inverted", "angular", "polar"], function (o) { n = zt[t.type || t.defaultSeriesType]; s = e[o] || t[o] || n && n.prototype[o]; for (i = r && r.length; !s && i--; ) (n = zt[r[i].type]) && n.prototype[o] && (s = !0); e[o] = s }) }, linkSeries: function () { var e = this, t = e.series; Kt(t, function (e) { e.linkedSeries.length = 0 }); Kt(t, function (t) { var n = t.options.linkedTo; if (i(n) && (n = n === ":previous" ? e.series[t.index - 1] : e.get(n))) n.linkedSeries.push(t), t.linkedParent = n }) }, render: function () { var t = this, n = t.axes, i = t.renderer, s = t.options, o = s.labels, u = s.credits, a; t.setTitle(); t.legend = new bn(t, s.legend); t.getStacks(); Kt(n, function (e) { e.setScale() }); t.getMargins(); t.maxTicks = null; Kt(n, function (e) { e.setTickPositions(!0); e.setMaxTicks() }); t.adjustTickAmounts(); t.getMargins(); t.drawChartBox(); t.hasCartesianSeries && Kt(n, function (e) { e.render() }); if (!t.seriesGroup) t.seriesGroup = i.g("series-group").attr({ zIndex: 3 }).add(); Kt(t.series, function (e) { e.translate(); e.setTooltipPoints(); e.render() }); o.items && Kt(o.items, function (n) { var s = e(o.style, n.style), u = r(s.left) + t.plotLeft, a = r(s.top) + t.plotTop + 12; delete s.left; delete s.top; i.text(n.html, u, a).attr({ zIndex: 2 }).css(s).add() }); if (u.enabled && !t.credits) a = u.href, t.credits = i.text(u.text, 0, 0).on("click", function () { if (a) location.href = a }).attr({ align: u.position.align, zIndex: 8 }).css(u.style).add().align(u.position); t.hasRendered = !0 }, destroy: function () { var e = this, t = e.axes, n = e.series, r = e.container, i, s = r && r.parentNode; tn(e, "destroy"); Tt[e.index] = U; e.renderTo.removeAttribute("data-highcharts-chart"); en(e); for (i = t.length; i--; ) t[i] = t[i].destroy(); for (i = n.length; i--; ) n[i] = n[i].destroy(); Kt("title,subtitle,chartBackground,plotBackground,plotBGImage,plotBorder,seriesGroup,clipRect,credits,pointer,scroller,rangeSelector,legend,resetZoomButton,tooltip,renderer".split(","), function (t) { var n = e[t]; n && n.destroy && (e[t] = n.destroy()) }); if (r) r.innerHTML = "", en(r), s && A(r); for (i in e) delete e[i] }, isReadyToRender: function () { var e = this; return !lt && W == W.top && z.readyState !== "complete" || ht && !W.canvg ? (ht ? dn.push(function () { e.firstRender() }, e.options.global.canvasToolsURL) : z.attachEvent("onreadystatechange", function () { z.detachEvent("onreadystatechange", e.firstRender); z.readyState === "complete" && e.firstRender() }), !1) : !0 }, firstRender: function () { var e = this, t = e.options, n = e.callback; if (e.isReadyToRender()) e.getContainer(), tn(e, "init"), e.resetMargins(), e.setChartSize(), e.propFromSeries(), e.getAxes(), Kt(t.series || [], function (t) { e.initSeries(t) }), e.linkSeries(), tn(e, "beforeRender"), e.pointer = new mn(e, t), e.render(), e.renderer.draw(), n && n.apply(e, [e]), Kt(e.callbacks, function (t) { t.apply(e, [e]) }), e.cloneRenderTo(!0), tn(e, "load") }, splashArray: function (e, t) { var n = t[e], n = s(n) ? n : [n, n, n, n]; return [d(t[e + "Top"], n[0]), d(t[e + "Right"], n[1]), d(t[e + "Bottom"], n[2]), d(t[e + "Left"], n[3])] } }; I.prototype.callbacks = []; pn = Highcharts.CenteredSeriesMixin = { getCenter: function () { var e = this.options, t = this.chart, n = 2 * (e.slicedOffset || 0), i, s = t.plotWidth - 2 * n, o = t.plotHeight - 2 * n, t = e.center, e = [d(t[0], "50%"), d(t[1], "50%"), e.size || "100%", e.innerSize || 0], u = Q(s, o), a; return Yt(e, function (e, t) { a = /%$/.test(e); i = t < 2 || t === 2 && a; return (a ? [s, o, u, u][t] * r(e) / 100 : e) + (i ? n : 0) }) } }; var wn = function () { }; wn.prototype = { init: function (e, t, n) { this.series = e; this.applyOptions(t, n); this.pointAttr = {}; if (e.options.colorByPoint && (t = e.options.colors || e.chart.options.colors, this.color = this.color || t[e.colorCounter++], e.colorCounter === t.length)) e.colorCounter = 0; e.chart.pointCount++; return this }, applyOptions: function (t, n) { var r = this.series, i = r.pointValKey, t = wn.prototype.optionsToObject.call(this, t); e(this, t); this.options = this.options ? e(this.options, t) : t; if (i) this.y = this[i]; if (this.x === U && r) this.x = n === U ? r.autoIncrement() : n; return this }, optionsToObject: function (e) { var t = {}, n = this.series, r = n.pointArrayMap || ["y"], i = r.length, s = 0, u = 0; if (typeof e === "number" || e === null) t[r[0]] = e; else if (o(e)) { if (e.length > i) { n = typeof e[0]; if (n === "string") t.name = e[0]; else if (n === "number") t.x = e[0]; s++ } for (; u < i; ) t[r[u++]] = e[s++] } else if (typeof e === "object") { t = e; if (e.dataLabels) n._hasPointLabels = !0; if (e.marker) n._hasPointMarkers = !0 } return t }, destroy: function () { var e = this.series.chart, t = e.hoverPoints, n; e.pointCount--; if (t && (this.setState(), l(t, this), !t.length)) e.hoverPoints = null; if (this === e.hoverPoint) this.onMouseOut(); if (this.graphic || this.dataLabel) en(this), this.destroyElements(); this.legendItem && e.legend.destroyItem(this); for (n in this) this[n] = null }, destroyElements: function () { for (var e = "graphic,dataLabel,dataLabelUpper,group,connector,shadowGroup".split(","), t, n = 6; n--; ) t = e[n], this[t] && (this[t] = this[t].destroy()) }, getLabelConfig: function () { return { x: this.category, y: this.y, key: this.name || this.category, series: this.series, point: this, percentage: this.percentage, total: this.total || this.stackTotal} }, select: function (e, t) { var n = this, r = n.series, i = r.chart, e = d(e, !n.selected); n.firePointEvent(e ? "select" : "unselect", { accumulate: t }, function () { n.selected = n.options.selected = e; r.options.data[Jt(n, r.data)] = n.options; n.setState(e && "select"); t || Kt(i.getSelectedPoints(), function (e) { if (e.selected && e !== n) e.selected = e.options.selected = !1, r.options.data[Jt(e, r.data)] = e.options, e.setState(""), e.firePointEvent("unselect") }) }) }, onMouseOver: function (e) { var t = this.series, n = t.chart, r = n.tooltip, i = n.hoverPoint; if (i && i !== this) i.onMouseOut(); this.firePointEvent("mouseOver"); r && (!r.shared || t.noSharedTooltip) && r.refresh(this, e); this.setState("hover"); n.hoverPoint = this }, onMouseOut: function () { var e = this.series.chart, t = e.hoverPoints; if (!t || Jt(this, t) === -1) this.firePointEvent("mouseOut"), this.setState(), e.hoverPoint = null }, tooltipFormatter: function (e) { var t = this.series, n = t.tooltipOptions, r = d(n.valueDecimals, ""), i = n.valuePrefix || "", s = n.valueSuffix || ""; Kt(t.pointArrayMap || ["y"], function (t) { t = "{point." + t; if (i || s) e = e.replace(t + "}", i + t + "}" + s); e = e.replace(t + "}", t + ":,." + r + "f}") }); return E(e, { point: this, series: this.series }) }, firePointEvent: function (e, t, n) { var r = this, i = this.series.options; (i.point.events[e] || r.options && r.options.events && r.options.events[e]) && this.importEvents(); e === "click" && i.allowPointSelect && (n = function (e) { r.select(null, e.ctrlKey || e.metaKey || e.shiftKey) }); tn(this, e, t, n) }, importEvents: function () { if (!this.hasImportedEvents) { var e = t(this.series.options.point, this.options).events, n; this.events = e; for (n in e) Zt(this, n, e[n]); this.hasImportedEvents = !0 } }, setState: function (e, n) { var r = this.plotX, i = this.plotY, s = this.series, o = s.options.states, u = on[s.type].marker && s.options.marker, a = u && !u.enabled, f = u && u.states[e], l = f && f.enabled === !1, c = s.stateMarkerGraphic, h = this.marker || {}, p = s.chart, d = this.pointAttr, e = e || "", n = n && c; if (!(e === this.state && !n || this.selected && e !== "select" || o[e] && o[e].enabled === !1 || e && (l || a && !f.enabled) || e && h.states && h.states[e] && h.states[e].enabled === !1)) { if (this.graphic) o = u && this.graphic.symbolName && d[e].r, this.graphic.attr(t(d[e], o ? { x: r - o, y: i - o, width: 2 * o, height: 2 * o} : {})); else { if (e && f) if (o = f.radius, h = h.symbol || s.symbol, c && c.currentSymbol !== h && (c = c.destroy()), c) c[n ? "animate" : "attr"]({ x: r - o, y: i - o }); else s.stateMarkerGraphic = c = p.renderer.symbol(h, r - o, i - o, 2 * o, 2 * o).attr(d[e]).add(s.markerGroup), c.currentSymbol = h; if (c) c[e && p.isInsidePlot(r, i, p.inverted) ? "show" : "hide"]() } this.state = e } } }; var En = function () { }; En.prototype = { isCartesian: !0, type: "line", pointClass: wn, sorted: !0, requireSorting: !0, pointAttrToOptions: { stroke: "lineColor", "stroke-width": "lineWidth", fill: "fillColor", r: "radius" }, axisTypes: ["xAxis", "yAxis"], colorCounter: 0, parallelArrays: ["x", "y"], init: function (t, n) { var r = this, i, s, o = t.series, u = function (e, t) { return d(e.options.index, e._i) - d(t.options.index, t._i) }; r.chart = t; r.options = n = r.setOptions(n); r.linkedSeries = []; r.bindAxes(); e(r, { name: n.name, state: "", pointAttr: {}, visible: n.visible !== !1, selected: n.selected === !0 }); if (ht) n.animation = !1; s = n.events; for (i in s) Zt(r, i, s[i]); if (s && s.click || n.point && n.point.events && n.point.events.click || n.allowPointSelect) t.runTrackerClick = !0; r.getColor(); r.getSymbol(); Kt(r.parallelArrays, function (e) { r[e + "Data"] = [] }); r.setData(n.data, !1); if (r.isCartesian) t.hasCartesianSeries = !0; o.push(r); r._i = o.length - 1; N(o, u); this.yAxis && N(this.yAxis.series, u); Kt(o, function (e, t) { e.index = t; e.name = e.name || "Series " + (t + 1) }) }, bindAxes: function () { var e = this, t = e.options, n = e.chart, r; Kt(e.axisTypes || [], function (i) { Kt(n[i], function (n) { r = n.options; if (t[i] === r.index || t[i] !== U && t[i] === r.id || t[i] === U && r.index === 0) n.series.push(e), e[i] = n, n.isDirty = !0 }); !e[i] && e.optionalAxis !== i && O(18, !0) }) }, updateParallelArrays: function (e, t) { var n = e.series, r = arguments; Kt(n.parallelArrays, typeof t === "number" ? function (r) { var i = r === "y" && n.toYData ? n.toYData(e) : e[r]; n[r + "Data"][t] = i } : function (e) { Array.prototype[t].apply(n[e + "Data"], Array.prototype.slice.call(r, 2)) }) }, autoIncrement: function () { var e = this.options, t = this.xIncrement, t = d(t, e.pointStart, 0); this.pointInterval = d(this.pointInterval, e.pointInterval, 1); this.xIncrement = t + this.pointInterval; return t }, getSegments: function () { var e = -1, t = [], n, r = this.points, i = r.length; if (i) if (this.options.connectNulls) { for (n = i; n--; ) r[n].y === null && r.splice(n, 1); r.length && (t = [r]) } else Kt(r, function (n, s) { n.y === null ? (s > e + 1 && t.push(r.slice(e + 1, s)), e = s) : s === i - 1 && t.push(r.slice(e + 1, s + 1)) }); this.segments = t }, setOptions: function (e) { var n = this.chart, r = n.options.plotOptions, n = n.userOptions || {}, i = n.plotOptions || {}, s = r[this.type]; this.userOptions = e; r = t(s, r.series, e); this.tooltipOptions = t(yt.tooltip, yt.plotOptions[this.type].tooltip, n.tooltip, i.series && i.series.tooltip, i[this.type] && i[this.type].tooltip, e.tooltip); s.marker === null && delete r.marker; return r }, getColor: function () { var e = this.options, t = this.userOptions, n = this.chart.options.colors, r = this.chart.counters, i; i = e.color || on[this.type].color; if (!i && !e.colorByPoint) c(t._colorIndex) ? e = t._colorIndex : (t._colorIndex = r.color, e = r.color++), i = n[e]; this.color = i; r.wrapColor(n.length) }, getSymbol: function () { var e = this.userOptions, t = this.options.marker, n = this.chart, r = n.options.symbols, n = n.counters; this.symbol = t.symbol; if (!this.symbol) c(e._symbolIndex) ? e = e._symbolIndex : (e._symbolIndex = n.symbol, e = n.symbol++), this.symbol = r[e]; if (/^url/.test(this.symbol)) t.radius = 0; n.wrapSymbol(r.length) }, drawLegendSymbol: Xt.drawLineMarker, setData: function (e, t) { var n = this, r = n.points, s = n.options, a = n.chart, f = null, l = n.xAxis, c = l && !!l.categories, h; n.xIncrement = null; n.pointRange = c ? 1 : s.pointRange; n.colorCounter = 0; var e = e || [], p = e.length; h = s.turboThreshold; var v = this.xData, m = this.yData, g = n.pointArrayMap, g = g && g.length; Kt(this.parallelArrays, function (e) { n[e + "Data"].length = 0 }); if (h && p > h) { for (h = 0; f === null && h < p; ) f = e[h], h++; if (u(f)) { c = d(s.pointStart, 0); s = d(s.pointInterval, 1); for (h = 0; h < p; h++) v[h] = c, m[h] = e[h], c += s; n.xIncrement = c } else if (o(f)) if (g) for (h = 0; h < p; h++) s = e[h], v[h] = s[0], m[h] = s.slice(1, g + 1); else for (h = 0; h < p; h++) s = e[h], v[h] = s[0], m[h] = s[1]; else O(12) } else for (h = 0; h < p; h++) if (e[h] !== U && (s = { series: n }, n.pointClass.prototype.applyOptions.apply(s, [e[h]]), n.updateParallelArrays(s, h), c && s.name)) l.names[s.x] = s.name; i(m[0]) && O(14, !0); n.data = []; n.options.data = e; for (h = r && r.length || 0; h--; ) r[h] && r[h].destroy && r[h].destroy(); if (l) l.minRange = l.userMinRange; n.isDirty = n.isDirtyData = a.isDirtyBox = !0; d(t, !0) && a.redraw(!1) }, processData: function (e) { var t = this.xData, n = this.yData, r = t.length, i; i = 0; var s, o, u = this.xAxis, a = this.options, f = a.cropThreshold, l = this.isCartesian; if (l && !this.isDirty && !u.isDirty && !this.yAxis.isDirty && !e) return !1; if (l && this.sorted && (!f || r > f || this.forceCrop)) if (e = u.min, u = u.max, t[r - 1] < e || t[0] > u) t = [], n = []; else if (t[0] < e || t[r - 1] > u) i = this.cropData(this.xData, this.yData, e, u), t = i.xData, n = i.yData, i = i.start, s = !0; for (u = t.length - 1; u >= 0; u--) r = t[u] - t[u - 1], r > 0 && (o === U || r < o) ? o = r : r < 0 && this.requireSorting && O(15); this.cropped = s; this.cropStart = i; this.processedXData = t; this.processedYData = n; if (a.pointRange === null) this.pointRange = o || 1; this.closestPointRange = o }, cropData: function (e, t, n, r) { var i = e.length, s = 0, o = i, u = d(this.cropShoulder, 1), a; for (a = 0; a < i; a++) if (e[a] >= n) { s = K(0, a - u); break } for (; a < i; a++) if (e[a] > r) { o = a + u; break } return { xData: e.slice(s, o), yData: t.slice(s, o), start: s, end: o} }, generatePoints: function () { var e = this.options.data, t = this.data, n, r = this.processedXData, i = this.processedYData, s = this.pointClass, o = r.length, u = this.cropStart || 0, a, f = this.hasGroupedData, l, c = [], h; if (!t && !f) t = [], t.length = e.length, t = this.data = t; for (h = 0; h < o; h++) a = u + h, f ? c[h] = (new s).init(this, [r[h]].concat(p(i[h]))) : (t[a] ? l = t[a] : e[a] !== U && (t[a] = l = (new s).init(this, e[a], r[h])), c[h] = l); if (t && (o !== (n = t.length) || f)) for (h = 0; h < n; h++) if (h === u && !f && (h += o), t[h]) t[h].destroyElements(), t[h].plotX = U; this.data = t; this.points = c }, setStackedPoints: function () { if (this.options.stacking && !(this.visible !== !0 && this.chart.options.chart.ignoreHiddenSeries !== !1)) { var e = this.processedXData, t = this.processedYData, n = [], r = t.length, i = this.options, s = i.threshold, o = i.stack, i = i.stacking, u = this.stackKey, a = "-" + u, f = this.negStacks, l = this.yAxis, c = l.stacks, h = l.oldStacks, p, d, v, m, g; for (v = 0; v < r; v++) { m = e[v]; g = t[v]; d = (p = f && g < s) ? a : u; c[d] || (c[d] = {}); if (!c[d][m]) h[d] && h[d][m] ? (c[d][m] = h[d][m], c[d][m].total = null) : c[d][m] = new B(l, l.options.stackLabels, p, m, o, i); d = c[d][m]; d.points[this.index] = [d.cum || 0]; i === "percent" ? (p = p ? u : a, f && c[p] && c[p][m] ? (p = c[p][m], d.total = p.total = K(p.total, d.total) + G(g) || 0) : d.total += G(g) || 0) : d.total += g || 0; d.cum = (d.cum || 0) + (g || 0); d.points[this.index].push(d.cum); n[v] = d.cum } if (i === "percent") l.usePercentage = !0; this.stackedYData = n; l.oldStacks = {} } }, setPercentStacks: function () { var e = this, t = e.stackKey, n = e.yAxis.stacks; Kt([t, "-" + t], function (t) { var r; for (var i = e.xData.length, s, o; i--; ) if (s = e.xData[i], r = (o = n[t] && n[t][s]) && o.points[e.index], s = r) o = o.total ? 100 / o.total : 0, s[0] = M(s[0] * o), s[1] = M(s[1] * o), e.stackedYData[i] = s[1] }) }, getExtremes: function (e) { var t = this.yAxis, n = this.processedXData, r, i = [], s = 0; r = this.xAxis.getExtremes(); var o = r.min, u = r.max, a, f, l, c, e = e || this.stackedYData || this.processedYData; r = e.length; for (c = 0; c < r; c++) if (f = n[c], l = e[c], a = l !== null && l !== U && (!t.isLog || l.length || l > 0), f = this.getExtremesFromAll || this.cropped || (n[c + 1] || f) >= o && (n[c - 1] || f) <= u, a && f) if (a = l.length) for (; a--; ) l[a] !== null && (i[s++] = l[a]); else i[s++] = l; this.dataMin = d(void 0, C(i)); this.dataMax = d(void 0, k(i)) }, translate: function () { this.processedXData || this.processData(); this.generatePoints(); for (var e = this.options, t = e.stacking, n = this.xAxis, r = n.categories, i = this.yAxis, s = this.points, o = s.length, a = !!this.modifyValue, f = e.pointPlacement, l = f === "between" || u(f), h = e.threshold, e = 0; e < o; e++) { var p = s[e], v = p.x, m = p.y, g = p.low, y = t && i.stacks[(this.negStacks && m < h ? "-" : "") + this.stackKey]; if (i.isLog && m <= 0) p.y = m = null; p.plotX = n.translate(v, 0, 0, 0, 1, f, this.type === "flags"); if (t && this.visible && y && y[v]) y = y[v], m = y.points[this.index], g = m[0], m = m[1], g === 0 && (g = d(h, i.min)), i.isLog && g <= 0 && (g = null), p.total = p.stackTotal = y.total, p.percentage = t === "percent" && p.y / y.total * 100, p.stackY = m, y.setOffset(this.pointXOffset || 0, this.barW || 0); p.yBottom = c(g) ? i.translate(g, 0, 1, 0, 1) : null; a && (m = this.modifyValue(m, p)); p.plotY = typeof m === "number" && m !== Infinity ? i.translate(m, 0, 1, 0, 1) : U; p.clientX = l ? n.translate(v, 0, 0, 0, 1) : p.plotX; p.negative = p.y < (h || 0); p.category = r && r[p.x] !== U ? r[p.x] : p.x } this.getSegments() }, setTooltipPoints: function (e) { var t = [], n, r, i = this.xAxis, s = i && i.getExtremes(), o = i ? i.tooltipLen || i.len : this.chart.plotSizeX, u, a, f = []; if (this.options.enableMouseTracking !== !1) { if (e) this.tooltipPoints = null; Kt(this.segments || this.points, function (e) { t = t.concat(e) }); i && i.reversed && (t = t.reverse()); this.orderTooltipPoints && this.orderTooltipPoints(t); e = t.length; for (a = 0; a < e; a++) if (i = t[a], n = i.x, n >= s.min && n <= s.max) { u = t[a + 1]; n = r === U ? 0 : r + 1; for (r = t[a + 1] ? Q(K(0, $((i.clientX + (u ? u.wrappedClientX || u.clientX : o)) / 2)), o) : o; n >= 0 && n <= r; ) f[n++] = i } this.tooltipPoints = f } }, tooltipHeaderFormatter: function (e) { var t = this.tooltipOptions, n = t.dateTimeLabelFormats, r = t.xDateFormat || n.year, i = this.xAxis, s = i && i.options.type === "datetime", t = t.headerFormat, i = i && i.closestPointRange, o; if (s && !r) if (i) for (o in St) { if (St[o] >= i) { r = n[o]; break } } else r = n.day; s && r && u(e.key) && (t = t.replace("{point.key}", "{point.key:" + r + "}")); return E(t, { point: e, series: this }) }, onMouseOver: function () { var e = this.chart, t = e.hoverSeries; if (t && t !== this) t.onMouseOut(); this.options.events.mouseOver && tn(this, "mouseOver"); this.setState("hover"); e.hoverSeries = this }, onMouseOut: function () { var e = this.options, t = this.chart, n = t.tooltip, r = t.hoverPoint; if (r) r.onMouseOut(); this && e.events.mouseOut && tn(this, "mouseOut"); n && !e.stickyTracking && (!n.shared || this.noSharedTooltip) && n.hide(); this.setState(); t.hoverSeries = null }, animate: function (t) { var n = this, r = n.chart, i = r.renderer, o; o = n.options.animation; var u = r.clipBox, a = r.inverted, f; if (o && !s(o)) o = on[n.type].animation; f = "_sharedClip" + o.duration + o.easing; if (t) t = r[f], o = r[f + "m"], t || (r[f] = t = i.clipRect(e(u, { width: 0 })), r[f + "m"] = o = i.clipRect(-99, a ? -r.plotLeft : -r.plotTop, 99, a ? r.chartWidth : r.chartHeight)), n.group.clip(t), n.markerGroup.clip(o), n.sharedClipKey = f; else { if (t = r[f]) t.animate({ width: r.plotSizeX }, o), r[f + "m"].animate({ width: r.plotSizeX + 99 }, o); n.animate = null; n.animationTimeout = setTimeout(function () { n.afterAnimate() }, o.duration) } }, afterAnimate: function () { var e = this.chart, t = this.sharedClipKey, n = this.group; n && this.options.clip !== !1 && (n.clip(e.clipRect), this.markerGroup.clip()); setTimeout(function () { t && e[t] && (e[t] = e[t].destroy(), e[t + "m"] = e[t + "m"].destroy()) }, 100) }, drawPoints: function () { var t, n = this.points, r = this.chart, i, s, o, u, a, f, l, c, h = this.options.marker, p = this.pointAttr[""], v, m = this.markerGroup; if (h.enabled || this._hasPointMarkers) for (o = n.length; o--; ) if (u = n[o], i = $(u.plotX), s = u.plotY, c = u.graphic, f = u.marker || {}, t = h.enabled && f.enabled === U || f.enabled, v = r.isInsidePlot(V(i), s, r.inverted), t && s !== U && !isNaN(s) && u.y !== null) if (t = u.pointAttr[u.selected ? "select" : ""] || p, a = t.r, f = d(f.symbol, this.symbol), l = f.indexOf("url") === 0, c) c.attr({ visibility: v ? lt ? "inherit" : "visible" : "hidden" }).animate(e({ x: i - a, y: s - a }, c.symbolName ? { width: 2 * a, height: 2 * a} : {})); else { if (v && (a > 0 || l)) u.graphic = r.renderer.symbol(f, i - a, s - a, 2 * a, 2 * a).attr(t).add(m) } else if (c) u.graphic = c.destroy() }, convertAttribs: function (e, t, n, r) { var i = this.pointAttrToOptions, s, o, u = {}, e = e || {}, t = t || {}, n = n || {}, r = r || {}; for (s in i) o = i[s], u[s] = d(e[o], t[s], n[s], r[s]); return u }, getAttribs: function () { var t = this, n = t.options, r = on[t.type].marker ? n.marker : n, i = r.states, s = i.hover, o, u = t.color; o = { stroke: u, fill: u }; var a = t.points || [], f, l = [], h, p = t.pointAttrToOptions; f = n.turboThreshold; var d = n.negativeColor, v = r.lineColor, m; n.marker ? (s.radius = s.radius || r.radius + 2, s.lineWidth = s.lineWidth || r.lineWidth + 1) : s.color = s.color || ln(s.color || u).brighten(s.brightness).get(); l[""] = t.convertAttribs(r, o); Kt(["hover", "select"], function (e) { l[e] = t.convertAttribs(i[e], l[""]) }); t.pointAttr = l; u = a.length; if (!f || u < f) for (; u--; ) { f = a[u]; if ((r = f.options && f.options.marker || f.options) && r.enabled === !1) r.radius = 0; if (f.negative && d) f.color = f.fillColor = d; o = n.colorByPoint || f.color; if (f.options) for (m in p) c(r[p[m]]) && (o = !0); if (o) { r = r || {}; h = []; i = r.states || {}; o = i.hover = i.hover || {}; if (!n.marker) o.color = o.color || s.color || ln(f.color).brighten(o.brightness || s.brightness).get(); h[""] = t.convertAttribs(e({ color: f.color, fillColor: f.color, lineColor: v === null ? f.color : U }, r), l[""]); h.hover = t.convertAttribs(i.hover, l.hover, h[""]); h.select = t.convertAttribs(i.select, l.select, h[""]) } else h = l; f.pointAttr = h } }, destroy: function () { var e = this, t = e.chart, n = /AppleWebKit\/533/.test(nt), r, i, s = e.data || [], o, u, a; tn(e, "destroy"); en(e); Kt(e.axisTypes || [], function (t) { if (a = e[t]) l(a.series, e), a.isDirty = a.forceRedraw = !0 }); e.legendItem && e.chart.legend.destroyItem(e); for (i = s.length; i--; ) (o = s[i]) && o.destroy && o.destroy(); e.points = null; clearTimeout(e.animationTimeout); Kt("area,graph,dataLabelsGroup,group,markerGroup,tracker,graphNeg,areaNeg,posClip,negClip".split(","), function (t) { e[t] && (r = n && t === "group" ? "hide" : "destroy", e[t][r]()) }); if (t.hoverSeries === e) t.hoverSeries = null; l(t.series, e); for (u in e) delete e[u] }, getSegmentPath: function (e) { var t = this, n = [], r = t.options.step; Kt(e, function (i, s) { var o = i.plotX, u = i.plotY, a; t.getPointSpline ? n.push.apply(n, t.getPointSpline(e, i, s)) : (n.push(s ? "L" : "M"), r && s && (a = e[s - 1], r === "right" ? n.push(a.plotX, u) : r === "center" ? n.push((a.plotX + o) / 2, a.plotY, (a.plotX + o) / 2, u) : n.push(o, a.plotY)), n.push(i.plotX, i.plotY)) }); return n }, getGraphPath: function () { var e = this, t = [], n, r = []; Kt(e.segments, function (i) { n = e.getSegmentPath(i); i.length > 1 ? t = t.concat(n) : r.push(i[0]) }); e.singlePoints = r; return e.graphPath = t }, drawGraph: function () { var e = this, t = this.options, n = [["graph", t.lineColor || this.color]], r = t.lineWidth, i = t.dashStyle, s = t.linecap !== "square", o = this.getGraphPath(), u = t.negativeColor; u && n.push(["graphNeg", u]); Kt(n, function (n, u) { var a = n[0], f = e[a]; if (f) sn(f), f.animate({ d: o }); else if (r && o.length) f = { stroke: n[1], "stroke-width": r, zIndex: 1 }, i ? f.dashstyle = i : s && (f["stroke-linecap"] = f["stroke-linejoin"] = "round"), e[a] = e.chart.renderer.path(o).attr(f).add(e.group).shadow(!u && t.shadow) }) }, clipNeg: function () { var e = this.options, t = this.chart, n = t.renderer, r = e.negativeColor || e.negativeFillColor, i, s = this.graph, o = this.area, u = this.posClip, a = this.negClip; i = t.chartWidth; var f = t.chartHeight, l = K(i, f), c = this.yAxis; if (r && (s || o)) { r = V(c.toPixels(e.threshold || 0, !0)); r < 0 && (l -= r); e = { x: 0, y: 0, width: l, height: r }; l = { x: 0, y: r, width: l, height: l }; if (t.inverted) e.height = l.y = t.plotWidth - r, n.isVML && (e = { x: t.plotWidth - r - t.plotLeft, y: 0, width: i, height: f }, l = { x: r + t.plotLeft - i, y: 0, width: t.plotLeft + r, height: i }); c.reversed ? (t = l, i = e) : (t = e, i = l); u ? (u.animate(t), a.animate(i)) : (this.posClip = u = n.clipRect(t), this.negClip = a = n.clipRect(i), s && this.graphNeg && (s.clip(u), this.graphNeg.clip(a)), o && (o.clip(u), this.areaNeg.clip(a))) } }, invertGroups: function () { function e() { var e = { width: t.yAxis.len, height: t.xAxis.len }; Kt(["group", "markerGroup"], function (n) { t[n] && t[n].attr(e).invert() }) } var t = this, n = t.chart; if (t.xAxis) Zt(n, "resize", e), Zt(t, "destroy", function () { en(n, "resize", e) }), e(), t.invertGroups = e }, plotGroup: function (e, t, n, r, i) { var s = this[e], o = !s; o && (this[e] = s = this.chart.renderer.g(t).attr({ visibility: n, zIndex: r || .1 }).add(i)); s[o ? "attr" : "animate"](this.getPlotBox()); return s }, getPlotBox: function () { return { translateX: this.xAxis ? this.xAxis.left : this.chart.plotLeft, translateY: this.yAxis ? this.yAxis.top : this.chart.plotTop, scaleX: 1, scaleY: 1} }, render: function () { var e = this.chart, t, n = this.options, r = n.animation && !!this.animate && e.renderer.isSVG, i = this.visible ? "visible" : "hidden", s = n.zIndex, o = this.hasRendered, u = e.seriesGroup; t = this.plotGroup("group", "series", i, s, u); this.markerGroup = this.plotGroup("markerGroup", "markers", i, s, u); r && this.animate(!0); this.getAttribs(); t.inverted = this.isCartesian ? e.inverted : !1; this.drawGraph && (this.drawGraph(), this.clipNeg()); this.drawDataLabels && this.drawDataLabels(); this.visible && this.drawPoints(); this.options.enableMouseTracking !== !1 && this.drawTracker(); e.inverted && this.invertGroups(); n.clip !== !1 && !this.sharedClipKey && !o && t.clip(e.clipRect); r ? this.animate() : o || this.afterAnimate(); this.isDirty = this.isDirtyData = !1; this.hasRendered = !0 }, redraw: function () { var e = this.chart, t = this.isDirtyData, n = this.group, r = this.xAxis, i = this.yAxis; n && (e.inverted && n.attr({ width: e.plotWidth, height: e.plotHeight }), n.animate({ translateX: d(r && r.left, e.plotLeft), translateY: d(i && i.top, e.plotTop) })); this.translate(); this.setTooltipPoints(!0); this.render(); t && tn(this, "updatedData") }, setState: function (e) { var t = this.options, n = this.graph, r = this.graphNeg, i = t.states, t = t.lineWidth, e = e || ""; if (this.state !== e) this.state = e, i[e] && i[e].enabled === !1 || (e && (t = i[e].lineWidth || t + 1), n && !n.dashstyle && (e = { "stroke-width": t }, n.attr(e), r && r.attr(e))) }, setVisible: function (e, t) { var n = this, r = n.chart, i = n.legendItem, s, o = r.options.chart.ignoreHiddenSeries, u = n.visible; s = (n.visible = e = n.userOptions.visible = e === U ? !u : e) ? "show" : "hide"; Kt(["group", "dataLabelsGroup", "markerGroup", "tracker"], function (e) { if (n[e]) n[e][s]() }); if (r.hoverSeries === n) n.onMouseOut(); i && r.legend.colorizeItem(n, e); n.isDirty = !0; n.options.stacking && Kt(r.series, function (e) { if (e.options.stacking && e.visible) e.isDirty = !0 }); Kt(n.linkedSeries, function (t) { t.setVisible(e, !1) }); if (o) r.isDirtyBox = !0; t !== !1 && r.redraw(); tn(n, s) }, show: function () { this.setVisible(!0) }, hide: function () { this.setVisible(!1) }, select: function (e) { this.selected = e = e === U ? !this.selected : e; if (this.checkbox) this.checkbox.checked = e; tn(this, e ? "select" : "unselect") }, drawTracker: gn.drawTrackerGraph }; e(I.prototype, { addSeries: function (e, t, n) { var r, i = this; e && (t = d(t, !0), tn(i, "addSeries", { options: e }, function () { r = i.initSeries(e); i.isDirtyLegend = !0; i.linkSeries(); t && i.redraw(n) })); return r }, addAxis: function (e, n, r, i) { var s = n ? "xAxis" : "yAxis", o = this.options; new j(this, t(e, { index: this[s].length, isX: n })); o[s] = p(o[s] || {}); o[s].push(e); d(r, !0) && this.redraw(i) }, showLoading: function (t) { var n = this.options, r = this.loadingDiv, i = n.loading; if (!r) this.loadingDiv = r = m(Nt, { className: "highcharts-loading" }, e(i.style, { zIndex: 10, display: Ct }), this.container), this.loadingSpan = m("span", null, i.labelStyle, r); this.loadingSpan.innerHTML = t || n.lang.loading; if (!this.loadingShown) v(r, { opacity: 0, display: "", left: this.plotLeft + "px", top: this.plotTop + "px", width: this.plotWidth + "px", height: this.plotHeight + "px" }), rn(r, { opacity: i.style.opacity }, { duration: i.showDuration || 0 }), this.loadingShown = !0 }, hideLoading: function () { var e = this.options, t = this.loadingDiv; t && rn(t, { opacity: 0 }, { duration: e.loading.hideDuration || 100, complete: function () { v(t, { display: Ct }) } }); this.loadingShown = !1 } }); e(wn.prototype, { update: function (e, t, n) { var r = this, i = r.series, o = r.graphic, u, a = i.data, f = i.chart, l = i.options, t = d(t, !0); r.firePointEvent("update", { options: e }, function () { r.applyOptions(e); if (s(e)) { i.getAttribs(); if (o) e && e.marker && e.marker.symbol ? r.graphic = o.destroy() : o.attr(r.pointAttr[r.state || ""]); if (e && e.dataLabels && r.dataLabel) r.dataLabel = r.dataLabel.destroy() } u = Jt(r, a); i.updateParallelArrays(r, u); l.data[u] = r.options; i.isDirty = i.isDirtyData = !0; if (!i.fixedBox && i.hasCartesianSeries) f.isDirtyBox = !0; l.legendType === "point" && f.legend.destroyItem(r); t && f.redraw(n) }) }, remove: function (e, t) { var n = this, r = n.series, i = r.points, s = r.chart, o, u = r.data; _(t, s); e = d(e, !0); n.firePointEvent("remove", null, function () { o = Jt(n, u); u.length === i.length && i.splice(o, 1); u.splice(o, 1); r.options.data.splice(o, 1); r.updateParallelArrays(n, "splice", o, 1); n.destroy(); r.isDirty = !0; r.isDirtyData = !0; e && s.redraw() }) } }); e(En.prototype, { addPoint: function (e, t, n, r) { var i = this.options, s = this.data, o = this.graph, u = this.area, a = this.chart, f = this.xAxis && this.xAxis.names, l = o && o.shift || 0, c = i.data, h, p = this.xData; _(r, a); n && Kt([o, u, this.graphNeg, this.areaNeg], function (e) { if (e) e.shift = l + 1 }); if (u) u.isArea = !0; t = d(t, !0); r = { series: this }; this.pointClass.prototype.applyOptions.apply(r, [e]); o = r.x; u = p.length; if (this.requireSorting && o < p[u - 1]) for (h = !0; u && p[u - 1] > o; ) u--; this.updateParallelArrays(r, "splice", u); this.updateParallelArrays(r, u); if (f) f[o] = r.name; c.splice(u, 0, e); h && (this.data.splice(u, 0, null), this.processData()); i.legendType === "point" && this.generatePoints(); n && (s[0] && s[0].remove ? s[0].remove(!1) : (s.shift(), this.updateParallelArrays(r, "shift"), c.shift())); this.isDirtyData = this.isDirty = !0; t && (this.getAttribs(), a.redraw()) }, remove: function (e, t) { var n = this, r = n.chart, e = d(e, !0); if (!n.isRemoving) n.isRemoving = !0, tn(n, "remove", null, function () { n.destroy(); r.isDirtyLegend = r.isDirtyBox = !0; r.linkSeries(); e && r.redraw(t) }); n.isRemoving = !1 }, update: function (n, r) { var i = this.chart, s = this.type, o = zt[s].prototype, u, n = t(this.userOptions, { animation: !1, index: this.index, pointStart: this.xData[0] }, { data: this.options.data }, n); this.remove(!1); for (u in o) o.hasOwnProperty(u) && (this[u] = U); e(this, zt[n.type || s].prototype); this.init(i, n); d(r, !0) && i.redraw(!1) } }); e(j.prototype, { update: function (n, r) { var i = this.chart, n = i.options[this.coll][this.options.index] = t(this.userOptions, n); this.destroy(!0); this._addedPlotLB = this.userMin = this.userMax = U; this.init(i, e(n, { events: U })); i.isDirtyBox = !0; d(r, !0) && i.redraw() }, remove: function (e) { var t = this.chart, n = this.coll; Kt(this.series, function (e) { e.remove(!1) }); l(t.axes, this); l(t[n], this); t.options[n].splice(this.options.index, 1); Kt(t[n], function (e, t) { e.options.index = t }); this.destroy(); t.isDirtyBox = !0; d(e, !0) && t.redraw() }, setTitle: function (e, t) { this.update({ title: e }, t) }, setCategories: function (e, t) { this.update({ categories: e }, t) } }); var Sn = g(En); zt.line = Sn; on.area = t(Wt, { threshold: 0 }); var xn = g(En, { type: "area", getSegments: function () { var e = [], t = [], n = [], r = this.xAxis, i = this.yAxis, s = i.stacks[this.stackKey], o = {}, u, a, f = this.points, l = this.options.connectNulls, c, h, p; if (this.options.stacking && !this.cropped) { for (h = 0; h < f.length; h++) o[f[h].x] = f[h]; for (p in s) s[p].total !== null && n.push(+p); n.sort(function (e, t) { return e - t }); Kt(n, function (e) { if (!l || o[e] && o[e].y !== null) o[e] ? t.push(o[e]) : (u = r.translate(e), c = s[e].percent ? s[e].total ? s[e].cum * 100 / s[e].total : 0 : s[e].cum, a = i.toPixels(c, !0), t.push({ y: null, plotX: u, clientX: u, plotY: a, yBottom: a, onMouseOver: xt })) }); t.length && e.push(t) } else En.prototype.getSegments.call(this), e = this.segments; this.segments = e }, getSegmentPath: function (e) { var t = En.prototype.getSegmentPath.call(this, e), n = [].concat(t), r, i = this.options; r = t.length; var s = this.yAxis.getThreshold(i.threshold), o; r === 3 && n.push("L", t[1], t[2]); if (i.stacking && !this.closedStacks) for (r = e.length - 1; r >= 0; r--) o = d(e[r].yBottom, s), r < e.length - 1 && i.step && n.push(e[r + 1].plotX, o), n.push(e[r].plotX, o); else this.closeSegment(n, e, s); this.areaPath = this.areaPath.concat(n); return t }, closeSegment: function (e, t, n) { e.push("L", t[t.length - 1].plotX, n, "L", t[0].plotX, n) }, drawGraph: function () { this.areaPath = []; En.prototype.drawGraph.apply(this); var e = this, t = this.areaPath, n = this.options, r = n.negativeColor, i = n.negativeFillColor, s = [["area", this.color, n.fillColor]]; (r || i) && s.push(["areaNeg", r, i]); Kt(s, function (r) { var i = r[0], s = e[i]; s ? s.animate({ d: t }) : e[i] = e.chart.renderer.path(t).attr({ fill: d(r[2], ln(r[1]).setOpacity(d(n.fillOpacity, .75)).get()), zIndex: 0 }).add(e.group) }) }, drawLegendSymbol: Xt.drawRectangle }); zt.area = xn; on.spline = t(Wt); Sn = g(En, { type: "spline", getPointSpline: function (e, t, n) { var r = t.plotX, i = t.plotY, s = e[n - 1], o = e[n + 1], u, a, f, l; if (s && o) { e = s.plotY; f = o.plotX; var o = o.plotY, c; u = (1.5 * r + s.plotX) / 2.5; a = (1.5 * i + e) / 2.5; f = (1.5 * r + f) / 2.5; l = (1.5 * i + o) / 2.5; c = (l - a) * (f - r) / (f - u) + i - l; a += c; l += c; a > e && a > i ? (a = K(e, i), l = 2 * i - a) : a < e && a < i && (a = Q(e, i), l = 2 * i - a); l > o && l > i ? (l = K(o, i), a = 2 * i - l) : l < o && l < i && (l = Q(o, i), a = 2 * i - l); t.rightContX = f; t.rightContY = l } n ? (t = ["C", s.rightContX || s.plotX, s.rightContY || s.plotY, u || r, a || i, r, i], s.rightContX = s.rightContY = null) : t = ["M", r, i]; return t } }); zt.spline = Sn; on.areaspline = t(on.area); xn = xn.prototype; Sn = g(Sn, { type: "areaspline", closedStacks: !0, getSegmentPath: xn.getSegmentPath, closeSegment: xn.closeSegment, drawGraph: xn.drawGraph, drawLegendSymbol: Xt.drawRectangle }); zt.areaspline = Sn; on.column = t(Wt, { borderColor: "#FFFFFF", borderWidth: 1, borderRadius: 0, groupPadding: .2, marker: null, pointPadding: .1, minPointLength: 0, cropThreshold: 50, pointRange: null, states: { hover: { brightness: .1, shadow: !1 }, select: { color: "#C0C0C0", borderColor: "#000000", shadow: !1} }, dataLabels: { align: null, verticalAlign: null, y: null }, stickyTracking: !1, threshold: 0 }); Sn = g(En, { type: "column", pointAttrToOptions: { stroke: "borderColor", "stroke-width": "borderWidth", fill: "color", r: "borderRadius" }, cropShoulder: 0, trackerGroups: ["group", "dataLabelsGroup"], negStacks: !0, init: function () { En.prototype.init.apply(this, arguments); var e = this, t = e.chart; t.hasRendered && Kt(t.series, function (t) { if (t.type === e.type) t.isDirty = !0 }) }, getColumnMetrics: function () { var e = this, t = e.options, n = e.xAxis, r = e.yAxis, i = n.reversed, s, o = {}, u, a = 0; t.grouping === !1 ? a = 1 : Kt(e.chart.series, function (t) { var n = t.options, i = t.yAxis; if (t.type === e.type && t.visible && r.len === i.len && r.pos === i.pos) n.stacking ? (s = t.stackKey, o[s] === U && (o[s] = a++), u = o[s]) : n.grouping !== !1 && (u = a++), t.columnIndex = u }); var n = Q(G(n.transA) * (n.ordinalSlope || t.pointRange || n.closestPointRange || 1), n.len), f = n * t.groupPadding, l = (n - 2 * f) / a, h = t.pointWidth, t = c(h) ? (l - h) / 2 : l * t.pointPadding, h = d(h, l - 2 * t); return e.columnMetrics = { width: h, offset: t + (f + ((i ? a - (e.columnIndex || 0) : e.columnIndex) || 0) * l - n / 2) * (i ? -1 : 1)} }, translate: function () { var e = this.chart, t = this.options, n = t.borderWidth, r = this.yAxis, i = this.translatedThreshold = r.getThreshold(t.threshold), s = d(t.minPointLength, 5), t = this.getColumnMetrics(), o = t.width, u = this.barW = J(K(o, 1 + 2 * n)), a = this.pointXOffset = t.offset, f = -(n % 2 ? .5 : 0), l = n % 2 ? .5 : 1; e.renderer.isVML && e.inverted && (l += 1); En.prototype.translate.apply(this); Kt(this.points, function (e) { var t = d(e.yBottom, i), n = Q(K(-999 - t, e.plotY), r.len + 999 + t), c = e.plotX + a, h = u, p = Q(n, t), v, n = K(n, t) - p; G(n) < s && s && (n = s, p = V(G(p - i) > s ? t - s : i - (r.translate(e.y, 0, 1, 0, 1) <= i ? s : 0))); e.barX = c; e.pointWidth = o; t = G(c) < .5; h = V(c + h) + f; c = V(c) + f; h -= c; v = G(p) < .5; n = V(p + n) + l; p = V(p) + l; n -= p; t && (c += 1, h -= 1); v && (p -= 1, n += 1); e.shapeType = "rect"; e.shapeArgs = { x: c, y: p, width: h, height: n} }) }, getSymbol: xt, drawLegendSymbol: Xt.drawRectangle, drawGraph: xt, drawPoints: function () { var e = this, n = this.chart, r = e.options, i = n.renderer, s = n.options.animationLimit || 250, o; Kt(e.points, function (u) { var a = u.plotY, f = u.graphic; if (a !== U && !isNaN(a) && u.y !== null) o = u.shapeArgs, f ? (sn(f), f[n.pointCount < s ? "animate" : "attr"](t(o))) : u.graphic = i[u.shapeType](o).attr(u.pointAttr[u.selected ? "select" : ""]).add(e.group).shadow(r.shadow, null, r.stacking && !r.borderRadius); else if (f) u.graphic = f.destroy() }) }, drawTracker: gn.drawTrackerPoint, animate: function (e) { var t = this.yAxis, n = this.options, r = this.chart.inverted, i = {}; if (lt) e ? (i.scaleY = .001, e = Q(t.pos + t.len, K(t.pos, t.toPixels(n.threshold))), r ? i.translateX = e - t.len : i.translateY = e, this.group.attr(i)) : (i.scaleY = 1, i[r ? "translateX" : "translateY"] = t.pos, this.group.animate(i, this.options.animation), this.animate = null) }, remove: function () { var e = this, t = e.chart; t.hasRendered && Kt(t.series, function (t) { if (t.type === e.type) t.isDirty = !0 }); En.prototype.remove.apply(e, arguments) } }); zt.column = Sn; on.bar = t(on.column); Sn = g(Sn, { type: "bar", inverted: !0 }); zt.bar = Sn; on.scatter = t(Wt, { lineWidth: 0, tooltip: { headerFormat: '<span style="font-size: 10px; color:{series.color}">{series.name}</span><br/>', pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>", followPointer: !0 }, stickyTracking: !1 }); Sn = g(En, { type: "scatter", sorted: !1, requireSorting: !1, noSharedTooltip: !0, trackerGroups: ["markerGroup"], takeOrdinalPosition: !1, drawTracker: gn.drawTrackerPoint, drawGraph: function () { this.options.lineWidth && En.prototype.drawGraph.call(this) }, setTooltipPoints: xt }); zt.scatter = Sn; on.pie = t(Wt, { borderColor: "#FFFFFF", borderWidth: 1, center: [null, null], clip: !1, colorByPoint: !0, dataLabels: { distance: 30, enabled: !0, formatter: function () { return this.point.name } }, ignoreHiddenPoint: !0, legendType: "point", marker: null, size: null, showInLegend: !1, slicedOffset: 10, states: { hover: { brightness: .1, shadow: !1} }, stickyTracking: !1, tooltip: { followPointer: !0} }); Wt = { type: "pie", isCartesian: !1, pointClass: g(wn, { init: function () { wn.prototype.init.apply(this, arguments); var t = this, n; if (t.y < 0) t.y = null; e(t, { visible: t.visible !== !1, name: d(t.name, "Slice") }); n = function (e) { t.slice(e.type === "select") }; Zt(t, "select", n); Zt(t, "unselect", n); return t }, setVisible: function (e) { var t = this, n = t.series, r = n.chart, i; t.visible = t.options.visible = e = e === U ? !t.visible : e; n.options.data[Jt(t, n.data)] = t.options; i = e ? "show" : "hide"; Kt(["graphic", "dataLabel", "connector", "shadowGroup"], function (e) { if (t[e]) t[e][i]() }); t.legendItem && r.legend.colorizeItem(t, e); if (!n.isDirty && n.options.ignoreHiddenPoint) n.isDirty = !0, r.redraw() }, slice: function (e, t, n) { var r = this.series; _(n, r.chart); d(t, !0); this.sliced = this.options.sliced = e = c(e) ? e : !this.sliced; r.options.data[Jt(this, r.data)] = this.options; e = e ? this.slicedTranslation : { translateX: 0, translateY: 0 }; this.graphic.animate(e); this.shadowGroup && this.shadowGroup.animate(e) } }), requireSorting: !1, noSharedTooltip: !0, trackerGroups: ["group", "dataLabelsGroup"], axisTypes: [], pointAttrToOptions: { stroke: "borderColor", "stroke-width": "borderWidth", fill: "color" }, getColor: xt, animate: function (e) { var t = this, n = t.points, r = t.startAngleRad; if (!e) Kt(n, function (e) { var n = e.graphic, e = e.shapeArgs; n && (n.attr({ r: t.center[3] / 2, start: r, end: r }), n.animate({ r: e.r, start: e.start, end: e.end }, t.options.animation)) }), t.animate = null }, setData: function (e, t) { En.prototype.setData.call(this, e, !1); this.processData(); this.generatePoints(); d(t, !0) && this.chart.redraw() }, generatePoints: function () { var e, t = 0, n, r, i, s = this.options.ignoreHiddenPoint; En.prototype.generatePoints.call(this); n = this.points; r = n.length; for (e = 0; e < r; e++) i = n[e], t += s && !i.visible ? 0 : i.y; this.total = t; for (e = 0; e < r; e++) i = n[e], i.percentage = t > 0 ? i.y / t * 100 : 0, i.total = t }, translate: function (e) { this.generatePoints(); var t = 0, n = this.options, r = n.slicedOffset, i = r + n.borderWidth, s, o, u, a = n.startAngle || 0, f = this.startAngleRad = et / 180 * (a - 90), a = (this.endAngleRad = et / 180 * ((n.endAngle || a + 360) - 90)) - f, l = this.points, c = n.dataLabels.distance, n = n.ignoreHiddenPoint, h, p = l.length, d; if (!e) this.center = e = this.getCenter(); this.getX = function (t, n) { u = X.asin((t - e[1]) / (e[2] / 2 + c)); return e[0] + (n ? -1 : 1) * Y(u) * (e[2] / 2 + c) }; for (h = 0; h < p; h++) { d = l[h]; s = f + t * a; if (!n || d.visible) t += d.percentage / 100; o = f + t * a; d.shapeType = "arc"; d.shapeArgs = { x: e[0], y: e[1], r: e[2] / 2, innerR: e[3] / 2, start: V(s * 1e3) / 1e3, end: V(o * 1e3) / 1e3 }; u = (o + s) / 2; u > .75 * a && (u -= 2 * et); d.slicedTranslation = { translateX: V(Y(u) * r), translateY: V(Z(u) * r) }; s = Y(u) * e[2] / 2; o = Z(u) * e[2] / 2; d.tooltipPos = [e[0] + s * .7, e[1] + o * .7]; d.half = u < -et / 2 || u > et / 2 ? 1 : 0; d.angle = u; i = Q(i, c / 2); d.labelPos = [e[0] + s + Y(u) * c, e[1] + o + Z(u) * c, e[0] + s + Y(u) * i, e[1] + o + Z(u) * i, e[0] + s, e[1] + o, c < 0 ? "center" : d.half ? "right" : "left", u] } }, setTooltipPoints: xt, drawGraph: null, drawPoints: function () { var t = this, n = t.chart.renderer, r, i, s = t.options.shadow, o, u; if (s && !t.shadowGroup) t.shadowGroup = n.g("shadow").add(t.group); Kt(t.points, function (a) { i = a.graphic; u = a.shapeArgs; o = a.shadowGroup; if (s && !o) o = a.shadowGroup = n.g("shadow").add(t.shadowGroup); r = a.sliced ? a.slicedTranslation : { translateX: 0, translateY: 0 }; o && o.attr(r); i ? i.animate(e(u, r)) : a.graphic = i = n.arc(u).setRadialReference(t.center).attr(a.pointAttr[a.selected ? "select" : ""]).attr({ "stroke-linejoin": "round" }).attr(r).add(t.group).shadow(s, o); a.visible !== void 0 && a.setVisible(a.visible) }) }, sortByAngle: function (e, t) { e.sort(function (e, n) { return e.angle !== void 0 && (n.angle - e.angle) * t }) }, drawTracker: gn.drawTrackerPoint, drawLegendSymbol: Xt.drawRectangle, getCenter: pn.getCenter, getSymbol: xt }; Wt = g(En, Wt); zt.pie = Wt; En.prototype.drawDataLabels = function () { var n = this, r = n.options, i = r.cursor, s = r.dataLabels, r = n.points, o, u, a, f; if (s.enabled || n._hasPointLabels) n.dlProcessOptions && n.dlProcessOptions(s), f = n.plotGroup("dataLabelsGroup", "data-labels", n.visible ? "visible" : "hidden", s.zIndex || 6), u = s, Kt(r, function (r) { var l, h = r.dataLabel, p, v, m = r.connector, g = !0; o = r.options && r.options.dataLabels; l = d(o && o.enabled, u.enabled); if (h && !l) r.dataLabel = h.destroy(); else if (l) { s = t(u, o); l = s.rotation; p = r.getLabelConfig(); a = s.format ? E(s.format, p) : s.formatter.call(p, s); s.style.color = d(s.color, s.style.color, n.color, "black"); if (h) if (c(a)) h.attr({ text: a }), g = !1; else { if (r.dataLabel = h = h.destroy(), m) r.connector = m.destroy() } else if (c(a)) { h = { fill: s.backgroundColor, stroke: s.borderColor, "stroke-width": s.borderWidth, r: s.borderRadius || 0, rotation: l, padding: s.padding, zIndex: 1 }; for (v in h) h[v] === U && delete h[v]; h = r.dataLabel = n.chart.renderer[l ? "text" : "label"](a, 0, -999, null, null, null, s.useHTML).attr(h).css(e(s.style, i && { cursor: i })).add(f).shadow(s.shadow) } h && n.alignDataLabel(r, h, s, null, g) } }) }; En.prototype.alignDataLabel = function (t, n, r, i, s) { var o = this.chart, u = o.inverted, a = d(t.plotX, -999), f = d(t.plotY, -999), l = n.getBBox(); if (t = this.visible && (t.series.forceDL || o.isInsidePlot(t.plotX, t.plotY, u))) i = e({ x: u ? o.plotWidth - f : a, y: V(u ? o.plotHeight - a : f), width: 0, height: 0 }, i), e(r, { width: l.width, height: l.height }), r.rotation ? (u = { align: r.align, x: i.x + r.x + i.width / 2, y: i.y + r.y + i.height / 2 }, n[s ? "attr" : "animate"](u)) : (n.align(r, null, i), u = n.alignAttr, d(r.overflow, "justify") === "justify" ? this.justifyDataLabel(n, r, u, l, i, s) : d(r.crop, !0) && (t = o.isInsidePlot(u.x, u.y) && o.isInsidePlot(u.x + l.width, u.y + l.height))); if (!t) n.attr({ y: -999 }), n.placed = !1 }; En.prototype.justifyDataLabel = function (e, t, n, r, i, s) { var o = this.chart, u = t.align, a = t.verticalAlign, f, l; f = n.x; if (f < 0) u === "right" ? t.align = "left" : t.x = -f, l = !0; f = n.x + r.width; if (f > o.plotWidth) u === "left" ? t.align = "right" : t.x = o.plotWidth - f, l = !0; f = n.y; if (f < 0) a === "bottom" ? t.verticalAlign = "top" : t.y = -f, l = !0; f = n.y + r.height; if (f > o.plotHeight) a === "top" ? t.verticalAlign = "bottom" : t.y = o.plotHeight - f, l = !0; if (l) e.placed = !s, e.align(t, null, i) }; if (zt.pie) zt.pie.prototype.drawDataLabels = function () { var e = this, t = e.data, n, r = e.chart, i = e.options.dataLabels, s = d(i.connectorPadding, 10), o = d(i.connectorWidth, 1), u = r.plotWidth, r = r.plotHeight, a, f, l = d(i.softConnector, !0), c = i.distance, h = e.center, p = h[2] / 2, v = h[1], m = c > 0, g, y, b, w, E = [[], []], S, x, T, N, C, L = [0, 0, 0, 0], A = function (e, t) { return t.y - e.y }; if (e.visible && (i.enabled || e._hasPointLabels)) { En.prototype.drawDataLabels.apply(e); Kt(t, function (e) { e.dataLabel && e.visible && E[e.half].push(e) }); for (N = 0; !w && t[N]; ) w = t[N] && t[N].dataLabel && (t[N].dataLabel.getBBox().height || 21), N++; for (N = 2; N--; ) { var t = [], O = [], M = E[N], _ = M.length, D; e.sortByAngle(M, N - .5); if (c > 0) { for (C = v - p - c; C <= v + p + c; C += w) t.push(C); y = t.length; if (_ > y) { n = [].concat(M); n.sort(A); for (C = _; C--; ) n[C].rank = C; for (C = _; C--; ) M[C].rank >= y && M.splice(C, 1); _ = M.length } for (C = 0; C < _; C++) { n = M[C]; b = n.labelPos; n = 9999; var P, H; for (H = 0; H < y; H++) P = G(t[H] - b[1]), P < n && (n = P, D = H); if (D < C && t[C] !== null) D = C; else for (y < _ - C + D && t[C] !== null && (D = y - _ + C); t[D] === null; ) D++; O.push({ i: D, y: t[D] }); t[D] = null } O.sort(A) } for (C = 0; C < _; C++) { n = M[C]; b = n.labelPos; g = n.dataLabel; T = n.visible === !1 ? "hidden" : "visible"; n = b[1]; if (c > 0) { if (y = O.pop(), D = y.i, x = y.y, n > x && t[D + 1] !== null || n < x && t[D - 1] !== null) x = n } else x = n; S = i.justify ? h[0] + (N ? -1 : 1) * (p + c) : e.getX(D === 0 || D === t.length - 1 ? n : x, N); g._attr = { visibility: T, align: b[6] }; g._pos = { x: S + i.x + ({ left: s, right: -s}[b[6]] || 0), y: x + i.y - 10 }; g.connX = S; g.connY = x; if (this.options.size === null) y = g.width, S - y < s ? L[3] = K(V(y - S + s), L[3]) : S + y > u - s && (L[1] = K(V(S + y - u + s), L[1])), x - w / 2 < 0 ? L[0] = K(V(-x + w / 2), L[0]) : x + w / 2 > r && (L[2] = K(V(x + w / 2 - r), L[2])) } } if (k(L) === 0 || this.verifyDataLabelOverflow(L)) this.placeDataLabels(), m && o && Kt(this.points, function (t) { a = t.connector; b = t.labelPos; if ((g = t.dataLabel) && g._pos) T = g._attr.visibility, S = g.connX, x = g.connY, f = l ? ["M", S + (b[6] === "left" ? 5 : -5), x, "C", S, x, 2 * b[2] - b[4], 2 * b[3] - b[5], b[2], b[3], "L", b[4], b[5]] : ["M", S + (b[6] === "left" ? 5 : -5), x, "L", b[2], b[3], "L", b[4], b[5]], a ? (a.animate({ d: f }), a.attr("visibility", T)) : t.connector = a = e.chart.renderer.path(f).attr({ "stroke-width": o, stroke: i.connectorColor || t.color || "#606060", visibility: T }).add(e.group); else if (a) t.connector = a.destroy() }) } }, zt.pie.prototype.placeDataLabels = function () { Kt(this.points, function (e) { var e = e.dataLabel, t; if (e) (t = e._pos) ? (e.attr(e._attr), e[e.moved ? "animate" : "attr"](t), e.moved = !0) : e && e.attr({ y: -999 }) }) }, zt.pie.prototype.alignDataLabel = xt, zt.pie.prototype.verifyDataLabelOverflow = function (e) { var t = this.center, n = this.options, r = n.center, i = n = n.minSize || 80, s; r[0] !== null ? i = K(t[2] - K(e[1], e[3]), n) : (i = K(t[2] - e[1] - e[3], n), t[0] += (e[3] - e[1]) / 2); r[1] !== null ? i = K(Q(i, t[2] - K(e[0], e[2])), n) : (i = K(Q(i, t[2] - e[0] - e[2]), n), t[1] += (e[0] - e[2]) / 2); i < t[2] ? (t[2] = i, this.translate(t), Kt(this.points, function (e) { if (e.dataLabel) e.dataLabel._pos = null }), this.drawDataLabels && this.drawDataLabels()) : s = !0; return s }; if (zt.column) zt.column.prototype.alignDataLabel = function (e, n, r, i, s) { var o = this.chart, u = o.inverted, a = e.dlBox || e.shapeArgs, f = e.below || e.plotY > d(this.translatedThreshold, o.plotSizeY), l = d(r.inside, !!this.options.stacking); if (a && (i = t(a), u && (i = { x: o.plotWidth - i.y - i.height, y: o.plotHeight - i.x - i.width, width: i.height, height: i.width }), !l)) u ? (i.x += f ? 0 : i.width, i.width = 0) : (i.y += f ? i.height : 0, i.height = 0); r.align = d(r.align, !u || l ? "center" : f ? "right" : "left"); r.verticalAlign = d(r.verticalAlign, u || l ? "middle" : f ? "top" : "bottom"); En.prototype.alignDataLabel.call(this, e, n, r, i, s) }; w(En.prototype, "init", function (e) { var t; e.apply(this, Array.prototype.slice.call(arguments, 1)); (t = this.xAxis) && t.options.ordinal && Zt(this, "updatedData", function () { delete t.ordinalIndex }) }); w(j.prototype, "getTimeTicks", function (e, t, n, r, i, s, o, u) { var a = 0, f = 0, l, h = {}, p, d, v, m = [], g = -Number.MAX_VALUE, y = this.options.tickPixelInterval; if (!this.options.ordinal || !s || s.length < 3 || n === U) return e.call(this, t, n, r, i); for (d = s.length; f < d; f++) { v = f && s[f - 1] > r; s[f] < n && (a = f); if (f === d - 1 || s[f + 1] - s[f] > o * 5 || v) { if (s[f] > g) { for (l = e.call(this, t, s[a], s[f], i); l.length && l[0] <= g; ) l.shift(); l.length && (g = l[l.length - 1]); m = m.concat(l) } a = f + 1 } if (v) break } e = l.info; if (u && e.unitRange <= St.hour) { f = m.length - 1; for (a = 1; a < f; a++) (new Date(m[a] - Mt))[Ht]() !== (new Date(m[a - 1] - Mt))[Ht]() && (h[m[a]] = "day", p = !0); p && (h[m[0]] = "day"); e.higherRanks = h } m.info = e; if (u && c(y)) { var u = e = m.length, f = [], b; for (p = []; u--; ) a = this.translate(m[u]), b && (p[u] = b - a), f[u] = b = a; p.sort(); p = p[$(p.length / 2)]; p < y * .6 && (p = null); u = m[e - 1] > r ? e - 1 : e; for (b = void 0; u--; ) a = f[u], r = b - a, b && r < y * .8 && (p === null || r < p * .8) ? (h[m[u]] && !h[m[u + 1]] ? (r = u + 1, b = a) : r = u, m.splice(r, 1)) : b = a } return m }); e(j.prototype, { beforeSetTickPositions: function () { var e, t = [], n = !1, r, i = this.getExtremes(), s = i.min, i = i.max, o; if (this.options.ordinal) { Kt(this.series, function (n, r) { if (n.visible !== !1 && n.takeOrdinalPosition !== !1 && (t = t.concat(n.processedXData), e = t.length, t.sort(function (e, t) { return e - t }), e)) for (r = e - 1; r--; ) t[r] === t[r + 1] && t.splice(r, 1) }); e = t.length; if (e > 2) { r = t[1] - t[0]; for (o = e - 1; o-- && !n; ) t[o + 1] - t[o] !== r && (n = !0); if (!this.options.keepOrdinalPadding && (t[0] - s > r || i - t[t.length - 1] > r)) n = !0 } n ? (this.ordinalPositions = t, n = this.val2lin(K(s, t[0]), !0), r = this.val2lin(Q(i, t[t.length - 1]), !0), this.ordinalSlope = i = (i - s) / (r - n), this.ordinalOffset = s - n * i) : this.ordinalPositions = this.ordinalSlope = this.ordinalOffset = U } this.groupIntervalFactor = null }, val2lin: function (e, t) { var n = this.ordinalPositions; if (n) { var r = n.length, i, s; for (i = r; i--; ) if (n[i] === e) { s = i; break } for (i = r - 1; i--; ) if (e > n[i] || i === 0) { n = (e - n[i]) / (n[i + 1] - n[i]); s = i + n; break } return t ? s : this.ordinalSlope * (s || 0) + this.ordinalOffset } else return e }, lin2val: function (e, t) { var n = this.ordinalPositions; if (n) { var r = this.ordinalSlope, i = this.ordinalOffset, s = n.length - 1, o, u; if (t) e < 0 ? e = n[0] : e > s ? e = n[s] : (s = $(e), u = e - s); else for (; s--; ) if (o = r * s + i, e >= o) { r = r * (s + 1) + i; u = (e - o) / (r - o); break } return u !== U && n[s] !== U ? n[s] + (u ? u * (n[s + 1] - n[s]) : 0) : e } else return e }, getExtendedPositions: function () { var e = this.chart, t = this.series[0].currentDataGrouping, n = this.ordinalIndex, r = t ? t.count + t.unitName : "raw", i = this.getExtremes(), s, o; if (!n) n = this.ordinalIndex = {}; if (!n[r]) s = { series: [], getExtremes: function () { return { min: i.dataMin, max: i.dataMax} }, options: { ordinal: !0} }, Kt(this.series, function (n) { o = { xAxis: s, xData: n.xData, chart: e, destroyGroupedData: xt }; o.options = { dataGrouping: t ? { enabled: !0, forced: !0, approximation: "open", units: [[t.unitName, [t.count]]]} : { enabled: !1} }; n.processData.apply(o); s.series.push(o) }), this.beforeSetTickPositions.apply(s), n[r] = s.ordinalPositions; return n[r] }, getGroupIntervalFactor: function (e, t, n) { var r = 0, n = n.processedXData, i = n.length, s = [], o = this.groupIntervalFactor; if (!o) { for (; r < i - 1; r++) s[r] = n[r + 1] - n[r]; s.sort(function (e, t) { return e - t }); r = s[$(i / 2)]; e = K(e, n[0]); t = Q(t, n[i - 1]); this.groupIntervalFactor = o = i * r / (t - e) } return o }, postProcessTickInterval: function (e) { var t = this.ordinalSlope; return t ? e / (t / this.closestPointRange) : e } }); w(I.prototype, "pan", function (e, t) { var n = this.xAxis[0], r = t.chartX, i = !1; if (n.options.ordinal && n.series.length) { var s = this.mouseDownX, o = n.getExtremes(), u = o.dataMax, a = o.min, f = o.max, l = this.hoverPoints, c = n.closestPointRange, s = (s - r) / (n.translationSlope * (n.ordinalSlope || c)), h = { ordinalPositions: n.getExtendedPositions() }, c = n.lin2val, p = n.val2lin, d; if (h.ordinalPositions) { if (G(s) > 1) l && Kt(l, function (e) { e.setState() }), s < 0 ? (l = h, d = n.ordinalPositions ? n : h) : (l = n.ordinalPositions ? n : h, d = h), h = d.ordinalPositions, u > h[h.length - 1] && h.push(u), s = n.toFixedRange(null, null, c.apply(l, [p.apply(l, [a, !0]) + s, !0]), c.apply(d, [p.apply(d, [f, !0]) + s, !0])), s.min >= Q(o.dataMin, a) && s.max <= K(u, f) && n.setExtremes(s.min, s.max, !0, !1, { trigger: "pan" }), this.mouseDownX = r, v(this.container, { cursor: "move" }) } else i = !0 } else i = !0; i && e.apply(this, Array.prototype.slice.call(arguments, 1)) }); w(En.prototype, "getSegments", function (e) { var t, n = this.options.gapSize, r = this.xAxis; e.apply(this, Array.prototype.slice.call(arguments, 1)); if (n) t = this.segments, Kt(t, function (e, i) { for (var s = e.length - 1; s--; ) e[s + 1].x - e[s].x > r.closestPointRange * n && t.splice(i + 1, 0, e.splice(s + 1, e.length - s)) }) }); var Tn = En.prototype, Nn = Tn.processData, Cn = Tn.generatePoints, kn = Tn.destroy, Ln = Tn.tooltipHeaderFormatter, An = { approximation: "average", groupPixelWidth: 2, dateTimeLabelFormats: n("millisecond", ["%A, %b %e, %H:%M:%S.%L", "%A, %b %e, %H:%M:%S.%L", "-%H:%M:%S.%L"], "second", ["%A, %b %e, %H:%M:%S", "%A, %b %e, %H:%M:%S", "-%H:%M:%S"], "minute", ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"], "hour", ["%A, %b %e, %H:%M", "%A, %b %e, %H:%M", "-%H:%M"], "day", ["%A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"], "week", ["Week from %A, %b %e, %Y", "%A, %b %e", "-%A, %b %e, %Y"], "month", ["%B %Y", "%B", "-%B %Y"], "year", ["%Y", "%Y", "-%Y"]) }, On = { line: {}, spline: {}, area: {}, areaspline: {}, column: { approximation: "sum", groupPixelWidth: 10 }, arearange: { approximation: "range" }, areasplinerange: { approximation: "range" }, columnrange: { approximation: "range", groupPixelWidth: 10 }, candlestick: { approximation: "ohlc", groupPixelWidth: 10 }, ohlc: { approximation: "ohlc", groupPixelWidth: 5} }, Mn = [["millisecond", [1, 2, 5, 10, 20, 25, 50, 100, 200, 500]], ["second", [1, 2, 5, 10, 15, 30]], ["minute", [1, 2, 5, 10, 15, 30]], ["hour", [1, 2, 3, 4, 6, 8, 12]], ["day", [1]], ["week", [1]], ["month", [1, 3, 6]], ["year", null]], _n = { sum: function (e) { var t = e.length, n; if (!t && e.hasNulls) n = null; else if (t) for (n = 0; t--; ) n += e[t]; return n }, average: function (e) { var t = e.length, e = _n.sum(e); typeof e === "number" && t && (e /= t); return e }, open: function (e) { return e.length ? e[0] : e.hasNulls ? null : U }, high: function (e) { return e.length ? k(e) : e.hasNulls ? null : U }, low: function (e) { return e.length ? C(e) : e.hasNulls ? null : U }, close: function (e) { return e.length ? e[e.length - 1] : e.hasNulls ? null : U }, ohlc: function (e, t, n, r) { e = _n.open(e); t = _n.high(t); n = _n.low(n); r = _n.close(r); if (typeof e === "number" || typeof t === "number" || typeof n === "number" || typeof r === "number") return [e, t, n, r] }, range: function (e, t) { e = _n.low(e); t = _n.high(t); if (typeof e === "number" || typeof t === "number") return [e, t] } }; Tn.groupData = function (e, t, n, r) { var i = this.data, s = this.options.data, o = [], u = [], a = e.length, f, l, c = !!t, h = [[], [], [], []], r = typeof r === "function" ? r : _n[r], p = this.pointArrayMap, d = p && p.length, v; for (v = 0; v <= a; v++) { for (; n[1] !== U && e[v] >= n[1] || v === a; ) if (f = n.shift(), l = r.apply(0, h), l !== U && (o.push(f), u.push(l)), h[0] = [], h[1] = [], h[2] = [], h[3] = [], v === a) break; if (v === a) break; if (p) { f = this.cropStart + v; f = i && i[f] || this.pointClass.prototype.applyOptions.apply({ series: this }, [s[f]]); var m; for (l = 0; l < d; l++) if (m = f[p[l]], typeof m === "number") h[l].push(m); else if (m === null) h[l].hasNulls = !0 } else if (f = c ? t[v] : null, typeof f === "number") h[0].push(f); else if (f === null) h[0].hasNulls = !0 } return [o, u] }; Tn.processData = function () { var e = this.chart, t = this.options, n = t.dataGrouping, r = n && d(n.enabled, e.options._stock), i; this.forceCrop = r; this.groupPixelWidth = null; if (Nn.apply(this, arguments) !== !1 && r) { this.destroyGroupedData(); var s = this.processedXData, o = this.processedYData, u = e.plotSizeX, a = this.xAxis, f = a.options.ordinal, l = this.groupPixelWidth = a.getGroupPixelWidth && a.getGroupPixelWidth(), e = this.pointRange; if (l) { i = !0; this.points = null; r = a.getExtremes(); e = r.min; r = r.max; f = f && a.getGroupIntervalFactor(e, r, this) || 1; u = l * (r - e) / u * f; a = a.getTimeTicks(a.normalizeTimeTickInterval(u, n.units || Mn), e, r, null, s, this.closestPointRange); o = Tn.groupData.apply(this, [s, o, a, n.approximation]); s = o[0]; o = o[1]; if (n.smoothed) { n = s.length - 1; for (s[n] = r; n-- && n > 0; ) s[n] += u / 2; s[0] = e } this.currentDataGrouping = a.info; if (t.pointRange === null) this.pointRange = a.info.totalRange; this.closestPointRange = a.info.totalRange; this.processedXData = s; this.processedYData = o } else this.currentDataGrouping = null, this.pointRange = e; this.hasGroupedData = i } }; Tn.destroyGroupedData = function () { var e = this.groupedData; Kt(e || [], function (t, n) { t && (e[n] = t.destroy ? t.destroy() : null) }); this.groupedData = null }; Tn.generatePoints = function () { Cn.apply(this); this.destroyGroupedData(); this.groupedData = this.hasGroupedData ? this.points : null }; Tn.tooltipHeaderFormatter = function (e) { var t = this.tooltipOptions, n = this.options.dataGrouping, r = t.xDateFormat, i, s = this.xAxis, o, a; if (s && s.options.type === "datetime" && n && u(e.key)) { o = this.currentDataGrouping; n = n.dateTimeLabelFormats; if (o) s = n[o.unitName], o.count === 1 ? r = s[0] : (r = s[1], i = s[2]); else if (!r && n) for (a in St) if (St[a] >= s.closestPointRange) { r = n[a][0]; break } r = bt(r, e.key); i && (r += bt(i, e.key + o.totalRange - 1)); e = t.headerFormat.replace("{point.key}", r) } else e = Ln.call(this, e); return e }; Tn.destroy = function () { for (var e = this.groupedData || [], t = e.length; t--; ) e[t] && e[t].destroy(); kn.apply(this) }; w(Tn, "setOptions", function (e, n) { var r = e.call(this, n), i = this.type, s = this.chart.options.plotOptions, o = on[i].dataGrouping; if (On[i]) o || (o = t(An, On[i])), r.dataGrouping = t(o, s.series && s.series.dataGrouping, s[i].dataGrouping, n.dataGrouping); if (this.chart.options._stock) this.requireSorting = !0; return r }); j.prototype.getGroupPixelWidth = function () { var e = this.series, t = e.length, n, r = 0, i = !1, s; for (n = t; n--; ) (s = e[n].options.dataGrouping) && (r = K(r, s.groupPixelWidth)); for (n = t; n--; ) if (s = e[n].options.dataGrouping) if (t = (e[n].processedXData || e[n].data).length, e[n].groupPixelWidth || t > this.chart.plotSizeX / r || t && s.forced) i = !0; return i ? r : 0 }; on.ohlc = t(on.column, { lineWidth: 1, tooltip: { pointFormat: '<span style="color:{series.color};font-weight:bold">{series.name}</span><br/>Open: {point.open}<br/>High: {point.high}<br/>Low: {point.low}<br/>Close: {point.close}<br/>' }, states: { hover: { lineWidth: 3} }, threshold: null }); Wt = g(zt.column, { type: "ohlc", pointArrayMap: ["open", "high", "low", "close"], toYData: function (e) { return [e.open, e.high, e.low, e.close] }, pointValKey: "high", pointAttrToOptions: { stroke: "color", "stroke-width": "lineWidth" }, upColorProp: "stroke", getAttribs: function () { zt.column.prototype.getAttribs.apply(this, arguments); var e = this.options, n = e.states, e = e.upColor || this.color, r = t(this.pointAttr), i = this.upColorProp; r[""][i] = e; r.hover[i] = n.hover.upColor || e; r.select[i] = n.select.upColor || e; Kt(this.points, function (e) { if (e.open < e.close) e.pointAttr = r }) }, translate: function () { var e = this.yAxis; zt.column.prototype.translate.apply(this); Kt(this.points, function (t) { if (t.open !== null) t.plotOpen = e.translate(t.open, 0, 1, 0, 1); if (t.close !== null) t.plotClose = e.translate(t.close, 0, 1, 0, 1) }) }, drawPoints: function () { var e = this, t = e.chart, n, r, i, s, o, u, a, f; Kt(e.points, function (l) { if (l.plotY !== U) a = l.graphic, n = l.pointAttr[l.selected ? "selected" : ""], s = n["stroke-width"] % 2 / 2, f = V(l.plotX) + s, o = V(l.shapeArgs.width / 2), u = ["M", f, V(l.yBottom), "L", f, V(l.plotY)], l.open !== null && (r = V(l.plotOpen) + s, u.push("M", f, r, "L", f - o, r)), l.close !== null && (i = V(l.plotClose) + s, u.push("M", f, i, "L", f + o, i)), a ? a.animate({ d: u }) : l.graphic = t.renderer.path(u).attr(n).add(e.group) }) }, animate: null }); zt.ohlc = Wt; on.candlestick = t(on.column, { lineColor: "black", lineWidth: 1, states: { hover: { lineWidth: 2} }, tooltip: on.ohlc.tooltip, threshold: null, upColor: "white" }); Wt = g(Wt, { type: "candlestick", pointAttrToOptions: { fill: "color", stroke: "lineColor", "stroke-width": "lineWidth" }, upColorProp: "fill", getAttribs: function () { zt.ohlc.prototype.getAttribs.apply(this, arguments); var e = this.options, t = e.states, n = e.upLineColor || e.lineColor, r = t.hover.upLineColor || n, i = t.select.upLineColor || n; Kt(this.points, function (e) { if (e.open < e.close) e.pointAttr[""].stroke = n, e.pointAttr.hover.stroke = r, e.pointAttr.select.stroke = i }) }, drawPoints: function () { var e = this, t = e.chart, n, r, i, s, o, u, a, f, l, c, h, p; Kt(e.points, function (d) { c = d.graphic; if (d.plotY !== U) n = d.pointAttr[d.selected ? "selected" : ""], f = n["stroke-width"] % 2 / 2, l = V(d.plotX) + f, r = d.plotOpen, i = d.plotClose, s = X.min(r, i), o = X.max(r, i), p = V(d.shapeArgs.width / 2), u = V(s) !== V(d.plotY), a = o !== d.yBottom, s = V(s) + f, o = V(o) + f, h = ["M", l - p, o, "L", l - p, s, "L", l + p, s, "L", l + p, o, "L", l - p, o, "M", l, s, "L", l, u ? V(d.plotY) : s, "M", l, o, "L", l, a ? V(d.yBottom) : o, "Z"], c ? c.animate({ d: h }) : d.graphic = t.renderer.path(h).attr(n).add(e.group).shadow(e.options.shadow) }) } }); zt.candlestick = Wt; var Dn = cn.prototype.symbols; on.flags = t(on.column, { dataGrouping: null, fillColor: "white", lineWidth: 1, pointRange: 0, shape: "flag", stackDistance: 12, states: { hover: { lineColor: "black", fillColor: "#FCFFC5"} }, style: { fontSize: "11px", fontWeight: "bold", textAlign: "center" }, tooltip: { pointFormat: "{point.text}<br/>" }, threshold: null, y: -30 }); zt.flags = g(zt.column, { type: "flags", sorted: !1, noSharedTooltip: !0, takeOrdinalPosition: !1, forceCrop: !0, init: En.prototype.init, pointAttrToOptions: { fill: "fillColor", stroke: "color", "stroke-width": "lineWidth", r: "radius" }, translate: function () { zt.column.prototype.translate.apply(this); var e = this.chart, t = this.points, n = t.length - 1, r, i, s = this.options.onSeries, s = (r = s && e.get(s)) && r.options.step, o = r && r.points, u = o && o.length, a = this.xAxis, f = a.getExtremes(), l, c, h; if (r && r.visible && u) { r = r.currentDataGrouping; c = o[u - 1].x + (r ? r.totalRange : 0); for (t.sort(function (e, t) { return e.x - t.x }); u-- && t[n]; ) if (r = t[n], l = o[u], l.x <= r.x && l.plotY !== U) { if (r.x <= c) r.plotY = l.plotY, l.x < r.x && !s && (h = o[u + 1]) && h.plotY !== U && (r.plotY += (r.x - l.x) / (h.x - l.x) * (h.plotY - l.plotY)); n--; u++; if (n < 0) break } } Kt(t, function (n, r) { if (n.plotY === U) n.x >= f.min && n.x <= f.max ? n.plotY = e.chartHeight - a.bottom - (a.opposite ? a.height : 0) + a.offset - e.plotTop : n.shapeArgs = {}; if ((i = t[r - 1]) && i.plotX === n.plotX) { if (i.stackIndex === U) i.stackIndex = 0; n.stackIndex = i.stackIndex + 1 } }) }, drawPoints: function () { var e, n = this.points, r = this.chart.renderer, i, s, o = this.options, u = o.y, a, f, l, c, h = o.lineWidth % 2 / 2, p, d; for (f = n.length; f--; ) if (l = n[f], e = l.plotX > this.xAxis.len, i = l.plotX + (e ? h : -h), c = l.stackIndex, a = l.options.shape || o.shape, s = l.plotY, s !== U && (s = l.plotY + u + h - (c !== U && c * o.stackDistance)), p = c ? U : l.plotX + h, d = c ? U : l.plotY, c = l.graphic, s !== U && i >= 0 && !e) e = l.pointAttr[l.selected ? "select" : ""], c ? c.attr({ x: i, y: s, r: e.r, anchorX: p, anchorY: d }) : c = l.graphic = r.label(l.options.title || o.title || "A", i, s, a, p, d, o.useHTML).css(t(o.style, l.style)).attr(e).attr({ align: a === "flag" ? "left" : "center", width: o.width, height: o.height }).add(this.markerGroup).shadow(o.shadow), a = c.box, a.getBBox(), l.tooltipPos = [i, s]; else if (c) l.graphic = c.destroy() }, drawTracker: function () { var e = this.points; gn.drawTrackerPoint.apply(this); Kt(e, function (t) { var n = t.graphic; n && Zt(n.element, "mouseover", function () { if (t.stackIndex > 0 && !t.raised) t._y = n.y, n.attr({ y: t._y - 8 }), t.raised = !0; Kt(e, function (e) { if (e !== t && e.raised && e.graphic) e.graphic.attr({ y: e._y }), e.raised = !1 }) }) }) }, animate: xt }); Dn.flag = function (e, t, n, r, i) { var s = i && i.anchorX || e, i = i && i.anchorY || t; return ["M", s, i, "L", e, t + r, e, t, e + n, t, e + n, t + r, e, t + r, "M", s, i, "Z"] }; Kt(["circle", "square"], function (e) { Dn[e + "pin"] = function (t, n, r, i, s) { var o = s && s.anchorX, s = s && s.anchorY, t = Dn[e](t, n, r, i); o && s && t.push("M", o, n > s ? n : n + i, "L", o, s); return t } }); pt === Highcharts.VMLRenderer && Kt(["flag", "circlepin", "squarepin"], function (e) { hn.prototype.symbols[e] = Dn[e] }); Wt = n("linearGradient", { x1: 0, y1: 0, x2: 0, y2: 1 }, "stops", [[0, "#FFF"], [1, "#CCC"]]); Xt = [].concat(Mn); Xt[4] = ["day", [1, 2, 3, 4]]; Xt[5] = ["week", [1, 2, 3]]; e(yt, { navigator: { handles: { backgroundColor: "#FFF", borderColor: "#666" }, height: 40, margin: 10, maskFill: "rgba(255, 255, 255, 0.75)", outlineColor: "#444", outlineWidth: 1, series: { type: zt.areaspline === U ? "line" : "areaspline", color: "#4572A7", compare: null, fillOpacity: .4, dataGrouping: { approximation: "average", enabled: !0, groupPixelWidth: 2, smoothed: !0, units: Xt }, dataLabels: { enabled: !1, zIndex: 2 }, id: "highcharts-navigator-series", lineColor: "#4572A7", lineWidth: 1, marker: { enabled: !1 }, pointRange: 0, shadow: !1, threshold: null }, xAxis: { tickWidth: 0, lineWidth: 0, gridLineWidth: 1, tickPixelInterval: 200, labels: { align: "left", x: 3, y: -4 }, crosshair: { label: { enabled: !1}} }, yAxis: { gridLineWidth: 0, startOnTick: !1, endOnTick: !1, minPadding: .1, maxPadding: .1, labels: { enabled: !1 }, crosshair: { enabled: !1, label: { enabled: !1} }, title: { text: null }, tickWidth: 0} }, scrollbar: { height: at ? 20 : 14, barBackgroundColor: Wt, barBorderRadius: 2, barBorderWidth: 1, barBorderColor: "#666", buttonArrowColor: "#666", buttonBackgroundColor: Wt, buttonBorderColor: "#666", buttonBorderRadius: 2, buttonBorderWidth: 1, minWidth: 6, rifleColor: "#666", trackBackgroundColor: n("linearGradient", { x1: 0, y1: 0, x2: 0, y2: 1 }, "stops", [[0, "#EEE"], [1, "#FFF"]]), trackBorderColor: "#CCC", trackBorderWidth: 1, liveRedraw: lt && !at} }); q.prototype = { drawHandle: function (e, t) { var n = this.chart, r = n.renderer, i = this.elementsToDestroy, s = this.handles, o = this.navigatorOptions.handles, o = { fill: o.backgroundColor, stroke: o.borderColor, "stroke-width": 1 }, u; this.rendered || (s[t] = r.g().css({ cursor: "e-resize" }).attr({ zIndex: 4 - t }).add(), u = r.rect(-4.5, 0, 9, 16, 3, 1).attr(o).add(s[t]), i.push(u), u = r.path(["M", -1.5, 4, "L", -1.5, 12, "M", .5, 4, "L", .5, 12]).attr(o).add(s[t]), i.push(u)); s[t][n.isResizing ? "animate" : "attr"]({ translateX: this.scrollerLeft + this.scrollbarHeight + parseInt(e, 10), translateY: this.top + this.height / 2 - 8 }) }, drawScrollbarButton: function (e) { var t = this.chart.renderer, n = this.elementsToDestroy, r = this.scrollbarButtons, i = this.scrollbarHeight, s = this.scrollbarOptions, o; this.rendered || (r[e] = t.g().add(this.scrollbarGroup), o = t.rect(-.5, -.5, i + 1, i + 1, s.buttonBorderRadius, s.buttonBorderWidth).attr({ stroke: s.buttonBorderColor, "stroke-width": s.buttonBorderWidth, fill: s.buttonBackgroundColor }).add(r[e]), n.push(o), o = t.path(["M", i / 2 + (e ? -1 : 1), i / 2 - 3, "L", i / 2 + (e ? -1 : 1), i / 2 + 3, i / 2 + (e ? 2 : -2), i / 2]).attr({ fill: s.buttonArrowColor }).add(r[e]), n.push(o)); e && r[e].attr({ translateX: this.scrollerWidth - i }) }, render: function (e, t, n, r) { var i = this.chart, s = i.renderer, o, u, a, f, l = this.scrollbarGroup, c = this.navigatorGroup, h = this.scrollbar, c = this.xAxis, p = this.scrollbarTrack, v = this.scrollbarHeight, m = this.scrollbarEnabled, g = this.navigatorOptions, y = this.scrollbarOptions, b = y.minWidth, w = this.height, E = this.top, S = this.navigatorEnabled, x = g.outlineWidth, T = x / 2, N = 0, C = this.outlineHeight, k = y.barBorderRadius, L = y.barBorderWidth, A = E + T, O; if (!isNaN(e)) { this.navigatorLeft = o = d(c.left, i.plotLeft + v); this.navigatorWidth = u = d(c.len, i.plotWidth - 2 * v); this.scrollerLeft = a = o - v; this.scrollerWidth = f = f = u + 2 * v; c.getExtremes && (O = this.getUnionExtremes(!0)) && (O.dataMin !== c.min || O.dataMax !== c.max) && c.setExtremes(O.dataMin, O.dataMax, !0, !1); n = d(n, c.translate(e)); r = d(r, c.translate(t)); if (isNaN(n) || G(n) === Infinity) n = 0, r = f; this.zoomedMax = Q(K(n, r), u); this.zoomedMin = K(this.fixedWidth ? this.zoomedMax - this.fixedWidth : Q(n, r), 0); this.range = this.zoomedMax - this.zoomedMin; n = V(this.zoomedMax); t = V(this.zoomedMin); e = n - t; if (!this.rendered) { if (S) this.navigatorGroup = c = s.g("navigator").attr({ zIndex: 3 }).add(), this.leftShade = s.rect().attr({ fill: g.maskFill }).add(c), this.rightShade = s.rect().attr({ fill: g.maskFill }).add(c), this.outline = s.path().attr({ "stroke-width": x, stroke: g.outlineColor }).add(c); if (m) this.scrollbarGroup = l = s.g("scrollbar").add(), h = y.trackBorderWidth, this.scrollbarTrack = p = s.rect().attr({ y: -h % 2 / 2, fill: y.trackBackgroundColor, stroke: y.trackBorderColor, "stroke-width": h, r: y.trackBorderRadius || 0, height: v }).add(l), this.scrollbar = h = s.rect().attr({ y: -L % 2 / 2, height: v, fill: y.barBackgroundColor, stroke: y.barBorderColor, "stroke-width": L, r: k }).add(l), this.scrollbarRifles = s.path().attr({ stroke: y.rifleColor, "stroke-width": 1 }).add(l) } i = i.isResizing ? "animate" : "attr"; S && (this.leftShade[i]({ x: o, y: E, width: t, height: w }), this.rightShade[i]({ x: o + n, y: E, width: u - n, height: w }), this.outline[i]({ d: ["M", a, A, "L", o + t + T, A, o + t + T, A + C - v, "M", o + n - T, A + C - v, "L", o + n - T, A, a + f, A] }), this.drawHandle(t + T, 0), this.drawHandle(n + T, 1)); if (m && l) this.drawScrollbarButton(0), this.drawScrollbarButton(1), l[i]({ translateX: a, translateY: V(A + w) }), p[i]({ width: f }), o = v + t, u = e - L, u < b && (N = (b - u) / 2, u = b, o -= N), this.scrollbarPad = N, h[i]({ x: $(o) + L % 2 / 2, width: u }), b = v + t + e / 2 - .5, this.scrollbarRifles.attr({ visibility: e > 12 ? "visible" : "hidden" })[i]({ d: ["M", b - 3, v / 4, "L", b - 3, 2 * v / 3, "M", b, v / 4, "L", b, 2 * v / 3, "M", b + 3, v / 4, "L", b + 3, 2 * v / 3] }); this.scrollbarPad = N; this.rendered = !0 } }, addEvents: function () { var e = this.chart.container, t = this.mouseDownHandler, n = this.mouseMoveHandler, r = this.mouseUpHandler, i; i = [[e, "mousedown", t], [e, "mousemove", n], [document, "mouseup", r]]; dt && i.push([e, "touchstart", t], [e, "touchmove", n], [document, "touchend", r]); Kt(i, function (e) { Zt.apply(null, e) }); this._events = i }, removeEvents: function () { Kt(this._events, function (e) { en.apply(null, e) }); this._events = U; this.navigatorEnabled && this.baseSeries && en(this.baseSeries, "updatedData", this.updatedDataHandler) }, init: function () { var e = this, n = e.chart, r, i, s = e.scrollbarHeight, o = e.navigatorOptions, u = e.height, a = e.top, f, l, c = document.body.style, h, p = e.baseSeries; e.mouseDownHandler = function (t) { var t = n.pointer.normalize(t), i = e.zoomedMin, s = e.zoomedMax, o = e.top, a = e.scrollbarHeight, l = e.scrollerLeft, p = e.scrollerWidth, d = e.navigatorLeft, v = e.navigatorWidth, m = e.scrollbarPad, g = e.range, y = t.chartX, b = t.chartY, t = n.xAxis[0], w, E = at ? 10 : 7; if (b > o && b < o + u + a) if ((o = !e.scrollbarEnabled || b < o + u) && X.abs(y - i - d) < E) e.grabbedLeft = !0, e.otherHandlePos = s, e.fixedExtreme = t.max, n.fixedRange = null; else if (o && X.abs(y - s - d) < E) e.grabbedRight = !0, e.otherHandlePos = i, e.fixedExtreme = t.min, n.fixedRange = null; else if (y > d + i - m && y < d + s + m) { e.grabbedCenter = y; e.fixedWidth = g; if (n.renderer.isSVG) h = c.cursor, c.cursor = "ew-resize"; f = y - i } else if (y > l && y < l + p) { s = o ? y - d - g / 2 : y < d ? i - g * .2 : y > l + p - a ? i + g * .2 : y < d + i ? i - g : s; if (s < 0) s = 0; else if (s + g >= v) s = v - g, w = r.dataMax; if (s !== i) e.fixedWidth = g, i = r.toFixedRange(s, s + g, null, w), t.setExtremes(i.min, i.max, !0, !1, { trigger: "navigator" }) } }; e.mouseMoveHandler = function (t) { var r = e.scrollbarHeight, i = e.navigatorLeft, s = e.navigatorWidth, o = e.scrollerLeft, u = e.scrollerWidth, a = e.range, c; if (t.pageX !== 0) t = n.pointer.normalize(t), c = t.chartX, c < i ? c = i : c > o + u - r && (c = o + u - r), e.grabbedLeft ? (l = !0, e.render(0, 0, c - i, e.otherHandlePos)) : e.grabbedRight ? (l = !0, e.render(0, 0, e.otherHandlePos, c - i)) : e.grabbedCenter && (l = !0, c < f ? c = f : c > s + f - a && (c = s + f - a), e.render(0, 0, c - f, c - f + a)), l && e.scrollbarOptions.liveRedraw && setTimeout(function () { e.mouseUpHandler(t) }, 0) }; e.mouseUpHandler = function (t) { var i, s; if (l) { if (e.zoomedMin === e.otherHandlePos) i = e.fixedExtreme; else if (e.zoomedMax === e.otherHandlePos) s = e.fixedExtreme; if (e.zoomedMax === e.navigatorWidth) s = r.dataMax; i = r.toFixedRange(e.zoomedMin, e.zoomedMax, i, s); n.xAxis[0].setExtremes(i.min, i.max, !0, !1, { trigger: "navigator", triggerOp: "navigator-drag", DOMEvent: t }) } if (t.type !== "mousemove") e.grabbedLeft = e.grabbedRight = e.grabbedCenter = e.fixedWidth = e.fixedExtreme = e.otherHandlePos = l = f = null, c.cursor = h || "" }; var v = n.xAxis.length, m = n.yAxis.length; n.extraBottomMargin = e.outlineHeight + o.margin; e.navigatorEnabled ? (e.xAxis = r = new j(n, t({ ordinal: p && p.xAxis.options.ordinal }, o.xAxis, { id: "navigator-x-axis", isX: !0, type: "datetime", index: v, height: u, offset: 0, offsetLeft: s, offsetRight: -s, keepOrdinalPadding: !0, startOnTick: !1, endOnTick: !1, minPadding: 0, maxPadding: 0, zoomEnabled: !1 })), e.yAxis = i = new j(n, t(o.yAxis, { id: "navigator-y-axis", alignTicks: !1, height: u, offset: 0, index: m, zoomEnabled: !1 })), p || o.series.data ? e.addBaseSeries() : n.series.length === 0 && w(n, "redraw", function (t, r) { if (n.series.length > 0 && !e.series) e.setBaseSeries(), n.redraw = t; t.call(n, r) })) : e.xAxis = r = { translate: function (e, t) { var r = n.xAxis[0].getExtremes(), i = n.plotWidth - 2 * s, o = r.dataMin, r = r.dataMax - o; return t ? e * r / i + o : i * (e - o) / r }, toFixedRange: j.prototype.toFixedRange }; w(n, "getMargins", function (t) { var n = this.legend, s = n.options; t.call(this); e.top = a = e.navigatorOptions.top || this.chartHeight - e.height - e.scrollbarHeight - this.spacing[2] - (s.verticalAlign === "bottom" && s.enabled && !s.floating ? n.legendHeight + d(s.margin, 10) : 0); if (r && i) r.options.top = i.options.top = a, r.setAxisSize(), i.setAxisSize() }); e.addEvents() }, getUnionExtremes: function (e) { var t = this.chart.xAxis[0], n = this.xAxis, r = n.options; if (!e || t.dataMin !== null) return { dataMin: d(r && r.min, (c(t.dataMin) && c(n.dataMin) ? Q : d)(t.dataMin, n.dataMin)), dataMax: d(r && r.max, (c(t.dataMax) && c(n.dataMax) ? K : d)(t.dataMax, n.dataMax))} }, setBaseSeries: function (e) { var t = this.chart, e = e || t.options.navigator.baseSeries; this.series && this.series.remove(); this.baseSeries = t.series[e] || typeof e === "string" && t.get(e) || t.series[0]; this.xAxis && this.addBaseSeries() }, addBaseSeries: function () { var n = this.baseSeries, r = n ? n.options : {}, i = r.data, s = this.navigatorOptions.series, o; o = s.data; this.hasNavigatorData = !!o; r = t(r, s, { clip: !1, enableMouseTracking: !1, group: "nav", padXAxis: !1, xAxis: "navigator-x-axis", yAxis: "navigator-y-axis", name: "Navigator", showInLegend: !1, isInternal: !0, visible: !0 }); r.data = o || i; this.series = this.chart.initSeries(r); if (n && this.navigatorOptions.adaptToUpdatedData !== !1) Zt(n, "updatedData", this.updatedDataHandler), n.userOptions.events = e(n.userOptions.event, { updatedData: this.updatedDataHandler }) }, updatedDataHandler: function () { var e = this.chart.scroller, t = e.baseSeries, n = t.xAxis, r = n.getExtremes(), i = r.min, s = r.max, o = r.dataMin, r = r.dataMax, u = s - i, a, f, l, c, h, p = e.series; a = p.xData; var d = !!n.setExtremes; f = s >= a[a.length - 1] - (this.closestPointRange || 0); a = i <= o; if (!e.hasNavigatorData) p.options.pointStart = t.xData[0], p.setData(t.options.data, !1), h = !0; a && (c = o, l = c + u); f && (l = r, a || (c = K(l - u, p.xData[0]))); d && (a || f) ? isNaN(c) || n.setExtremes(c, l, !0, !1, { trigger: "updatedData" }) : (h && this.chart.redraw(!1), e.render(K(i, o), Q(s, r))) }, destroy: function () { this.removeEvents(); Kt([this.xAxis, this.yAxis, this.leftShade, this.rightShade, this.outline, this.scrollbarTrack, this.scrollbarRifles, this.scrollbarGroup, this.scrollbar], function (e) { e && e.destroy && e.destroy() }); this.xAxis = this.yAxis = this.leftShade = this.rightShade = this.outline = this.scrollbarTrack = this.scrollbarRifles = this.scrollbarGroup = this.scrollbar = null; Kt([this.scrollbarButtons, this.handles, this.elementsToDestroy], function (e) { L(e) }) } }; Highcharts.Scroller = q; w(j.prototype, "zoom", function (e, t, n) { var r = this.chart, i = r.options, s = i.chart.zoomType, o = i.navigator, i = i.rangeSelector, u; if (this.isXAxis && (o && o.enabled || i && i.enabled)) if (s === "x") r.resetZoomButton = "blocked"; else if (s === "y") u = !1; else if (s === "xy") r = this.previousZoom, c(t) ? this.previousZoom = [this.min, this.max] : r && (t = r[0], n = r[1], delete this.previousZoom); return u !== U ? u : e.call(this, t, n) }); w(I.prototype, "init", function (e, t, n) { Zt(this, "beforeRender", function () { var e = this.options; if (e.navigator.enabled || e.scrollbar.enabled) this.scroller = new q(this) }); e.call(this, t, n) }); w(En.prototype, "addPoint", function (e, t, n, r, i) { var u = this.options.turboThreshold; u && this.xData.length > u && s(t) && !o(t) && this.chart.scroller && O(20, !0); e.call(this, t, n, r, i) }); e(yt, { rangeSelector: { buttonTheme: { width: 28, height: 16, padding: 1, r: 0, stroke: "#68A", zIndex: 7 }, inputPosition: { align: "right" }, labelStyle: { color: "#666"}} }); yt.lang = t(yt.lang, { rangeSelectorZoom: "Zoom", rangeSelectorFrom: "From", rangeSelectorTo: "To" }); R.prototype = { clickButton: function (e, n) { var r = this, i = r.selected, s = r.chart, o = r.buttons, u = r.buttonOptions[e], a = s.xAxis[0], f = s.scroller && s.scroller.getUnionExtremes() || a || {}, l = f.dataMin, c = f.dataMax, h, p = a && V(Q(a.max, d(c, a.max))), v = new Date(p), m = u.type, g = u.count, f = u._range, y; if (!(l === null || c === null || e === r.selected)) { if (m === "month" || m === "year") h = { month: "Month", year: "FullYear"}[m], v["set" + h](v["get" + h]() - g), h = v.getTime(), l = d(l, Number.MIN_VALUE), isNaN(h) || h < l ? (h = l, p = Q(h + f, c)) : f = p - h; else if (f) h = K(p - f, l), p = Q(h + f, c); else if (m === "ytd") if (a) { if (c === U) l = Number.MAX_VALUE, c = Number.MIN_VALUE, Kt(s.series, function (e) { e = e.xData; l = Q(e[0], l); c = K(e[e.length - 1], c) }), n = !1; p = new Date(c); y = p.getFullYear(); h = y = K(l || 0, Date.UTC(y, 0, 1)); p = p.getTime(); p = Q(c || p, p) } else { Zt(s, "beforeRender", function () { r.clickButton(e) }); return } else m === "all" && a && (h = l, p = c); o[i] && o[i].setState(0); o[e] && o[e].setState(2); s.fixedRange = f; a ? a.setExtremes(h, p, d(n, 1), 0, { trigger: "rangeSelectorButton", rangeSelectorButton: u }) : (i = s.options.xAxis, i[0] = t(i[0], { range: f, min: y })); r.setSelected(e) } }, setSelected: function (e) { this.selected = this.options.selected = e }, defaultButtons: [{ type: "month", count: 1, text: "1m" }, { type: "month", count: 3, text: "3m" }, { type: "month", count: 6, text: "6m" }, { type: "ytd", text: "YTD" }, { type: "year", count: 1, text: "1y" }, { type: "all", text: "All"}], init: function (e) { var t = this, n = e.options.rangeSelector, r = n.buttons || [].concat(t.defaultButtons), i = n.selected, s = t.blurInputs = function () { var e = t.minInput, n = t.maxInput; e && e.blur(); n && n.blur() }; t.chart = e; t.options = n; t.buttons = []; e.extraTopMargin = 25; t.buttonOptions = r; Zt(e.container, "mousedown", s); Zt(e, "resize", s); Kt(r, t.computeButtonRange); i !== U && r[i] && this.clickButton(i, !1); Zt(e, "load", function () { Zt(e.xAxis[0], "afterSetExtremes", function () { t.updateButtonStates(!0) }) }) }, updateButtonStates: function (e) { var t = this, n = this.chart, r = n.xAxis[0], i = n.scroller && n.scroller.getUnionExtremes() || r, s = i.dataMin, o = i.dataMax, u = t.selected, a = t.buttons; e && n.fixedRange !== V(r.max - r.min) && (a[u] && a[u].setState(0), t.setSelected(null)); Kt(t.buttonOptions, function (e, n) { var i = e._range, f = i > o - s, l = i < r.minRange, c = e.type === "all" && r.max - r.min >= o - s && a[n].state !== 2, h = e.type === "ytd" && bt("%Y", s) === bt("%Y", o); i === V(r.max - r.min) && n !== u ? (t.setSelected(n), a[n].setState(2)) : f || l || c || h ? a[n].setState(3) : a[n].state === 3 && a[n].setState(0) }) }, computeButtonRange: function (e) { var t = e.type, n = e.count || 1, r = { millisecond: 1, second: 1e3, minute: 6e4, hour: 36e5, day: 864e5, week: 6048e5 }; if (r[t]) e._range = r[t] * n; else if (t === "month" || t === "year") e._range = { month: 30, year: 365}[t] * 864e5 * n }, setInputValue: function (e, t) { var n = this.chart.options.rangeSelector; if (c(t)) this[e + "Input"].HCTime = t; this[e + "Input"].value = bt(n.inputEditDateFormat || "%Y-%m-%d", this[e + "Input"].HCTime); this[e + "DateBox"].attr({ text: bt(n.inputDateFormat || "%b %e, %Y", this[e + "Input"].HCTime) }) }, drawInput: function (n) { var i = this, s = i.chart, o = s.options.chart.style, u = s.renderer, a = s.options.rangeSelector, f = i.div, l = n === "min", c, h, p, d = this.inputGroup; this[n + "Label"] = h = u.label(yt.lang[l ? "rangeSelectorFrom" : "rangeSelectorTo"], this.inputGroup.offset).attr({ padding: 1 }).css(t(o, a.labelStyle)).add(d); d.offset += h.width + 5; this[n + "DateBox"] = p = u.label("", d.offset).attr({ padding: 1, width: a.inputBoxWidth || 90, height: a.inputBoxHeight || 16, stroke: a.inputBoxBorderColor || "silver", "stroke-width": 1 }).css(t({ textAlign: "center" }, o, a.inputStyle)).on("click", function () { i[n + "Input"].focus() }).add(d); d.offset += p.width + (l ? 10 : 0); this[n + "Input"] = c = m("input", { name: n, className: "highcharts-range-selector", type: "text" }, e({ position: "absolute", border: 0, width: "1px", height: "1px", padding: 0, textAlign: "center", fontSize: o.fontSize, fontFamily: o.fontFamily, top: s.plotTop + "px" }, a.inputStyle), f); c.onfocus = function () { v(this, { left: d.translateX + p.x + "px", top: d.translateY + "px", width: p.width - 2 + "px", height: p.height - 2 + "px", border: "2px solid silver" }) }; c.onblur = function () { v(this, { border: 0, width: "1px", height: "1px" }); i.setInputValue(n) }; c.onchange = function () { var e = c.value, t = (a.inputDateParser || Date.parse)(e), n = s.xAxis[0], o = n.dataMin, u = n.dataMax; isNaN(t) && (t = e.split("-"), t = Date.UTC(r(t[0]), r(t[1]) - 1, r(t[2]))); isNaN(t) || (yt.global.useUTC || (t += (new Date).getTimezoneOffset() * 6e4), l ? t > i.maxInput.HCTime ? t = U : t < o && (t = o) : t < i.minInput.HCTime ? t = U : t > u && (t = u), t !== U && s.xAxis[0].setExtremes(l ? t : n.min, l ? n.max : t, U, U, { trigger: "rangeSelectorInput" })) } }, render: function (t, n) { var r = this, i = r.chart, s = i.renderer, o = i.container, u = i.options, a = u.exporting && u.navigation && u.navigation.buttonOptions, f = u.rangeSelector, l = r.buttons, u = yt.lang, c = r.div, c = r.inputGroup, h = f.buttonTheme, p = f.inputEnabled !== !1, d = h && h.states, v = i.plotLeft, g; if (!r.rendered && (r.zoomText = s.text(u.rangeSelectorZoom, v, i.plotTop - 10).css(f.labelStyle).add(), g = v + r.zoomText.getBBox().width + 5, Kt(r.buttonOptions, function (e, t) { l[t] = s.button(e.text, g, i.plotTop - 25, function () { r.clickButton(t); r.isActive = !0 }, h, d && d.hover, d && d.select).css({ textAlign: "center" }).add(); g += l[t].width + (f.buttonSpacing || 0); r.selected === t && l[t].setState(2) }), r.updateButtonStates(), p)) r.div = c = m("div", null, { position: "relative", height: 0, zIndex: 1 }), o.parentNode.insertBefore(c, o), r.inputGroup = c = s.g("input-group").add(), c.offset = 0, r.drawInput("min"), r.drawInput("max"); p && (o = i.plotTop - 35, c.align(e({ y: o, width: c.offset, x: a && o < (a.y || 0) + a.height - i.spacing[0] ? -40 : 0 }, f.inputPosition), !0, i.spacingBox), r.setInputValue("min", t), r.setInputValue("max", n)); r.rendered = !0 }, destroy: function () { var e = this.minInput, t = this.maxInput, n = this.chart, r = this.blurInputs, i; en(n.container, "mousedown", r); en(n, "resize", r); L(this.buttons); if (e) e.onfocus = e.onblur = e.onchange = null; if (t) t.onfocus = t.onblur = t.onchange = null; for (i in this) this[i] && i !== "chart" && (this[i].destroy ? this[i].destroy() : this[i].nodeType && A(this[i])), this[i] = null } }; j.prototype.toFixedRange = function (e, t, n, r) { var i = this.chart && this.chart.fixedRange, e = d(n, this.translate(e, !0)), t = d(r, this.translate(t, !0)), n = i && (t - e) / i; n > .7 && n < 1.3 && (r ? e = t - i : t = e + i); return { min: e, max: t} }; w(I.prototype, "init", function (e, t, n) { Zt(this, "init", function () { if (this.options.rangeSelector.enabled) this.rangeSelector = new R(this) }); e.call(this, t, n) }); Highcharts.RangeSelector = R; I.prototype.callbacks.push(function (e) { function t() { s = e.xAxis[0].getExtremes(); o.render(s.min, s.max) } function n() { s = e.xAxis[0].getExtremes(); isNaN(s.min) || u.render(s.min, s.max) } function r(e) { e.triggerOp !== "navigator-drag" && o.render(e.min, e.max) } function i(e) { u.render(e.min, e.max) } var s, o = e.scroller, u = e.rangeSelector; o && (Zt(e.xAxis[0], "afterSetExtremes", r), w(e, "drawChartBox", function (e) { var n = this.isDirtyBox; e.call(this); n && t() }), t()); u && (Zt(e.xAxis[0], "afterSetExtremes", i), Zt(e, "resize", n), n()); Zt(e, "destroy", function () { o && en(e.xAxis[0], "afterSetExtremes", r); u && (en(e, "resize", n), en(e.xAxis[0], "afterSetExtremes", i)) }) }); Highcharts.StockChart = function (e, n) { var r = e.series, i, s = d(e.navigator && e.navigator.enabled, !0) ? { startOnTick: !1, endOnTick: !1} : null, o = { marker: { enabled: !1, states: { hover: { radius: 5}} }, states: { hover: { lineWidth: 2}} }, u = { shadow: !1, borderWidth: 0 }; e.xAxis = Yt(p(e.xAxis || {}), function (e) { return t({ minPadding: 0, maxPadding: 0, ordinal: !0, title: { text: null }, labels: { overflow: "justify" }, showLastLabel: !0 }, e, { type: "datetime", categories: null }, s) }); e.yAxis = Yt(p(e.yAxis || {}), function (e) { i = e.opposite; return t({ labels: { align: i ? "right" : "left", x: i ? -2 : 2, y: -2 }, showLastLabel: !1, title: { text: null} }, e) }); e.series = null; e = t({ chart: { panning: !0, pinchType: "x" }, navigator: { enabled: !0 }, scrollbar: { enabled: !0 }, rangeSelector: { enabled: !0 }, title: { text: null }, tooltip: { shared: !0, crosshairs: !0 }, legend: { enabled: !1 }, plotOptions: { line: o, spline: o, area: o, areaspline: o, arearange: o, areasplinerange: o, column: u, columnrange: u, candlestick: u, ohlc: u} }, e, { _stock: !0, chart: { inverted: !1} }); e.series = r; return new I(e, n) }; w(mn.prototype, "init", function (e, t, n) { var r = n.chart.pinchType || ""; e.call(this, t, n); this.pinchX = this.pinchHor = r.indexOf("x") !== -1; this.pinchY = this.pinchVert = r.indexOf("y") !== -1 }); w(j.prototype, "hideCrosshair", function (e, t, n) { e.call(this, t, n); this.crossLabel && this.crossLabel.hide() }); w(j.prototype, "drawCrosshair", function (t, n, r) { var i, s; t.call(this, n, r); if (c(this.crosshair.label) && this.crosshair.label.enabled && c(r)) { var t = this.chart, o = this.options.crosshair.label, u = this.isXAxis ? "x" : "y", n = this.horiz, a = this.opposite, f = this.left, l = this.top, h = this.crossLabel, p, v, m = o.format, g = ""; if (!h) h = this.crossLabel = t.renderer.label().attr({ align: o.align || n ? "center" : a ? this.labelAlign === "right" ? "right" : "center" : this.labelAlign === "left" ? "left" : "center", zIndex: 12, height: n ? 16 : U, fill: o.backgroundColor || this.series[0] && this.series[0].color || "gray", padding: d(o.padding, 2), stroke: o.borderColor || null, "stroke-width": o.borderWidth || 0 }).css(e({ color: "white", fontWeight: "normal", fontSize: "11px", textAlign: "center" }, o.style)).add(); n ? (p = r.plotX + f, v = l + (a ? 0 : this.height)) : (p = a ? this.width + f : 0, v = r.plotY + l); if (v < l || v > l + this.height) this.hideCrosshair(); else { !m && !o.formatter && (this.isDatetimeAxis && (g = "%b %d, %Y"), m = "{value" + (g ? ":" + g : "") + "}"); h.attr({ x: p, y: v, text: m ? E(m, { value: r[u] }) : o.formatter.call(this, r[u]), visibility: "visible" }); r = h.box; if (n) { if (this.options.tickPosition === "inside" && !a || this.options.tickPosition !== "inside" && a) v = h.y - r.height } else v = h.y - r.height / 2; n ? (i = f - r.x, s = f + this.width - r.x) : (i = this.labelAlign === "left" ? f : 0, s = this.labelAlign === "right" ? f + this.width : t.chartWidth); h.translateX < i && (p += i - h.translateX); h.translateX + r.width >= s && (p -= h.translateX + r.width - s); h.attr({ x: p, y: v, visibility: "visible" }) } } }); var Pn = Tn.init, Hn = Tn.processData, Bn = wn.prototype.tooltipFormatter; Tn.init = function () { Pn.apply(this, arguments); this.setCompare(this.options.compare) }; Tn.setCompare = function (e) { this.modifyValue = e === "value" || e === "percent" ? function (t, n) { var r = this.compareValue, t = e === "value" ? t - r : t = 100 * (t / r) - 100; if (n) n.change = t; return t } : null; if (this.chart.hasRendered) this.isDirty = !0 }; Tn.processData = function () { var e = 0, t, n, r; Hn.apply(this, arguments); if (this.xAxis && this.processedYData) { t = this.processedXData; n = this.processedYData; for (r = n.length; e < r; e++) if (typeof n[e] === "number" && t[e] >= this.xAxis.min) { this.compareValue = n[e]; break } } }; w(Tn, "getExtremes", function (e) { e.call(this); if (this.modifyValue) this.dataMax = this.modifyValue(this.dataMax), this.dataMin = this.modifyValue(this.dataMin) }); j.prototype.setCompare = function (e, t) { this.isXAxis || (Kt(this.series, function (t) { t.setCompare(e) }), d(t, !0) && this.chart.redraw()) }; wn.prototype.tooltipFormatter = function (e) { e = e.replace("{point.change}", (this.change > 0 ? "+" : "") + y(this.change, d(this.series.tooltipOptions.changeDecimals, 2))); return Bn.apply(this, [e]) }; e(Highcharts, { Axis: j, Chart: I, Color: ln, Point: wn, Tick: H, Tooltip: F, Renderer: pt, Series: En, SVGElement: P, SVGRenderer: cn, arrayMin: C, arrayMax: k, charts: Tt, dateFormat: bt, format: E, pathAnim: Et, getOptions: function () { return yt }, hasBidiBug: ct, isTouchDevice: at, numberFormat: y, seriesTypes: zt, setOptions: function (e) { yt = t(!0, yt, e); D(); return yt }, addEvent: Zt, removeEvent: en, createElement: m, discardElement: A, css: v, each: Kt, extend: e, map: Yt, merge: t, pick: d, splat: p, extendClass: g, pInt: r, wrap: w, svg: lt, canvas: ht, vml: !lt && !ht, product: "Highstock", version: "1.3.8" }) })();
//(function(e,t){function n(e,t,n){this.init.call(this,e,t,n)}var r=e.arrayMin,i=e.arrayMax,s=e.each,o=e.extend,u=e.merge,a=e.map,f=e.pick,l=e.pInt,c=e.getOptions().plotOptions,h=e.seriesTypes,p=e.extendClass,d=e.splat,v=e.wrap,m=e.Axis,g=e.Tick,y=e.Point,b=e.Pointer,w=e.CenteredSeriesMixin,E=e.TrackerMixin,S=e.Series,x=Math,T=x.round,N=x.floor,C=x.max,k=e.Color,L=function(){};o(n.prototype,{init:function(e,t,n){var r=this,i=r.defaultOptions;r.chart=t;if(t.angular)i.background={};r.options=e=u(i,e);(e=e.background)&&s([].concat(d(e)).reverse(),function(e){var t=e.backgroundColor,e=u(r.defaultBackgroundOptions,e);if(t)e.backgroundColor=t;e.color=e.backgroundColor;n.options.plotBands.unshift(e)})},defaultOptions:{center:["50%","50%"],size:"85%",startAngle:0},defaultBackgroundOptions:{shape:"circle",borderWidth:1,borderColor:"silver",backgroundColor:{linearGradient:{x1:0,y1:0,x2:0,y2:1},stops:[[0,"#FFF"],[1,"#DDD"]]},from:Number.MIN_VALUE,innerRadius:0,to:Number.MAX_VALUE,outerRadius:"105%"}});var A=m.prototype,g=g.prototype,O={getOffset:L,redraw:function(){this.isDirty=!1},render:function(){this.isDirty=!1},setScale:L,setCategories:L,setTitle:L},M={isRadial:!0,defaultRadialGaugeOptions:{labels:{align:"center",x:0,y:null},minorGridLineWidth:0,minorTickInterval:"auto",minorTickLength:10,minorTickPosition:"inside",minorTickWidth:1,tickLength:10,tickPosition:"inside",tickWidth:2,title:{rotation:0},zIndex:2},defaultRadialXOptions:{gridLineWidth:1,labels:{align:null,distance:15,x:0,y:null},maxPadding:0,minPadding:0,showLastLabel:!1,tickLength:0},defaultRadialYOptions:{gridLineInterpolation:"circle",labels:{align:"right",x:-3,y:-2},showLastLabel:!1,title:{x:4,text:null,rotation:90}},setOptions:function(e){e=this.options=u(this.defaultOptions,this.defaultRadialOptions,e);if(!e.plotBands)e.plotBands=[]},getOffset:function(){A.getOffset.call(this);this.chart.axisOffset[this.side]=0;this.center=this.pane.center=w.getCenter.call(this.pane)},getLinePath:function(e,t){var n=this.center,t=f(t,n[2]/2-this.offset);return this.chart.renderer.symbols.arc(this.left+n[0],this.top+n[1],t,t,{start:this.startAngleRad,end:this.endAngleRad,open:!0,innerR:0})},setAxisTranslation:function(){A.setAxisTranslation.call(this);if(this.center)this.transA=this.isCircular?(this.endAngleRad-this.startAngleRad)/(this.max-this.min||1):this.center[2]/2/(this.max-this.min||1),this.minPixelPadding=this.isXAxis?this.transA*this.minPointOffset:0},beforeSetTickPositions:function(){this.autoConnect&&(this.max+=this.categories&&1||this.pointRange||this.closestPointRange||0)},setAxisSize:function(){A.setAxisSize.call(this);if(this.isRadial){this.center=this.pane.center=e.CenteredSeriesMixin.getCenter.call(this.pane);if(this.isCircular)this.sector=this.endAngleRad-this.startAngleRad;this.len=this.width=this.height=this.center[2]*f(this.sector,1)/2}},getPosition:function(e,t){return this.postTranslate(this.isCircular?this.translate(e):0,f(this.isCircular?t:this.translate(e),this.center[2]/2)-this.offset)},postTranslate:function(e,t){var n=this.chart,r=this.center,e=this.startAngleRad+e;return{x:n.plotLeft+r[0]+Math.cos(e)*t,y:n.plotTop+r[1]+Math.sin(e)*t}},getPlotBandPath:function(e,t,n){var r=this.center,i=this.startAngleRad,s=r[2]/2,o=[f(n.outerRadius,"100%"),n.innerRadius,f(n.thickness,10)],u=/%$/,c,h=this.isCircular;this.options.gridLineInterpolation==="polygon"?r=this.getPlotLinePath(e).concat(this.getPlotLinePath(t,!0)):(h||(o[0]=this.translate(e),o[1]=this.translate(t)),o=a(o,function(e){u.test(e)&&(e=l(e,10)*s/100);return e}),n.shape==="circle"||!h?(e=-Math.PI/2,t=Math.PI*1.5,c=!0):(e=i+this.translate(e),t=i+this.translate(t)),r=this.chart.renderer.symbols.arc(this.left+r[0],this.top+r[1],o[0],o[0],{start:e,end:t,innerR:f(o[1],o[0]-o[2]),open:c}));return r},getPlotLinePath:function(e,t){var n=this,r=n.center,i=n.chart,o=n.getPosition(e),u,a,f;n.isCircular?f=["M",r[0]+i.plotLeft,r[1]+i.plotTop,"L",o.x,o.y]:n.options.gridLineInterpolation==="circle"?(e=n.translate(e))&&(f=n.getLinePath(0,e)):(s(i.xAxis,function(e){e.pane===n.pane&&(u=e)}),f=[],e=n.translate(e),r=u.tickPositions,u.autoConnect&&(r=r.concat([r[0]])),t&&(r=[].concat(r).reverse()),s(r,function(t,n){a=u.getPosition(t,e);f.push(n?"L":"M",a.x,a.y)}));return f},getTitlePosition:function(){var e=this.center,t=this.chart,n=this.options.title;return{x:t.plotLeft+e[0]+(n.x||0),y:t.plotTop+e[1]-{high:.5,middle:.25,low:0}[n.align]*e[2]+(n.y||0)}}};v(A,"init",function(e,r,i){var s;var a=r.angular,l=r.polar,c=i.isX,h=a&&c,p,v;v=r.options;var m=i.pane||0;if(a){if(o(this,h?O:M),p=!c)this.defaultRadialOptions=this.defaultRadialGaugeOptions}else if(l)o(this,M),this.defaultRadialOptions=(p=c)?this.defaultRadialXOptions:u(this.defaultYAxisOptions,this.defaultRadialYOptions);e.call(this,r,i);if(!h&&(a||l)){e=this.options;if(!r.panes)r.panes=[];this.pane=(s=r.panes[m]=r.panes[m]||new n(d(v.pane)[m],r,this),m=s);m=m.options;r.inverted=!1;v.chart.zoomType=null;this.startAngleRad=r=(m.startAngle-90)*Math.PI/180;this.endAngleRad=v=(f(m.endAngle,m.startAngle+360)-90)*Math.PI/180;this.offset=e.offset||0;if((this.isCircular=p)&&i.max===t&&v-r===2*Math.PI)this.autoConnect=!0}});v(g,"getPosition",function(e,t,n,r,i){var s=this.axis;return s.getPosition?s.getPosition(n):e.call(this,t,n,r,i)});v(g,"getLabelPosition",function(e,t,n,r,i,s,o,u,a){var l=this.axis,c=s.y,h=s.align,p=(l.translate(this.pos)+l.startAngleRad+Math.PI/2)/Math.PI*180%360;l.isRadial?(e=l.getPosition(this.pos,l.center[2]/2+f(s.distance,-25)),s.rotation==="auto"?r.attr({rotation:p}):c===null&&(c=l.chart.renderer.fontMetrics(r.styles.fontSize).b-r.getBBox().height/2),h===null&&(h=l.isCircular?p>20&&p<160?"left":p>200&&p<340?"right":"center":"center",r.attr({align:h})),e.x+=s.x,e.y+=c):e=e.call(this,t,n,r,i,s,o,u,a);return e});v(g,"getMarkPath",function(e,t,n,r,i,s,o){var u=this.axis;u.isRadial?(e=u.getPosition(this.pos,u.center[2]/2+r),t=["M",t,n,"L",e.x,e.y]):t=e.call(this,t,n,r,i,s,o);return t});c.arearange=u(c.area,{lineWidth:1,marker:null,threshold:null,tooltip:{pointFormat:'<span style="color:{series.color}">â—</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'},trackByArea:!0,dataLabels:{verticalAlign:null,xLow:0,xHigh:0,yLow:0,yHigh:0},states:{hover:{halo:!1}}});h.arearange=p(h.area,{type:"arearange",pointArrayMap:["low","high"],toYData:function(e){return[e.low,e.high]},pointValKey:"low",getSegments:function(){var e=this;s(e.points,function(t){if(!e.options.connectNulls&&(t.low===null||t.high===null))t.y=null;else if(t.low===null&&t.high!==null)t.y=t.high});S.prototype.getSegments.call(this)},translate:function(){var e=this.yAxis;h.area.prototype.translate.apply(this);s(this.points,function(t){var n=t.low,r=t.high,i=t.plotY;r===null&&n===null?t.y=null:n===null?(t.plotLow=t.plotY=null,t.plotHigh=e.translate(r,0,1,0,1)):r===null?(t.plotLow=i,t.plotHigh=null):(t.plotLow=i,t.plotHigh=e.translate(r,0,1,0,1))})},getSegmentPath:function(e){var t,n=[],r=e.length,i=S.prototype.getSegmentPath,s,o;o=this.options;var u=o.step;for(t=HighchartsAdapter.grep(e,function(e){return e.plotLow!==null});r--;)s=e[r],s.plotHigh!==null&&n.push({plotX:s.plotX,plotY:s.plotHigh});e=i.call(this,t);if(u)u===!0&&(u="left"),o.step={left:"right",center:"center",right:"left"}[u];n=i.call(this,n);o.step=u;o=[].concat(e,n);n[0]="L";this.areaPath=this.areaPath.concat(e,n);return o},drawDataLabels:function(){var e=this.data,t=e.length,n,r=[],i=S.prototype,s=this.options.dataLabels,o,u=this.chart.inverted;if(s.enabled||this._hasPointLabels){for(n=t;n--;)o=e[n],o.y=o.high,o._plotY=o.plotY,o.plotY=o.plotHigh,r[n]=o.dataLabel,o.dataLabel=o.dataLabelUpper,o.below=!1,u?(s.align="left",s.x=s.xHigh):s.y=s.yHigh;i.drawDataLabels&&i.drawDataLabels.apply(this,arguments);for(n=t;n--;)o=e[n],o.dataLabelUpper=o.dataLabel,o.dataLabel=r[n],o.y=o.low,o.plotY=o._plotY,o.below=!0,u?(s.align="right",s.x=s.xLow):s.y=s.yLow;i.drawDataLabels&&i.drawDataLabels.apply(this,arguments)}},alignDataLabel:function(){h.column.prototype.alignDataLabel.apply(this,arguments)},getSymbol:h.column.prototype.getSymbol,drawPoints:L});c.areasplinerange=u(c.arearange);h.areasplinerange=p(h.arearange,{type:"areasplinerange",getPointSpline:h.spline.prototype.getPointSpline});(function(){var e=h.column.prototype;c.columnrange=u(c.column,c.arearange,{lineWidth:1,pointRange:null});h.columnrange=p(h.arearange,{type:"columnrange",translate:function(){var t=this,n=t.yAxis,r;e.translate.apply(t);s(t.points,function(e){var i=e.shapeArgs,s=t.options.minPointLength,o;e.tooltipPos=null;e.plotHigh=r=n.translate(e.high,0,1,0,1);e.plotLow=e.plotY;o=r;e=e.plotY-r;e<s&&(s-=e,e+=s,o-=s/2);i.height=e;i.y=o})},trackerGroups:["group","dataLabels"],drawGraph:L,pointAttrToOptions:e.pointAttrToOptions,drawPoints:e.drawPoints,drawTracker:e.drawTracker,animate:e.animate,getColumnMetrics:e.getColumnMetrics})})();c.gauge=u(c.line,{dataLabels:{enabled:!0,defer:!1,y:15,borderWidth:1,borderColor:"silver",borderRadius:3,crop:!1,style:{fontWeight:"bold"},verticalAlign:"top",zIndex:2},dial:{},pivot:{},tooltip:{headerFormat:""},showInLegend:!1});E={type:"gauge",pointClass:p(y,{setState:function(e){this.state=e}}),angular:!0,drawGraph:L,fixedBox:!0,forceDL:!0,trackerGroups:["group","dataLabels"],translate:function(){var e=this.yAxis,t=this.options,n=e.center;this.generatePoints();s(this.points,function(r){var i=u(t.dial,r.dial),s=l(f(i.radius,80))*n[2]/200,o=l(f(i.baseLength,70))*s/100,a=l(f(i.rearLength,10))*s/100,c=i.baseWidth||3,h=i.topWidth||1,p=t.overshoot,d=e.startAngleRad+e.translate(r.y,null,null,null,!0);p&&typeof p==="number"?(p=p/180*Math.PI,d=Math.max(e.startAngleRad-p,Math.min(e.endAngleRad+p,d))):t.wrap===!1&&(d=Math.max(e.startAngleRad,Math.min(e.endAngleRad,d)));d=d*180/Math.PI;r.shapeType="path";r.shapeArgs={d:i.path||["M",-a,-c/2,"L",o,-c/2,s,-h/2,s,h/2,o,c/2,-a,c/2,"z"],translateX:n[0],translateY:n[1],rotation:d};r.plotX=n[0];r.plotY=n[1]})},drawPoints:function(){var e=this,t=e.yAxis.center,n=e.pivot,r=e.options,i=r.pivot,o=e.chart.renderer;s(e.points,function(t){var n=t.graphic,i=t.shapeArgs,s=i.d,a=u(r.dial,t.dial);n?(n.animate(i),i.d=s):t.graphic=o[t.shapeType](i).attr({stroke:a.borderColor||"none","stroke-width":a.borderWidth||0,fill:a.backgroundColor||"black",rotation:i.rotation}).add(e.group)});n?n.animate({translateX:t[0],translateY:t[1]}):e.pivot=o.circle(0,0,f(i.radius,5)).attr({"stroke-width":i.borderWidth||0,stroke:i.borderColor||"silver",fill:i.backgroundColor||"black"}).translate(t[0],t[1]).add(e.group)},animate:function(e){var t=this;if(!e)s(t.points,function(e){var n=e.graphic;n&&(n.attr({rotation:t.yAxis.startAngleRad*180/Math.PI}),n.animate({rotation:e.shapeArgs.rotation},t.options.animation))}),t.animate=null},render:function(){this.group=this.plotGroup("group","series",this.visible?"visible":"hidden",this.options.zIndex,this.chart.seriesGroup);S.prototype.render.call(this);this.group.clip(this.chart.clipRect)},setData:function(e,t){S.prototype.setData.call(this,e,!1);this.processData();this.generatePoints();f(t,!0)&&this.chart.redraw()},drawTracker:E&&E.drawTrackerPoint};h.gauge=p(h.line,E);c.boxplot=u(c.column,{fillColor:"#FFFFFF",lineWidth:1,medianWidth:2,states:{hover:{brightness:-.3}},threshold:null,tooltip:{pointFormat:'<span style="color:{series.color}">â—</span> <b> {series.name}</b><br/>Maximum: {point.high}<br/>Upper quartile: {point.q3}<br/>Median: {point.median}<br/>Lower quartile: {point.q1}<br/>Minimum: {point.low}<br/>'},whiskerLength:"50%",whiskerWidth:2});h.boxplot=p(h.column,{type:"boxplot",pointArrayMap:["low","q1","median","q3","high"],toYData:function(e){return[e.low,e.q1,e.median,e.q3,e.high]},pointValKey:"high",pointAttrToOptions:{fill:"fillColor",stroke:"color","stroke-width":"lineWidth"},drawDataLabels:L,translate:function(){var e=this.yAxis,t=this.pointArrayMap;h.column.prototype.translate.apply(this);s(this.points,function(n){s(t,function(t){n[t]!==null&&(n[t+"Plot"]=e.translate(n[t],0,1,0,1))})})},drawPoints:function(){var e=this,n=e.points,r=e.options,i=e.chart.renderer,o,u,a,l,c,h,p,d,v,m,g,y,b,w,E,S,x,C,k,L,A,O,M=e.doQuartiles!==!1,_=parseInt(e.options.whiskerLength,10)/100;s(n,function(n){v=n.graphic;A=n.shapeArgs;g={};w={};S={};O=n.color||e.color;if(n.plotY!==t)if(o=n.pointAttr[n.selected?"selected":""],x=A.width,C=N(A.x),k=C+x,L=T(x/2),u=N(M?n.q1Plot:n.lowPlot),a=N(M?n.q3Plot:n.lowPlot),l=N(n.highPlot),c=N(n.lowPlot),g.stroke=n.stemColor||r.stemColor||O,g["stroke-width"]=f(n.stemWidth,r.stemWidth,r.lineWidth),g.dashstyle=n.stemDashStyle||r.stemDashStyle,w.stroke=n.whiskerColor||r.whiskerColor||O,w["stroke-width"]=f(n.whiskerWidth,r.whiskerWidth,r.lineWidth),S.stroke=n.medianColor||r.medianColor||O,S["stroke-width"]=f(n.medianWidth,r.medianWidth,r.lineWidth),S["stroke-linecap"]="round",p=g["stroke-width"]%2/2,d=C+L+p,m=["M",d,a,"L",d,l,"M",d,u,"L",d,c],M&&(p=o["stroke-width"]%2/2,d=N(d)+p,u=N(u)+p,a=N(a)+p,C+=p,k+=p,y=["M",C,a,"L",C,u,"L",k,u,"L",k,a,"L",C,a,"z"]),_&&(p=w["stroke-width"]%2/2,l+=p,c+=p,b=["M",d-L*_,l,"L",d+L*_,l,"M",d-L*_,c,"L",d+L*_,c]),p=S["stroke-width"]%2/2,h=T(n.medianPlot)+p,E=["M",C,h,"L",k,h],v)n.stem.animate({d:m}),_&&n.whiskers.animate({d:b}),M&&n.box.animate({d:y}),n.medianShape.animate({d:E});else{n.graphic=v=i.g().add(e.group);n.stem=i.path(m).attr(g).add(v);if(_)n.whiskers=i.path(b).attr(w).add(v);if(M)n.box=i.path(y).attr(o).add(v);n.medianShape=i.path(E).attr(S).add(v)}})}});c.errorbar=u(c.boxplot,{color:"#000000",grouping:!1,linkedTo:":previous",tooltip:{pointFormat:'<span style="color:{series.color}">â—</span> {series.name}: <b>{point.low}</b> - <b>{point.high}</b><br/>'},whiskerWidth:null});h.errorbar=p(h.boxplot,{type:"errorbar",pointArrayMap:["low","high"],toYData:function(e){return[e.low,e.high]},pointValKey:"high",doQuartiles:!1,drawDataLabels:h.arearange?h.arearange.prototype.drawDataLabels:L,getColumnMetrics:function(){return this.linkedParent&&this.linkedParent.columnMetrics||h.column.prototype.getColumnMetrics.call(this)}});c.waterfall=u(c.column,{lineWidth:1,lineColor:"#333",dashStyle:"dot",borderColor:"#333"});h.waterfall=p(h.column,{type:"waterfall",upColorProp:"fill",pointArrayMap:["low","y"],pointValKey:"y",init:function(e,t){t.stacking=!0;h.column.prototype.init.call(this,e,t)},translate:function(){var e=this.yAxis,t,n,r,i,s,o,u,a,f;t=this.options.threshold;h.column.prototype.translate.apply(this);a=t;r=this.points;for(n=0,t=r.length;n<t;n++){i=r[n];s=i.shapeArgs;o=this.getStack(n);f=o.points[this.index+","+n];if(isNaN(i.y))i.y=this.yData[n];u=C(a,a+i.y)+f[0];s.y=e.translate(u,0,1);i.isSum||i.isIntermediateSum?(s.y=e.translate(f[1],0,1),s.height=e.translate(f[0],0,1)-s.y):a+=o.total;s.height<0&&(s.y+=s.height,s.height*=-1);i.plotY=s.y=T(s.y)-this.borderWidth%2/2;s.height=T(s.height);i.yBottom=s.y+s.height}},processData:function(e){var t=this.yData,n=this.points,r,i=t.length,s=this.options.threshold||0,o,u,a,f,l,c;u=o=a=f=s;for(c=0;c<i;c++)l=t[c],r=n&&n[c]?n[c]:{},l==="sum"||r.isSum?t[c]=u:l==="intermediateSum"||r.isIntermediateSum?(t[c]=o,o=s):(u+=l,o+=l),a=Math.min(u,a),f=Math.max(u,f);S.prototype.processData.call(this,e);this.dataMin=a;this.dataMax=f},toYData:function(e){if(e.isSum)return"sum";else if(e.isIntermediateSum)return"intermediateSum";return e.y},getAttribs:function(){h.column.prototype.getAttribs.apply(this,arguments);var t=this.options,n=t.states,r=t.upColor||this.color,t=e.Color(r).brighten(.1).get(),i=u(this.pointAttr),o=this.upColorProp;i[""][o]=r;i.hover[o]=n.hover.upColor||t;i.select[o]=n.select.upColor||r;s(this.points,function(e){if(e.y>0&&!e.color)e.pointAttr=i,e.color=r})},getGraphPath:function(){var e=this.data,t=e.length,n=T(this.options.lineWidth+this.borderWidth)%2/2,r=[],i,s,o;for(o=1;o<t;o++)s=e[o].shapeArgs,i=e[o-1].shapeArgs,s=["M",i.x+i.width,i.y+n,"L",s.x,i.y+n],e[o-1].y<0&&(s[2]+=i.height,s[5]+=i.height),r=r.concat(s);return r},getExtremes:L,getStack:function(e){var t=this.yAxis.stacks,n=this.stackKey;this.processedYData[e]<this.options.threshold&&(n="-"+n);return t[n][e]},drawGraph:S.prototype.drawGraph});c.bubble=u(c.scatter,{dataLabels:{format:"{point.z}",inside:!0,style:{color:"white",textShadow:"0px 0px 3px black"},verticalAlign:"middle"},marker:{lineColor:null,lineWidth:1},minSize:8,maxSize:"20%",states:{hover:{halo:{size:5}}},tooltip:{pointFormat:"({point.x}, {point.y}), Size: {point.z}"},turboThreshold:0,zThreshold:0});E=p(y,{haloPath:function(){return y.prototype.haloPath.call(this,this.shapeArgs.r+this.series.options.states.hover.halo.size)}});h.bubble=p(h.scatter,{type:"bubble",pointClass:E,pointArrayMap:["y","z"],parallelArrays:["x","y","z"],trackerGroups:["group","dataLabelsGroup"],bubblePadding:!0,pointAttrToOptions:{stroke:"lineColor","stroke-width":"lineWidth",fill:"fillColor"},applyOpacity:function(e){var t=this.options.marker,n=f(t.fillOpacity,.5),e=e||t.fillColor||this.color;n!==1&&(e=k(e).setOpacity(n).get("rgba"));return e},convertAttribs:function(){var e=S.prototype.convertAttribs.apply(this,arguments);e.fill=this.applyOpacity(e.fill);return e},getRadii:function(e,t,n,r){var i,s,o,u=this.zData,a=[],f=this.options.sizeBy!=="width";for(s=0,i=u.length;s<i;s++)o=t-e,o=o>0?(u[s]-e)/(t-e):.5,f&&o>=0&&(o=Math.sqrt(o)),a.push(x.ceil(n+o*(r-n))/2);this.radii=a},animate:function(e){var t=this.options.animation;if(!e)s(this.points,function(e){var n=e.graphic,e=e.shapeArgs;n&&e&&(n.attr("r",1),n.animate({r:e.r},t))}),this.animate=null},translate:function(){var e,n=this.data,r,i,s=this.radii;h.scatter.prototype.translate.call(this);for(e=n.length;e--;)r=n[e],i=s?s[e]:0,r.negative=r.z<(this.options.zThreshold||0),i>=this.minPxSize/2?(r.shapeType="circle",r.shapeArgs={x:r.plotX,y:r.plotY,r:i},r.dlBox={x:r.plotX-i,y:r.plotY-i,width:2*i,height:2*i}):r.shapeArgs=r.plotY=r.dlBox=t},drawLegendSymbol:function(e,t){var n=l(e.itemStyle.fontSize)/2;t.legendSymbol=this.chart.renderer.circle(n,e.baseline-n,n).attr({zIndex:3}).add(t.legendGroup);t.legendSymbol.isMarker=!0},drawPoints:h.column.prototype.drawPoints,alignDataLabel:h.column.prototype.alignDataLabel});m.prototype.beforePadding=function(){var e=this,n=this.len,o=this.chart,u=0,a=n,c=this.isXAxis,h=c?"xData":"yData",p=this.min,d={},v=x.min(o.plotWidth,o.plotHeight),m=Number.MAX_VALUE,g=-Number.MAX_VALUE,y=this.max-p,b=n/y,w=[];this.tickPositions&&(s(this.series,function(t){var n=t.options;if(t.bubblePadding&&(t.visible||!o.options.chart.ignoreHiddenSeries))if(e.allowZoomOutside=!0,w.push(t),c)s(["minSize","maxSize"],function(e){var t=n[e],r=/%$/.test(t),t=l(t);d[e]=r?v*t/100:t}),t.minPxSize=d.minSize,t=t.zData,t.length&&(m=x.min(m,x.max(r(t),n.displayNegative===!1?n.zThreshold:-Number.MAX_VALUE)),g=x.max(g,i(t)))}),s(w,function(e){var t=e[h],n=t.length,r;c&&e.getRadii(m,g,d.minSize,d.maxSize);if(y>0)for(;n--;)typeof t[n]==="number"&&(r=e.radii[n],u=Math.min((t[n]-p)*b-r,u),a=Math.max((t[n]-p)*b+r,a))}),w.length&&y>0&&f(this.options.min,this.userMin)===t&&f(this.options.max,this.userMax)===t&&(a-=n,b*=(n+u-a)/n,this.min+=u/b,this.max+=a/b))};(function(){function e(e,t,n){e.call(this,t,n);if(this.chart.polar)this.closeSegment=function(e){var t=this.xAxis.center;e.push("L",t[0],t[1])},this.closedStacks=!0}function t(e,t){var n=this.chart,r=this.options.animation,i=this.group,s=this.markerGroup,o=this.xAxis.center,u=n.plotLeft,a=n.plotTop;if(n.polar){if(n.renderer.isSVG)r===!0&&(r={}),t?(n={translateX:o[0]+u,translateY:o[1]+a,scaleX:.001,scaleY:.001},i.attr(n),s&&s.attr(n)):(n={translateX:u,translateY:a,scaleX:1,scaleY:1},i.animate(n,r),s&&s.animate(n,r),this.animate=null)}else e.call(this,t)}var n=S.prototype,r=b.prototype,i;n.toXY=function(e){var t,n=this.chart,r=e.plotX;t=e.plotY;e.rectPlotX=r;e.rectPlotY=t;r=(r/Math.PI*180+this.xAxis.pane.options.startAngle)%360;r<0&&(r+=360);e.clientX=r;t=this.xAxis.postTranslate(e.plotX,this.yAxis.len-t);e.plotX=e.polarPlotX=t.x-n.plotLeft;e.plotY=e.polarPlotY=t.y-n.plotTop};n.orderTooltipPoints=function(e){if(this.chart.polar&&(e.sort(function(e,t){return e.clientX-t.clientX}),e[0]))e[0].wrappedClientX=e[0].clientX+360,e.push(e[0])};h.area&&v(h.area.prototype,"init",e);h.areaspline&&v(h.areaspline.prototype,"init",e);h.spline&&v(h.spline.prototype,"getPointSpline",function(e,t,n,r){var i,s,o,u,a,f,l;if(this.chart.polar){i=n.plotX;s=n.plotY;e=t[r-1];o=t[r+1];this.connectEnds&&(e||(e=t[t.length-2]),o||(o=t[1]));if(e&&o)u=e.plotX,a=e.plotY,t=o.plotX,f=o.plotY,u=(1.5*i+u)/2.5,a=(1.5*s+a)/2.5,o=(1.5*i+t)/2.5,l=(1.5*s+f)/2.5,t=Math.sqrt(Math.pow(u-i,2)+Math.pow(a-s,2)),f=Math.sqrt(Math.pow(o-i,2)+Math.pow(l-s,2)),u=Math.atan2(a-s,u-i),a=Math.atan2(l-s,o-i),l=Math.PI/2+(u+a)/2,Math.abs(u-l)>Math.PI/2&&(l-=Math.PI),u=i+Math.cos(l)*t,a=s+Math.sin(l)*t,o=i+Math.cos(Math.PI+l)*f,l=s+Math.sin(Math.PI+l)*f,n.rightContX=o,n.rightContY=l;r?(n=["C",e.rightContX||e.plotX,e.rightContY||e.plotY,u||i,a||s,i,s],e.rightContX=e.rightContY=null):n=["M",i,s]}else n=e.call(this,t,n,r);return n});v(n,"translate",function(e){e.call(this);if(this.chart.polar&&!this.preventPostTranslate)for(var e=this.points,t=e.length;t--;)this.toXY(e[t])});v(n,"getSegmentPath",function(e,t){var n=this.points;if(this.chart.polar&&this.options.connectEnds!==!1&&t[t.length-1]===n[n.length-1]&&n[0].y!==null)this.connectEnds=!0,t=[].concat(t,[n[0]]);return e.call(this,t)});v(n,"animate",t);v(n,"setTooltipPoints",function(e,t){this.chart.polar&&o(this.xAxis,{tooltipLen:360});return e.call(this,t)});if(h.column)i=h.column.prototype,v(i,"animate",t),v(i,"translate",function(e){var t=this.xAxis,n=this.yAxis.len,r=t.center,i=t.startAngleRad,s=this.chart.renderer,o,u;this.preventPostTranslate=!0;e.call(this);if(t.isRadial){t=this.points;for(u=t.length;u--;)o=t[u],e=o.barX+i,o.shapeType="path",o.shapeArgs={d:s.symbols.arc(r[0],r[1],n-o.plotY,null,{start:e,end:e+o.pointWidth,innerR:n-f(o.yBottom,n)})},this.toXY(o),o.tooltipPos=[o.plotX,o.plotY],o.ttBelow=o.plotY>r[1]}}),v(i,"alignDataLabel",function(e,t,r,i,s,o){if(this.chart.polar){e=t.rectPlotX/Math.PI*180;if(i.align===null)i.align=e>20&&e<160?"left":e>200&&e<340?"right":"center";if(i.verticalAlign===null)i.verticalAlign=e<45||e>315?"bottom":e>135&&e<225?"top":"middle";n.alignDataLabel.call(this,t,r,i,s,o)}else e.call(this,t,r,i,s,o)});v(r,"getIndex",function(e,t){var n,r=this.chart,i;r.polar?(i=r.xAxis[0].center,n=t.chartX-i[0]-r.plotLeft,r=t.chartY-i[1]-r.plotTop,n=180-Math.round(Math.atan2(n,r)/Math.PI*180)):n=e.call(this,t);return n});v(r,"getCoordinates",function(e,t){var n=this.chart,r={xAxis:[],yAxis:[]};n.polar?s(n.axes,function(e){var i=e.isXAxis,s=e.center,o=t.chartX-s[0]-n.plotLeft,s=t.chartY-s[1]-n.plotTop;r[i?"xAxis":"yAxis"].push({axis:e,value:e.translate(i?Math.PI-Math.atan2(o,s):Math.sqrt(Math.pow(o,2)+Math.pow(s,2)),!0)})}):r=e.call(this,t);return r})})()})(Highcharts);
(function (e) { var t = e.Chart, n = e.addEvent, r = e.removeEvent, i = e.createElement, s = e.discardElement, o = e.css, u = e.merge, a = e.each, f = e.extend, l = Math.max, c = document, h = window, p = e.isTouchDevice, d = e.Renderer.prototype.symbols, v = e.getOptions(), m; f(v.lang, { printChart: "Print chart", downloadPNG: "Download PNG image", downloadJPEG: "Download JPEG image", downloadPDF: "Download PDF document", downloadSVG: "Download SVG vector image", contextButtonTitle: "Chart context menu" }); v.navigation = { menuStyle: { border: "1px solid #A0A0A0", background: "#FFFFFF", padding: "5px 0" }, menuItemStyle: { padding: "0 10px", background: "none", color: "#303030", fontSize: p ? "14px" : "11px" }, menuItemHoverStyle: { background: "#4572A5", color: "#FFFFFF" }, buttonOptions: { symbolFill: "#E0E0E0", symbolSize: 14, symbolStroke: "#666", symbolStrokeWidth: 3, symbolX: 12.5, symbolY: 10.5, align: "right", buttonSpacing: 3, height: 22, theme: { fill: "white", stroke: "none" }, verticalAlign: "top", width: 24 } }; v.exporting = { type: "image/png", url: "http://export.highcharts.com/", buttons: { contextButton: { menuClassName: "highcharts-contextmenu", symbol: "menu", _titleKey: "contextButtonTitle", menuItems: [{ textKey: "printChart", onclick: function () { this.print() } }, { separator: !0 }, { textKey: "downloadPNG", onclick: function () { this.exportChart() } }, { textKey: "downloadJPEG", onclick: function () { this.exportChart({ type: "aimage/jpeg" }) } }, { textKey: "downloadPDF", onclick: function () { this.exportChart({ type: "application/pdf" }) } }, { textKey: "downloadSVG", onclick: function () { this.exportChart({ type: "image/svg+xml" }) } }] } } }; e.post = function (e, t, n) { var r, e = i("form", u({ method: "post", action: e, enctype: "multipart/form-data" }, n), { display: "none" }, c.body); for (r in t) i("input", { type: "hidden", name: r, value: t[r] }, null, e); e.submit(); s(e) }; f(t.prototype, { getSVG: function (t) { var n = this, r, o, l, h, p = u(n.options, t); if (!c.createElementNS) c.createElementNS = function (e, t) { return c.createElement(t) }; t = i("div", null, { position: "absolute", top: "-9999em", width: n.chartWidth + "px", height: n.chartHeight + "px" }, c.body); o = n.renderTo.style.width; h = n.renderTo.style.height; o = p.exporting.sourceWidth || p.chart.width || /px$/.test(o) && parseInt(o, 10) || 600; h = p.exporting.sourceHeight || p.chart.height || /px$/.test(h) && parseInt(h, 10) || 400; f(p.chart, { animation: !1, renderTo: t, forExport: !0, width: o, height: h }); p.exporting.enabled = !1; p.series = []; a(n.series, function (e) { l = u(e.options, { animation: !1, showCheckbox: !1, visible: e.visible }); l.isInternal || p.series.push(l) }); r = new e.Chart(p, n.callback); a(["xAxis", "yAxis"], function (e) { a(n[e], function (t, n) { var i = r[e][n], s = t.getExtremes(), o = s.userMin, s = s.userMax; i && (o !== void 0 || s !== void 0) && i.setExtremes(o, s, !0, !1) }) }); o = r.container.innerHTML; p = null; r.destroy(); s(t); o = o.replace(/zIndex="[^"]+"/g, "").replace(/isShadow="[^"]+"/g, "").replace(/symbolName="[^"]+"/g, "").replace(/jQuery[0-9]+="[^"]+"/g, "").replace(/url\([^#]+#/g, "url(#").replace(/<svg /, '<svg xmlns:xlink="http://www.w3.org/1999/xlink" ').replace(/ href=/g, " xlink:href=").replace(/\n/, " ").replace(/<\/svg>.*?$/, "</svg>").replace(/&nbsp;/g, "Â ").replace(/&shy;/g, "Â­").replace(/<IMG /g, "<image ").replace(/height=([^" ]+)/g, 'height="$1"').replace(/width=([^" ]+)/g, 'width="$1"').replace(/hc-svg-href="([^"]+)">/g, 'xlink:href="$1"/>').replace(/id=([^" >]+)/g, 'id="$1"').replace(/class=([^" >]+)/g, 'class="$1"').replace(/ transform /g, " ").replace(/:(path|rect)/g, "$1").replace(/style="([^"]+)"/g, function (e) { return e.toLowerCase() }); return o = o.replace(/(url\(#highcharts-[0-9]+)&quot;/g, "$1").replace(/&quot;/g, "'") }, exportChart: function (t, n) { var t = t || {}, r = this.options.exporting, r = this.getSVG(u({ chart: { borderRadius: 0 } }, r.chartOptions, n, { exporting: { sourceWidth: t.sourceWidth || r.sourceWidth, sourceHeight: t.sourceHeight || r.sourceHeight } })), t = u(this.options.exporting, t); e.post(t.url, { filename: t.filename || "chart", type: t.type, width: t.width || 0, scale: t.scale || 2, svg: r }, t.formAttributes) }, print: function () { var e = this, t = e.container, n = [], r = t.parentNode, i = c.body, s = i.childNodes; if (!e.isPrinting) e.isPrinting = !0, a(s, function (e, t) { if (e.nodeType === 1) n[t] = e.style.display, e.style.display = "none" }), i.appendChild(t), h.focus(), h.print(), setTimeout(function () { r.appendChild(t); a(s, function (e, t) { if (e.nodeType === 1) e.style.display = n[t] }); e.isPrinting = !1 }, 1e3) }, contextMenu: function (e, t, s, u, c, h, p) { var d = this, v = d.options.navigation, m = v.menuItemStyle, g = d.chartWidth, y = d.chartHeight, b = "cache-" + e, w = d[b], E = l(c, h), S, x, T, N = function (t) { d.pointer.inClass(t.target, e) || x() }; if (!w) d[b] = w = i("div", { className: e }, { position: "absolute", zIndex: 1e3, padding: E + "px" }, d.container), S = i("div", null, f({ MozBoxShadow: "3px 3px 10px #888", WebkitBoxShadow: "3px 3px 10px #888", boxShadow: "3px 3px 10px #888" }, v.menuStyle), w), x = function () { o(w, { display: "none" }); p && p.setState(0); d.openMenu = !1 }, n(w, "mouseleave", function () { T = setTimeout(x, 500) }), n(w, "mouseenter", function () { clearTimeout(T) }), n(document, "mouseup", N), n(d, "destroy", function () { r(document, "mouseup", N) }), a(t, function (e) { if (e) { var t = e.separator ? i("hr", null, null, S) : i("div", { onmouseover: function () { o(this, v.menuItemHoverStyle) }, onmouseout: function () { o(this, m) }, onclick: function () { x(); e.onclick.apply(d, arguments) }, innerHTML: e.text || d.options.lang[e.textKey] }, f({ cursor: "pointer" }, m), S); d.exportDivElements.push(t) } }), d.exportDivElements.push(S, w), d.exportMenuWidth = w.offsetWidth, d.exportMenuHeight = w.offsetHeight; t = { display: "block" }; s + d.exportMenuWidth > g ? t.right = g - s - c - E + "px" : t.left = s - E + "px"; u + h + d.exportMenuHeight > y && p.alignOptions.verticalAlign !== "top" ? t.bottom = y - u - E + "px" : t.top = u + h - E + "px"; o(w, t); d.openMenu = !0 }, addButton: function (t) { var n = this, r = n.renderer, i = u(n.options.navigation.buttonOptions, t), s = i.onclick, o = i.menuItems, a, l, c = { stroke: i.symbolStroke, fill: i.symbolFill }, h = i.symbolSize || 12; if (!n.btnCount) n.btnCount = 0; if (!n.exportDivElements) n.exportDivElements = [], n.exportSVGElements = []; if (i.enabled !== !1) { var p = i.theme, d = p.states, v = d && d.hover, d = d && d.select, g; delete p.states; s ? g = function () { s.apply(n, arguments) } : o && (g = function () { n.contextMenu(l.menuClassName, o, l.translateX, l.translateY, l.width, l.height, l); l.setState(2) }); i.text && i.symbol ? p.paddingLeft = e.pick(p.paddingLeft, 25) : i.text || f(p, { width: i.width, height: i.height, padding: 0 }); l = r.button(i.text, 0, 0, g, p, v, d).attr({ title: n.options.lang[i._titleKey], "stroke-linecap": "round" }); l.menuClassName = t.menuClassName || "highcharts-menu-" + n.btnCount++; i.symbol && (a = r.symbol(i.symbol, i.symbolX - h / 2, i.symbolY - h / 2, h, h).attr(f(c, { "stroke-width": i.symbolStrokeWidth || 1, zIndex: 1 })).add(l)); l.add().align(f(i, { width: l.width, x: e.pick(i.x, m) }), !0, "spacingBox"); m += (l.width + i.buttonSpacing) * (i.align === "right" ? -1 : 1); n.exportSVGElements.push(l, a) } }, destroyExport: function (e) { var e = e.target, t, n; for (t = 0; t < e.exportSVGElements.length; t++) if (n = e.exportSVGElements[t]) n.onclick = n.ontouchstart = null, e.exportSVGElements[t] = n.destroy(); for (t = 0; t < e.exportDivElements.length; t++) n = e.exportDivElements[t], r(n, "mouseleave"), e.exportDivElements[t] = n.onmouseout = n.onmouseover = n.ontouchstart = n.onclick = null, s(n) } }); d.menu = function (e, t, n, r) { return ["M", e, t + 2.5, "L", e + n, t + 2.5, "M", e, t + r / 2 + .5, "L", e + n, t + r / 2 + .5, "M", e, t + r - 1.5, "L", e + n, t + r - 1.5] }; t.prototype.callbacks.push(function (e) { var t, r = e.options.exporting, i = r.buttons; m = 0; if (r.enabled !== !1) { for (t in i) e.addButton(i[t]); n(e, "destroy", e.destroyExport) } }) })(Highcharts);

function showLogDetails(msg, taskName, additional) {
    String.prototype.replaceAll = function (find, replace) {
        return this.replace(new RegExp(find, 'g'), replace);
    }
    msg = msg.replaceAll('<ž>', '\"');
    console.log(msg + "  " + taskName);
    $('#dialogMsg').empty();
    $('#dialogMsg').css('max-height', '300px');
    //    else {
    //        var inputtype = "<INPUT name=\"feedBrowserBtn\" title=\"Click to open feed browser\" style=\"BORDER-LEFT-WIDTH: 0px; BORDER-RIGHT-WIDTH: 0px; BORDER-BOTTOM-WIDTH: 0px; BORDER-TOP-WIDTH: 0px\" onclick=\"openFeedBrowserFromTaskStatusCommonTaskManager('" + attrValue + "');return false;\" type=image src=\"App_Themes/Aqua/images/aggregatedDetailsIcon.gif\" Text=\"\" />"
    //        //$('#dialogMsg').append("Link : <div>" + msg.substr(msg.indexOf("#####") + 5) + "</div> Log Description :<div class='wordwrap' style='background-color: rgb(250, 250, 250);max-height: 300px;overflow: auto;padding: 10px;margin-top: 8px;box-shadow: 0px 0px 5px rgb(139, 139, 139) inset;'>" + msg + "</div>");
    //        $('#dialogMsg').append("Link : <div>" + inputtype + "</div> Log Description :<div class='wordwrap' style='background-color: rgb(250, 250, 250);max-height: 300px;overflow: auto;padding: 10px;margin-top: 8px;box-shadow: 0px 0px 5px rgb(139, 139, 139) inset;'>" + msg + "</div>");
    //    }
    $('#dialogMsg').append("<div class='wordwrap' style='max-height: 300px;overflow: auto;padding: 10px;margin-top: 8px;'>" + $('<div />').text(msg).html().replaceAll('&lt;\br&gt;', '<br>').replaceAll('&lt;\ br&gt;', '<br>').replaceAll('&lt;br/&gt;', '<br>').replaceAll('&lt;br /&gt;', '<br>').replaceAll('&lt;br&gt;', '<br>').replaceAll('&lt;/br&gt;', '<br>').replaceAll('&lt;/ br&gt;', '<br>') + "</div>");
    if (typeof additional !== 'undefined' && additional !== "") {
        $('#dialogMsg').append('<div class="CTMadditionalInfoTopHeader"> Additional Info :</div><div class="CTMadditionalInfo" style="box-shadow: none !important; background: none !important;">' + additional.replaceAll('ž', '●') + '</div>');
        var cont = $('.CTMLinkSpan');
        cont.unbind('click').click(function (e) {
            if ($(this).attr('action') === 'openinnewtab') {
                var objDate = new Date();
                var str = objDate.toString();
                str = objDate.getDate().toString() + objDate.getMonth().toString() + objDate.getFullYear().toString() + objDate.getHours().toString() + objDate.getMinutes().toString() + objDate.getSeconds().toString() + objDate.getMilliseconds().toString() + eval('Math.round(Math.random() * 10090)').toString();

                var path = window.location.protocol + '//' + window.location.host;
                var pathname = window.location.pathname.split('/');

                $.each(pathname, function (ii, ee) {
                    if ((ii !== 0) && (ii !== pathname.length - 1))
                        path = path + '/' + ee;
                });
                window.parent.leftMenu.createTab('', path + '/Download.aspx?physicalpath=' + $(this).attr('path') + '&opentab=true', str, $(this).html().trim());
            }
        });
    }
    $('#dialog').dialog({
        title: taskName,
        modal: true,
        width: '483px',
        height: 'auto',
        resizable: false,
        buttons: {
            "Ok": function () {
                $(this).dialog("close")
            }
        }
    });
    $('#dialog').dialog('option', 'title', taskName);
};

function TSResizeGrid() {
    $find(gridId).get_GridInfo().Height = $(window).height() - 125 + "px";
    $('#' + $find(gridId).get_GridInfo().GridId).width('100%');

    $(window).unbind('message').bind('message', function (e) {
        debugger; if (e.originalEvent.data == 'resize') {
            $find(gridId).refreshWithCache();
        }
    });
}

function show_no_records_div() {
    var showNoRecordsDiv = $('#showNoRecordsDiv_hf').val().toLowerCase();
    if (showNoRecordsDiv == 'false') {
        $('#taskStatus_Border_display').css('display', 'none');
        if (window.parent.parent.leftMenu != "undefined")
            window.parent.parent.leftMenu.hideNoRecordsMsg();
    }
    else {
        var top = $('[id$=panelTop]').outerHeight();
        $('#taskStatus_EmptyGridContainer').css('top', (top + 20));
        $('#taskStatus_Border_display').css('display', 'block');
        if (window.parent.parent.leftMenu != "undefined")
            window.parent.leftMenu.showNoRecordsMsg("No tasks found matching your search criteria", $("#taskStatus_EmptyGridContainer"));
        $('#showNoRecordsDiv_hf').val('false');
    }
}
function dateFilterHtml() {
    if ($('[id*=hdnHtmlString]').val() != '')
        $('.dateFilterText').text($('[id*=hdnHtmlString]').val());
}

function ExecuteSynchronously(url, method, args) {
    var executor = new Sys.Net.XMLHttpSyncExecutor();
    var request = new Sys.Net.WebRequest();
    request.set_url(url + '/' + method);
    request.set_httpVerb('POST');
    request.get_headers()['Content-Type'] = 'application/json; charset=utf-8';
    request.set_executor(executor);
    request.set_body(Sys.Serialization.JavaScriptSerializer.serialize(args));
    request.invoke();
    if (executor.get_responseAvailable()) {
        return (executor.get_object());
    }
    return (false);
}

function processFilters(filterGroupItems, filterGroupHeaderID, filterGroupHeaderTitle, checkedValuesList, txtId, txtName, filterType, checkerItem, isSearchable, isDateTypeControl, selectAllText, state) {
    var filterItems = [];
    var checkedValuesArray = checkedValuesList.split(',');
    $.each(filterGroupItems, function (index, item) {
        var objFilterItem = {};
        objFilterItem.text = item[txtName];
        objFilterItem.value = item[txtId];
        if (checkedValuesArray.indexOf(item[checkerItem].toString()) > -1)
            objFilterItem.isSelected = "true";
        else
            objFilterItem.isSelected = "false";
        if (isDateTypeControl) {
            objFilterItem.dateFilterType = item.dateFilterType;
            objFilterItem.rangeStartDate = item.rangeStartDate;
            objFilterItem.rangeEndDate = item.rangeEndDate;
            objFilterItem.singleDate = item.singleDate;
            objFilterItem.dateType = item.dateType;
        }
        filterItems.push(objFilterItem);
    });
    var filterDataItem = {};
    if (filterGroupHeaderID != null)
        filterDataItem.identity = filterGroupHeaderID;
    filterDataItem.sectionHeader = filterGroupHeaderTitle;
    if (selectAllText != null)
        filterDataItem.selectAllText = selectAllText;
    filterDataItem.state = state;
    filterDataItem.sectionType = filterType;
    filterDataItem.listItems = filterItems;
    filterDataItem.isSearchable = isSearchable;
    filterDataItem.maxHeight = $(window).height() - 425;
    return filterDataItem;
}

function CallCommonServiceMethod(methodName, parameters, ajaxSuccess, ajaxError, userContext, isCrossDomain) {
    //  callService('POST', path + '/BaseUserControls/Service/CommonService.svc', methodName, parameters, ajaxSuccess, ajaxError, null, userContext, isCrossDomain);
    var webServicePath = $('[id$="servicePath"]').val() + ($('[id$="servicePath"]').val().endsWith("/") ? "" : "/") + "Services/TaskStatusWebMethods.asmx";
    var taskStatusBasicInfo = ExecuteSynchronously(webServicePath, methodName, parameters);
    //var allStatus = {};
    //allStatus.d = taskStatusBasicInfo.d.Status;
    var taskStatusInfo = JSON.parse(taskStatusBasicInfo.d);
    var allTaskStatus = {};
    allTaskStatus.d = taskStatusInfo.TaskStatus;
    var allTaskTypes = {};
    allTaskTypes.d = taskStatusInfo.TaskType;
    var selectAllTaskStatus = '';
    var selectAllTaskType = '';


    for (var i in allTaskStatus.d) {
        selectAllTaskStatus += (allTaskStatus.d[i].TaskStatusName) + ',';
    }

    for (var i in allTaskTypes.d) {
        selectAllTaskType += (allTaskTypes.d[i].TaskTypeDetailsName) + ',';
    }

    selectAllTaskStatus = selectAllTaskStatus.substring(0, selectAllTaskStatus.length - 1);
    selectAllTaskType = selectAllTaskType.substring(0, selectAllTaskType.length - 1);



    var filterData = [];
    //filterData.push(processFilters(allStatus.d, 'Status', 'Status', 'Most Recent', 'StatusId', 'StatusName', 'radio', 'StatusName', false, true, null, "up"));

    var hdnFieldEmpty = $('#hdnGetTaskTypeWithStatus').val();
    if (hdnFieldEmpty == '') {
        filterData.push(processFilters(allTaskTypes.d, 'TaskType', 'Task Type', selectAllTaskType, 'TaskTypeDetailsId', 'TaskTypeDetailsName', 'checkbox', 'TaskTypeDetailsName', false, true, "ALL", "up"));
        filterData.push(processFilters(allTaskStatus.d, 'TaskStatus', 'Task Status', selectAllTaskStatus, 'TaskStatusId', 'TaskStatusName', 'checkbox', 'TaskStatusName', false, true, "ALL", "up"));
        bindSlideMenu(filterData);
    }
    else if (hdnFieldEmpty != '') {
        var hdnFieldValue = $('#hdnGetTaskTypeWithStatus').val().split('<$>');
        var taskType = hdnFieldValue[0];
        var taskStatus = hdnFieldValue[1];
        filterData.push(processFilters(allTaskTypes.d, 'TaskType', 'Task Type', taskType, 'TaskTypeDetailsId', 'TaskTypeDetailsName', 'checkbox', 'TaskTypeDetailsName', false, true, "ALL", "up"));
        filterData.push(processFilters(allTaskStatus.d, 'TaskStatus', 'Task Status', taskStatus, 'TaskStatusId', 'TaskStatusName', 'checkbox', 'TaskStatusName', false, true, "ALL", "up"));
        bindSlideMenu(filterData);
    }
}

function filterApply() {
    $('[id$=btnGetStatus]').trigger('click');
    return false;
}

function bindSlideMenu(filterData) {
    var rightFilterContainer = $("#SMDashboardRightFilterContainer");
    rightFilterContainer.empty();

    var objFilterData = {};
    objFilterData.pivotElementId = "SMDashboardRightFilter";
    objFilterData.id = "SMDashboardRightFilterDiv";
    objFilterData.container = rightFilterContainer;
    objFilterData.data = filterData;
    smslidemenu.init(objFilterData, function () { filterApply(); });

    var txtInProgressLimit = $('#txtInProgressLimit');
    var spanInProgressLimit = $('#spanInProgressLimit');

    filtersSelectedDataSelected = smslidemenu.getAllData("SMDashboardRightFilterDiv");
    $('#smSlideMenuApplyBtn').css('float', 'right');
}

function OnSuccess_GetTaskStatusInfo(result) {
}
function OnFailure(result) {
}

function initializeDivFilterDate() {
    var obj = {};
    obj.dateOptions = [0, 1, 2, 3, 4];
    obj.dateFormat = 'd/m/Y';
    obj.lefttimePicker = true;
    obj.righttimePicker = false;
    obj.calenderType = 0;
    obj.calenderID = 'smdd_0';
    obj.pivotElement = $('.dateFilterText');
    // obj.pivotElement = $('[id$=labeldateselectiondiv]');
    if ($('[id$=hdnStartDateCalender]').val() == '') {
        obj.StartDateCalender = com.ivp.rad.rscriptutils.RSDateTimeUtils.convertDateTimeToString(new Date(), com.ivp.rad.rscriptutils.RSDateTimeUtils.getCultureFormat(com.ivp.rad.rscriptutils.DateTimeFormat.longDate));
        obj.EndDateCalender = com.ivp.rad.rscriptutils.RSDateTimeUtils.convertDateTimeToString(new Date(), com.ivp.rad.rscriptutils.RSDateTimeUtils.getCultureFormat(com.ivp.rad.rscriptutils.DateTimeFormat.shorDate));
    }
    else {
        obj.StartDateCalender = $('[id$=hdnStartDateCalender]').val();
        obj.EndDateCalender = $('[id$=hdnEndDateCalender]').val();
    }
    if ($('[id$=hdnTopOption]').val() == -1) {
        obj.selectedTopOption = 0; //Today

    }
    else
        obj.selectedTopOption = $('[id$=hdnTopOption]').val();

    obj.selectedCustomRadioOption = $('[id$=hdnCustomRadioOption]').val();
    obj.applyCallback = function () {

        // $("#smdd_1").css('display', 'none');
        var modifiedText = smdatepickercontrol.getResponse($("#smdd_0"));
        var htmlString = "";
        var prepString = "";

        var selectedEndDate = modifiedText.selectedEndDate;
        var selectedStartDate = modifiedText.selectedStartDate;
        var selectedText = modifiedText.selectedText;
        var selectedDateOption = modifiedText.selDateOption;
        var selectedRadioOption = modifiedText.selRadioOption;
        var serverStartDate = modifiedText.serverStartDate;
        var serverEndDate = modifiedText.serverEndDate;
        var serverEndDateOriginal = modifiedText.serverEndDateOriginal;
        var serverStartDateLongDate = modifiedText.serverStartDateLongDate;

        if (selectedStartDate != null) {
            selectedStartDate = com.ivp.rad.rscriptutils.RSDateTimeUtils.convertDateTimeToString(new Date(selectedStartDate), com.ivp.rad.rscriptutils.RSDateTimeUtils.getCultureFormat(com.ivp.rad.rscriptutils.DateTimeFormat.longDate));
            $('[id$=hdnStartDateCalender]').val(selectedStartDate);
        } if (selectedEndDate != null) {
            selectedEndDate = com.ivp.rad.rscriptutils.RSDateTimeUtils.convertDateTimeToString(new Date(selectedEndDate), com.ivp.rad.rscriptutils.RSDateTimeUtils.getCultureFormat(com.ivp.rad.rscriptutils.DateTimeFormat.shorDate));
            $('[id$=hdnEndDateCalender]').val(selectedEndDate);
        }

        if (selectedText != undefined) {
            if (selectedText.toUpperCase() === "TODAY")
                htmlString = "Today";
            else if (selectedText.toUpperCase() === "SINCE YESTERDAY")
                htmlString = "Since Yesterday";
            else if (selectedText.toUpperCase() === "THIS WEEK")
                htmlString = "This Week";
            else if (selectedText.toUpperCase() === "ANYTIME")
            { prepString = ""; htmlString = "Anytime"; }
            else if (selectedText.toUpperCase() === "CUSTOM DATE") {
                if (selectedRadioOption == 0)
                    htmlString = " after " + selectedStartDate;
                else if (selectedRadioOption == 1)
                    htmlString = " between " + selectedStartDate + " to " + selectedEndDate;
                else if (selectedRadioOption == 2)
                    htmlString = " before " + selectedEndDate;
            }
            $('[id$=hdnTopOption]').val(selectedDateOption);
            $('[id$=hdnCustomRadioOption]').val(selectedRadioOption);
            $('[id$=hdnFirstTime]').val('0');
            //  $('[id$=labeldateselectiondiv]').text(htmlString);
            $('.dateFilterText').text(htmlString);
            //   SMSDownstreamSystemStatusMethods.prototype._controls.HdnExceptionDate().val(selectedDateOption);
            $('[id*=txtStartDate]').val(serverStartDateLongDate);
            $('[id*=txtEndDate]').val(serverEndDateOriginal);
            //Short End Date
            $('[id*=txtEndDateShort]').val(serverEndDateOriginal);
            $('[id*=hdnHtmlString]').val(htmlString);
        }
        var errormsg = validateDates();
        if (errormsg == '')
            filterApply();
        return errormsg
    }

    obj.ready = function (e) {
    }
    smdatepickercontrol.init(obj);
}

function validateDates() {
    var webServicePath = $('[id$="servicePath"]').val() + ($('[id$="servicePath"]').val().endsWith("/") ? "" : "/") + "Services/TaskStatusWebMethods.asmx";
    checked = $('[id$=hdnCustomRadioOption]').val();
    marked = $('[id$=hdnTopOption]').val();
    startDate = $('[id*=txtStartDate]').val();
    endDate = $('[id*=txtEndDate]').val();
    if (startDate == "")
        startDate = null;
    if (endDate == "")
        endDate = null;
    var errormsg = '';
    if (marked == '4') {
        switch (checked) {

            case '0': //From
                errormsg = CompareDateFromTodaysDateUS(webServicePath, $('[id*=txtStartDate]').val(), 'Start Date');
                break;
            case '1':
                errormsg = CompareDateFromTodaysDateUS(webServicePath, $('[id*=txtStartDate]').val(), 'Start Date');
                if (errormsg == '')
                    errormsg = CompareDateFromTodaysDateUS(webServicePath, $('[id*=txtEndDateShort]').val(), 'End Date');
                if (errormsg == '')
                    errormsg = CompareDateUS(webServicePath, $('[id*=txtStartDate]').val(), $('[id*=txtEndDateShort]').val());
                break;
            case '2':
                errormsg = CompareDateFromTodaysDateUS(webServicePath, $('[id*=txtEndDateShort]').val(), 'End Date');
                break;
        }
    }
    return errormsg;
}